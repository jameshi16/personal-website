







<!doctype html>
<html class="height-full">
  <head>
    <meta charset="utf-8">
    <meta name="description" content="EDIT (13/5/2024): A quick note for the various mentions of Immersed in this post. The company hasrecently removed support for physical multi-monitor setups, requiring you to turn off all externalmonitors to use Immersed. While the company reserves all rights to do whatever they want with theirsof..." />
    <title>CodingIndex's Random Shenanigans</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Blog posts (last 10, atom feed)">
    <link href="/feed/anime.xml" type="application/atom+xml" rel="alternate" title="Weaboo Corner (last 10, atom feed)">
    <link href="/assets/styles.css" rel="stylesheet" type="text/css">
    <link href="/favicon.png" rel="icon" type="image/png" sizes="128x128">
  </head>
  <body class="height-full" style="width: 100vw; overflow-x: hidden">




  <div class="container-xl pt-6 p-responsive text-center">
    

<img src="/CodingIndex.png" class="mb-3" style="max-width: 150px;" alt="CodingIndex Logo">
<p class="mb-3 f4 text-gray">A (human) index that likes to code<br><span class="f5">Also drinks way too much coffee <img class="emoji" title=":coffee:" alt=":coffee:" src="https://github.githubassets.com/images/icons/emoji/unicode/2615.png" height="20" width="20"></span></p>
<nav class="UnderlineNavi container-md"> 
  <div class="UnderlineNav-body" style="display: block">
    <a href="/" role="tab" title="Home" class="UnderlineNav-item selected">Home</a>
    <a href="/anime" role="tab" title="Anime" class="UnderlineNav-item ">Anime</a>
    <a href="/about" role="tab" title="About" class="UnderlineNav-item ">About</a>
  </div>
</nav>



    <div class="container-xl f4 text-left border rounded-2 bg-white p-3 p-sm-5 mt-6">
      <p class="f5"><a href="/" class="d-flex flex-items-center"><svg height="16" class="octicon octicon-chevron-left mr-2 v-align-middle" fill="#0366d6" aria-label="Home" viewbox="0 0 16 16" version="1.1" width="16" role="img"><path d="M9.78 12.78a.75.75 0 0 1-1.06 0L4.47 8.53a.75.75 0 0 1 0-1.06l4.25-4.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042L6.06 8l3.72 3.72a.75.75 0 0 1 0 1.06Z"></path></svg>Home</a></p>
      <h1 class="f00-light lh-condensed">Cheap man's Linux Multi-Monitor Setup</h1>
      <p class="text-gray mb-5">Published Apr 27, 2024 23:33</p>
      
  <div class="article">
    <p>EDIT (13/5/2024): A quick note for the various mentions of Immersed in this post. The company has
recently removed support for physical multi-monitor setups, <em>requiring</em> you to turn off all external
monitors to use Immersed. While the company reserves all rights to do whatever they want with their
software, they have begun banning and moderating away posts that criticised this change. There are
speculations that this is done to keep their records clean for the upcoming IPO. Hence, I cannot, in
good faith, endorse Immersed anymore. There is currently no good alternative for a physical +
virtual multi-monitor setup.</p>

<p>Good morning! <img class="emoji" title=":coffee:" alt=":coffee:" src="https://github.githubassets.com/images/icons/emoji/unicode/2615.png" height="20" width="20"></p>

<p>Recently, I’ve been playing around with some ideas that’ll eventually get me 24
monitors. Why the impractical and unholy number of monitors?</p>

<p>If I’m being completely realistic, that’s way too many monitors to be
practical. It’s just way too many monitors to even be useful, except
for some extenuating circumstances like stocks trading.</p>

<p>So, instead of coming up with a good excuse, I present you the best argument
I’ve had since time immemorial: why not, sounds fun!</p>

<p>There have been some interesting ideas to accomplish this surrounding the use
of Virtual Reality (VR) headsets, using apps like
<a href="https://immersed.com" target="_blank" rel="noopener noreferrer">Immersed</a> to achieve both a multi-monitor setup, and a
distraction-free environment. When COVID-19 was still a prominent part of life,
I could see this being used fairly frequently.</p>

<p>On <a href="https://immersed.com/faq" target="_blank" rel="noopener noreferrer">Immersed’s FAQ</a>, under “What devices can run immersed?”, it is stated
that “Currently, Linux only supports plugged-in external monitors” with “virtual displays coming
soon!” (accurate at the time of writing).</p>

<p>Borrowing a mate’s Quest 2, I was able to verify that Immersed wasn’t able to
spawn new displays on Linux.</p>

<p>So that got me wondering; what if I could implement this killer feature? Apart from Immersed, I
could turn old devices into high-speed, low latency external displays.</p>

<p>Apps like these already exist; notable examples include GNOME’s virtual displays and
<a href="https://deskreen.com/lang-en" target="_blank" rel="noopener noreferrer">deskreen</a>.</p>

<p>“But!” I exclaim to myself.</p>

<p>“I want a potentially unlimited number of virtual displays!” I bemoaned.</p>

<p>“And I want to do it by <em>myself</em>!” I lamented.</p>

<p>Lo and behold, of course I’d find a way.</p>

<hr>

<h1 id="discovery">Discovery</h1>

<p>Ideally, I want whatever solution I come up with to be GPU-agnostic; i.e. there shouldn’t be
something that <em>only</em> works for Intel iGPUs (as in the case with <code class="language-plaintext highlighter-rouge">VirtualHeads</code> in XOrg
configurations).</p>

<p>When searching online, I came across <a href="https://unix.stackexchange.com/a/585078" target="_blank" rel="noopener noreferrer">this wonderful person’s
post</a>, who suggested that we can use <code class="language-plaintext highlighter-rouge">DisplayLink</code>’s <code class="language-plaintext highlighter-rouge">evdi</code>
kernel module, which allows us to set an initial number of devices.</p>

<p>Running the right <code class="language-plaintext highlighter-rouge">xrandr</code> commands will then get us virtual monitors that we can’t
directly observe on physical monitors, but can instead be accessed via something like VNC or an alternate method
which I will later propose.</p>

<h1 id="base-setting-up-multiple-monitors">Base: Setting up multiple monitors</h1>

<p>The first step is to install the <code class="language-plaintext highlighter-rouge">evdi</code> kernel module. On Ubuntu, it is as simple as running <code class="language-plaintext highlighter-rouge">sudo
apt install evdi-dkms</code> and then restarting the system.</p>

<p>On other systems, either look for <code class="language-plaintext highlighter-rouge">evdi</code> in your package manager, or compile it from the
<a href="https://github.com/DisplayLink/evdi" target="_blank" rel="noopener noreferrer">source</a>.</p>

<p>Now, run <code class="language-plaintext highlighter-rouge">modprobe evdi initial_device_count=2</code> (or however many you want). 
After which, restart your X session; this can typically be done by signing out and then logging back
in, although I’ve only ever tested it by using the “restart X session” functionality on my i3
config. (i.e. killing the X session and restarting it).</p>

<blockquote>
  <p>You’d have to do this every restart. If you already have a good idea on how
many additional virtual monitors you want, you can choose to add this to
<code class="language-plaintext highlighter-rouge">/etc/modprobe.d/local-evdi.conf</code>: <code class="language-plaintext highlighter-rouge">options evdi initial_device_count=X</code>, where <code class="language-plaintext highlighter-rouge">X</code> is the number
of monitors you intend to boot with.</p>
</blockquote>

<p>Now, perform <code class="language-plaintext highlighter-rouge">xrandr --query</code>. You should see a bunch of disconnected monitors, which can look like
this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DVI-I-3-2 disconnected (normal left inverted right x axis y axis)
DVI-I-2-1 disconnected (normal left inverted right x axis y axis)
eDP-1-1 connected primary 1920x1080+0+0 (normal left invertest right x axis y axis) ...
</code></pre></div></div>

<p>At this point, add the resolution you want your virtual monitors to be. There are plenty of guides
online on how you can add custom resolutions, but if you’re adding well-known resolutions (such as
“1920x1080”, “1920x1200”), you can do so by running these commands:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>xrandr --addmode DVI-I-2-1 1920x1200
xrandr --addmode DVI-I-3-2 1920x1080
</code></pre></div></div>

<blockquote>
  <p>Note: If you have other interfaces that are free, you can use those instead. The <code class="language-plaintext highlighter-rouge">DVI-I</code> ones are
generates by <code class="language-plaintext highlighter-rouge">EVDI</code>.</p>
</blockquote>

<p>Figure out how you want to lay your monitors. In my setup, I want <code class="language-plaintext highlighter-rouge">DVI-I-2-1</code> to be on the right of
<code class="language-plaintext highlighter-rouge">eDP-1-1</code>, and <code class="language-plaintext highlighter-rouge">DVI-I-3-2</code> to be on the right of <code class="language-plaintext highlighter-rouge">DVI-I-2-1</code>. Here’s the <code class="language-plaintext highlighter-rouge">xrandr</code> magic to achieve
that:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>xrandr --output DVI-I-2-1 --mode 1920x1200 --right-of eDP-1-1
xrandr --output DVI-I-3-2 --mode 1920x1080 --right-of DVI-I-2-1
</code></pre></div></div>

<p>Congratulations! You’ve managed to set up virtual desktops. Way to go <img class="emoji" title=":beers:" alt=":beers:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f37b.png" height="20" width="20"></p>

<p>Now, how do you see content on those monitors?</p>

<hr>

<h1 id="viewing">Viewing</h1>

<p>Suppose you have two other devices to display the two new virtual monitors you’ve set up; then there
are actually a fairly abundant number of ways you can go about this. The easiest way is probably
with a VNC server and client, where there are plenty of guides for.</p>

<p>One way I tried that didn’t work was with NoMachine (notoriously known to be incredibly fast); it
wasn’t happy about the virtual monitors and drew a large black box over where they were supposed to
positioned.</p>

<p>If you have a VR workspace emulator like Immersed, the virtual monitors you’ve created should just
work straight away (tried and tested).</p>

<p>The rest of this blog post will outline a less conventional way - using
<code class="language-plaintext highlighter-rouge">ffmpeg</code> and <code class="language-plaintext highlighter-rouge">ffplay</code>. This allows me to take advantage of a host’s NVIDIA card
to display my virtual monitors on other devices.</p>

<h2 id="method">Method</h2>

<p>First, run <code class="language-plaintext highlighter-rouge">xrandr --query</code> to figure out the offsets of your outputs. For instance, here’s what
mine looks like:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; xrandr --query

DVI-I-3-2 disconnected 1920x1200+3360+1000 (normal left inverted right x axis y axis) 0mm x 0mm
DVI-I-2-1 disconnected 1920x1080+5280+1000 (normal left inverted right x axis y axis) 0mm x 0mm
</code></pre></div></div>

<p>This means that <code class="language-plaintext highlighter-rouge">DVI-I-3-2</code> has an x-offset of <code class="language-plaintext highlighter-rouge">3360</code>, and a y-offset of <code class="language-plaintext highlighter-rouge">1000</code>, while <code class="language-plaintext highlighter-rouge">DVI-I-2-1</code>
has an x-offset of <code class="language-plaintext highlighter-rouge">5280</code> and a y-offset of <code class="language-plaintext highlighter-rouge">1000</code> (I have a weird setup).</p>

<p>As you may have guessed, the devices I am planning to project the virtual monitors to are
<code class="language-plaintext highlighter-rouge">1920x1200</code> and <code class="language-plaintext highlighter-rouge">1920x1080</code> in resolutions respectively.</p>

<p>Hence, on the host, I run the following command:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ffmpeg -video_size 3840x1200 -f x11grab -framerate 60 -i :0.0+3360,1000 \
-c:v h264_nvenc -zerolatency 1 -profile:v main -preset llhq -maxrate 500k \
-bufsize 1m -qp 0 -f mpegts udp://&lt;client 1 IP&gt;:&lt;some port you choose&gt; -c:v \
h264_nvenc -zerolatency 1 -profile:v main -preset llhq -maxrate 500k -bufsize 1m \
-qp 0 -f mpegts udp://&lt;client 2 IP&gt;:&lt;some port you choose&gt;
</code></pre></div></div>

<blockquote>
  <p>Quick Disclaimer: I am not a <code class="language-plaintext highlighter-rouge">ffmpeg</code> pro. I’m fairly certain this can be optimized to smithereens,
but for the purposes of this blog post (and my usage), this is more than good enough.</p>
</blockquote>

<p>The command above screen grabs the regions defined above (essentially the two virtual monitors), and
sends the stream to both devices. The other flags are there to decrease the latency as much as
possible. Note that this setup is <em>still</em> not sub-one latency, but is much faster than achievable
with VNC (<code class="language-plaintext highlighter-rouge">ffmpeg</code> pros could probably get it to sub-one latency).</p>

<p>Ensure that the client allows ingress into both ports on their firewall, then, on the respective
clients, run the following <code class="language-plaintext highlighter-rouge">ffplay</code> commands:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Client 1 (the 1920x1200 one)
ffplay -vf "crop=1920:1200:0:0,setpts=0" -fflags nobuffer -flags low_delay \
-framedrop -strict experimental -probesize 32 -fast -an udp://127.0.0.1:&lt;port&gt;

# Client 2 (the 1920x1080 one)
ffplay -vf "crop=1920:1080:1920:0,setpts=0" -fflags nobuffer -flags low_delay \
-framedrop -strict experimental -probesize 32 -fast -an udp://127.0.0.1:&lt;port&gt;
</code></pre></div></div>

<p>The two clients should connect, after which you can press “F” to fullscreen the window.
Congratulations, both devices should now be displaying your virtual screens!
You can now interact with them as if they were external monitors to your host machine.</p>

<hr>

<h1 id="conclusions">Conclusions</h1>

<p>The solution above can be combined into a single script to suit your needs. It shows that even
without dedicated software, it is possible to have a virtual monitor setup that (basically) supports
unlimited monitors.</p>

<p>If you have any spare devices laying around, and they can run VNC clients / <code class="language-plaintext highlighter-rouge">ffplay</code>, give this a
shot! You may be able to give it a new lease of life as a secondary monitor.</p>

<p>Happy Coding,</p>

<p>CodingIndex</p>

  </div>

    </div>
  </div>

    <footer>
      <div class="container-md p-3 text-gray text-center">
        <p>Copyright © CodingIndex 2024</p>
      </div>
    </footer>
  </body>
</html>

