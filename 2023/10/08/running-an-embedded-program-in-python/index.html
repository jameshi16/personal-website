







<!doctype html>
<html class="height-full">
  <head>
    <meta charset="utf-8">
    <meta name="description" content="Good morning! :coffee:Suppose a hypothetical situation where you gained access to a Python REPL onsome server, somewhere. The REPL is artificially limited such that you have noaccess to any file or networking.Given that you are in a REPL, you can theoretically write any program you want;however, ..." />
    <title>CodingIndex's Random Shenanigans</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Blog posts (last 10, atom feed)">
    <link href="/feed/anime.xml" type="application/atom+xml" rel="alternate" title="Weaboo Corner (last 10, atom feed)">
    <link href="/assets/styles.css" rel="stylesheet" type="text/css">
    <link href="/favicon.png" rel="icon" type="image/png" sizes="128x128">
  </head>
  <body class="height-full" style="width: 100vw; overflow-x: hidden">




  <div class="container-xl pt-6 p-responsive text-center">
    

<img src="/CodingIndex.png" class="mb-3" style="max-width: 150px;" alt="CodingIndex Logo">
<p class="mb-3 f4 text-gray">A (human) index that likes to code<br><span class="f5">Also drinks way too much coffee <img class="emoji" title=":coffee:" alt=":coffee:" src="https://github.githubassets.com/images/icons/emoji/unicode/2615.png" height="20" width="20"></span></p>
<nav class="UnderlineNavi container-md"> 
  <div class="UnderlineNav-body" style="display: block">
    <a href="/" role="tab" title="Home" class="UnderlineNav-item selected">Home</a>
    <a href="/anime" role="tab" title="Anime" class="UnderlineNav-item ">Anime</a>
    <a href="/about" role="tab" title="About" class="UnderlineNav-item ">About</a>
  </div>
</nav>



    <div class="container-xl f4 text-left border rounded-2 bg-white p-3 p-sm-5 mt-6">
      <p class="f5"><a href="/" class="d-flex flex-items-center"><svg height="16" class="octicon octicon-chevron-left mr-2 v-align-middle" fill="#0366d6" aria-label="Home" viewbox="0 0 16 16" version="1.1" width="16" role="img"><path d="M9.78 12.78a.75.75 0 0 1-1.06 0L4.47 8.53a.75.75 0 0 1 0-1.06l4.25-4.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042L6.06 8l3.72 3.72a.75.75 0 0 1 0 1.06Z"></path></svg>Home</a></p>
      <h1 class="f00-light lh-condensed">Running an embedded executable in Python</h1>
      <p class="text-gray mb-5">Published Oct 08, 2023 21:51</p>
      
  <div class="article">
    <p>Good morning! <img class="emoji" title=":coffee:" alt=":coffee:" src="https://github.githubassets.com/images/icons/emoji/unicode/2615.png" height="20" width="20"></p>

<p>Suppose a hypothetical situation where you gained access to a Python REPL on
some server, somewhere. The REPL is artificially limited such that you have no
access to any file or networking.</p>

<p>Given that you are in a REPL, you can theoretically write any program you want;
however, you are lazy to write such a program, and instead wish to run an
arbitrary executable. After running some REPL commands, like:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="n">sys</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">sys</span><span class="p">.</span><span class="n">version</span>
<span class="sh">'</span><span class="s">3.10.12 (main, Jun 11 2023, 00:00:00) [GCC 11.4.0]</span><span class="sh">'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">sys</span><span class="p">.</span><span class="n">platform</span>
<span class="sh">'</span><span class="s">linux</span><span class="sh">'</span>
</code></pre></div></div>

<p>You realize the following:</p>

<ul>
  <li>The system is running &gt; Python 3.3 (more importantly, &gt; Python 3.8); and</li>
  <li>It’s running on Linux</li>
</ul>

<p>As someone who knows how to code, surely you can whip up a script that would
can execute any arbitrary binary file even under these conditions, right?</p>

<hr>

<h1 id="executing-an-arbitrary-executable">Executing an arbitrary executable</h1>

<p>On Unix and Windows, Python supports an executable, as long as a file path is
specified. This is typically done with the following recipe:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">os</span>
<span class="n">os</span><span class="p">.</span><span class="nf">execv</span><span class="p">(</span><span class="sh">"</span><span class="s">/bin/echo</span><span class="sh">"</span><span class="p">,</span> <span class="p">[</span><span class="sh">"</span><span class="s">-e</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">hello world</span><span class="sh">"</span><span class="p">])</span>
</code></pre></div></div>

<p>The code above causes the <code class="language-plaintext highlighter-rouge">/bin/echo</code> to replace the current process
immediately and prints “hello world”. After <code class="language-plaintext highlighter-rouge">/bin/echo</code> quits, so does Python.</p>

<p>Great, problem solved, right? Unfortunately, the oddly specific constraints
stated above has explicitly denied access to files, which includes the
<code class="language-plaintext highlighter-rouge">/bin/echo</code> executable.</p>

<p>Okay, so maybe we include the executable as part of the script instead. Since
we know that the REPL runs on Linux, we spin up a Docker container, and begin
experimenting.</p>

<p>First, we get the <code class="language-plaintext highlighter-rouge">/bin/echo</code> program as bytes:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">data</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="sh">'</span><span class="s">/bin/echo</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">rb</span><span class="sh">'</span><span class="p">).</span><span class="nf">read</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">data</span>
<span class="sa">b</span><span class="sh">'</span><span class="se">\x7f</span><span class="s">ELF</span><span class="se">\x02\x01\x01\x00</span><span class="s">...</span><span class="sh">'</span>
</code></pre></div></div>

<p>Backslashes looks really scary, so lets convert it to a Base64 encoded string:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="n">base64</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">data_str</span> <span class="o">=</span> <span class="n">base64</span><span class="p">.</span><span class="nf">b64encode</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">data_str</span>
<span class="sa">b</span><span class="sh">'</span><span class="s">f0VMRgIBAQAAAAAAAAAAAAMA...</span><span class="sh">'</span>
</code></pre></div></div>

<p>Great, let’s copy the whole string and keep it in our clipboard for now.</p>

<p>Next, we whip up a script, and write:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">os</span>
<span class="kn">import</span> <span class="n">base64</span>

<span class="n">bin_file</span> <span class="o">=</span> <span class="n">base64</span><span class="p">.</span><span class="nf">b64decode</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="s">f0VMRgIBAQAAAAAAAAAAAAMA...</span><span class="sh">'</span><span class="p">)</span>
<span class="n">os</span><span class="p">.</span><span class="nf">execv</span><span class="p">(</span><span class="n">bin_file</span><span class="p">,</span> <span class="p">[</span><span class="sh">'</span><span class="s">-e</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">hello world</span><span class="sh">'</span><span class="p">])</span>
</code></pre></div></div>

<p>And the run the program, and oh…</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Traceback (most recent call last):
  File "your_file_here.py", line 1, in &lt;module&gt;
ValueError: execv: embedded null character in path
</code></pre></div></div>

<h1 id="execv-and-paths">execv and paths</h1>

<p>Turns out, even with all the bytes of the executable, you can’t just run it;
Python’s <code class="language-plaintext highlighter-rouge">os.exec*</code> series of functions only support executables specified as
paths.</p>

<p><em>Well…</em></p>

<p>That statement is only half-true. As of Python version 3.3, the <code class="language-plaintext highlighter-rouge">os.execve</code>
<a href="https://docs.python.org/3/library/os.html#os.execl" target="_blank" rel="noopener noreferrer">official Python
documentation</a> supports a
<em>file descriptor</em>.</p>

<blockquote>
  <p>According to <a href="https://stackoverflow.com/a/5256705" target="_blank" rel="noopener noreferrer">this StackOverflow
answer</a>, a <em>file descriptor</em> is an entry
created by the OS when a resource (e.g. file or sockets) is opened. This
entry stores information about the resource, which includes how to access it.
On Windows, this is also known as a <em>handle</em>.</p>
</blockquote>

<p>The file descriptors on Unix can be found in <code class="language-plaintext highlighter-rouge">/proc/&lt;pid&gt;/fd</code>, where <code class="language-plaintext highlighter-rouge">&lt;pid&gt;</code> is
the process ID of the current process. Each file descriptor is represented by
an integer.</p>

<p>Okay, but why is this important? Because the standard streams, i.e. <em>standard
input</em>, <em>standard output</em> and <em>standard error</em> all have their own file
descriptors, which are 0, 1, and 2 respectively.</p>

<p>Notably, those standard streams <em>definitely</em> don’t occupy disk space; the file
descriptor to these standard streams simply represent the concept of those
streams (<a href="https://stackoverflow.com/a/3511816" target="_blank" rel="noopener noreferrer">StackOverflow</a>). Even though the
files <code class="language-plaintext highlighter-rouge">/dev/stdout</code>, <code class="language-plaintext highlighter-rouge">/dev/stdin</code>, and <code class="language-plaintext highlighter-rouge">/dev/stderr</code> exist, they actually point
to <code class="language-plaintext highlighter-rouge">/proc/self/fd/&lt;0/1/2&gt;</code>, which is basically <code class="language-plaintext highlighter-rouge">/proc/&lt;pid&gt;/fd/&lt;0/1/2&gt;</code>, the
file descriptors in question.</p>

<p>In some sense, you can say that these streams exist in-memory (they’re
technically buffered there, according to <a href="https://www.quora.com/What-does-it-mean-to-buffer-or-stdin-stdout-and-stderr" target="_blank" rel="noopener noreferrer">this Quora
post</a>).</p>

<p>Now, answer me this: what happens if I pass <code class="language-plaintext highlighter-rouge">os.execve</code> a <em>file descriptor</em>
pointing to a resource that has executable content?</p>

<p>The theoretical answer: we can execute things.</p>

<h1 id="exploring-the-theoretical-answer">Exploring the theoretical answer</h1>

<p>Let’s run an experiment on a computer we have full access to.</p>

<p>We create two files; <code class="language-plaintext highlighter-rouge">redirect.py</code>, which basically redirects the standard
input to standard output, and <code class="language-plaintext highlighter-rouge">execute.py</code>, which spawns the <code class="language-plaintext highlighter-rouge">redirect.py</code>
subprocess, then attaches pipes to the standard output of <code class="language-plaintext highlighter-rouge">redirect.py</code>.</p>

<p><code class="language-plaintext highlighter-rouge">execute.py</code> will write the Base64 string to <code class="language-plaintext highlighter-rouge">redirect.py</code>, and <code class="language-plaintext highlighter-rouge">redirect.py</code>
will respond with the raw bytes.</p>

<blockquote>
  <p>We have to do it this way, because <code class="language-plaintext highlighter-rouge">sys.stdin.read()</code> reads <em>strings</em> instead
of bytes, which causes issues when trying to pass an entire executable. With
<code class="language-plaintext highlighter-rouge">sys.stdout.buffer.write()</code>, we can write raw bytes into the standard
output. Since we hijack <code class="language-plaintext highlighter-rouge">execute.py</code> with pipes, we can also receive raw
bytes from <code class="language-plaintext highlighter-rouge">redirect.py</code>.</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">redirect.py</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">base64</span>
<span class="kn">import</span> <span class="n">sys</span>

<span class="n">r</span> <span class="o">=</span> <span class="n">base64</span><span class="p">.</span><span class="nf">b64decode</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="nf">read</span><span class="p">())</span>
<span class="n">sys</span><span class="p">.</span><span class="n">stdout</span><span class="p">.</span><span class="nb">buffer</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
<span class="n">sys</span><span class="p">.</span><span class="n">stdout</span><span class="p">.</span><span class="nf">flush</span><span class="p">()</span>
<span class="n">sys</span><span class="p">.</span><span class="n">stdout</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
</code></pre></div></div>

<p>In <code class="language-plaintext highlighter-rouge">execute.py</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">os</span>
<span class="kn">import</span> <span class="n">subprocess</span>

<span class="n">bin_file</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">f0VMRgIBAQAAAAAAAAAAAAMA...</span><span class="sh">'</span>
<span class="n">process</span> <span class="o">=</span> <span class="n">subprocess</span><span class="p">.</span><span class="nc">Popen</span><span class="p">([</span><span class="sh">'</span><span class="s">python</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">redirect.py</span><span class="sh">'</span><span class="p">],</span> <span class="n">stdin</span><span class="o">=</span><span class="n">subprocess</span><span class="p">.</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="n">subprocess</span><span class="p">.</span><span class="n">PIPE</span><span class="p">)</span>

<span class="n">process</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="n">bin_file</span><span class="p">)</span>
<span class="n">process</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>

<span class="n">os</span><span class="p">.</span><span class="nf">execve</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">stdout</span><span class="p">.</span><span class="nf">fileno</span><span class="p">(),</span> <span class="p">[</span><span class="sh">'</span><span class="s">-e</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">hello world</span><span class="sh">'</span><span class="p">],</span> <span class="p">{})</span>
</code></pre></div></div>

<p>Giving a quick whirl, we see… oh…</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Traceback (most recent call last):
  File "execute.py", line 10, in &lt;module&gt;
    os.execve(process.stdout.fileno(), ['-e', 'hello world'], {})
PermissionError: [Errno 13] Permission denied: 5
</code></pre></div></div>

<p>Looking at this
<a href="https://www.askpython.com/python/examples/handling-error-13-permission-denied" target="_blank" rel="noopener noreferrer">AskPython</a>
article, it seems like this error happens when:</p>
<ul>
  <li>File doesn’t exist;</li>
  <li>Concurrent reads by another program;</li>
  <li>Permissions error</li>
</ul>

<p>Given that we’re using one of the standard streams, surely the file descriptor
points to something that actually exists; and given standard streams are
exclusive to processes, we couldn’t have concurrent reads.</p>

<p>Hence, the only logical explanation stems from us receiving a permissions
error. <em>However</em>, that conclusion is relatively ill-conceived - how do we
assign permissions to a pipe?</p>

<p>After calling <code class="language-plaintext highlighter-rouge">os.stat</code> on both the <code class="language-plaintext highlighter-rouge">process.stdout.fileno()</code> file descriptor
and a normal executable file descriptor, we discover that there are indeed
indicators on the file mode that differentiates a stream to an actual file on
the system.</p>

<p>In fact, it is possible to use <code class="language-plaintext highlighter-rouge">os.chmod</code> to change <code class="language-plaintext highlighter-rouge">process.stdout.fileno()</code>’s
file mode, but that will <em>still</em> not yield a working result.</p>

<p>So, end of the road? Can’t be done? Not quite.</p>

<h1 id="in-memory-files">In-memory files</h1>

<p>We have just established that we <em>need</em> files; the operating system has to
understand that the file descriptor points to a resource that is <em>meant</em> to be
a file.</p>

<p>This would mean that creating a temporary file would work; however, since we
don’t have write access to the filesystem, as constrained by above, we can’t do
that. Instead, we simply create a file in memory.</p>

<p>But how?</p>

<p>If we look carefully under the Linux kernel manual, under the <code class="language-plaintext highlighter-rouge">sys/mman.h</code>
header file, we see that there is an interesting function by the name of
<code class="language-plaintext highlighter-rouge">memfd_create</code>. Here is a <a href="https://man7.org/linux/man-pages/man2/memfd_create.2.html" target="_blank" rel="noopener noreferrer">link to that
manpage</a>. The
manpage describes that:</p>

<ul>
  <li>An <em>anonymous file</em> is created; this function returns a file descriptor that points to it</li>
  <li>It <em>behaves</em> like a normal file</li>
  <li>This file lives on the RAM</li>
</ul>

<p>And wouldn’t you know it, Python’s <code class="language-plaintext highlighter-rouge">os</code> module has a <code class="language-plaintext highlighter-rouge">memfd_create</code> function!</p>

<p>Here’s the plan:</p>

<ol>
  <li>We create an in-memory file and obtain a file descriptor</li>
  <li>We write the bytes of the Base64 string into the in-memory file</li>
  <li>We seek to the start of the file</li>
  <li>We send the file descriptor over to <code class="language-plaintext highlighter-rouge">os.execve</code> and we’re off the races!</li>
</ol>

<p>Here is the final script:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># script.py
</span><span class="kn">import</span> <span class="n">base64</span>
<span class="kn">import</span> <span class="n">os</span>
<span class="kn">import</span> <span class="n">sys</span>

<span class="n">bin_file</span> <span class="o">=</span> <span class="n">base64</span><span class="p">.</span><span class="nf">b64decode</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="s">f0VMRgIBAQAAAAAAAAAAAAMA...</span><span class="sh">'</span><span class="p">)</span>

<span class="n">in_mem_fd</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="nf">memfd_create</span><span class="p">(</span><span class="sh">"</span><span class="s">bin_name</span><span class="sh">"</span><span class="p">,</span> <span class="n">os</span><span class="p">.</span><span class="n">MFD_CLOEXEC</span><span class="p">)</span>
<span class="n">os</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="n">in_mem_fd</span><span class="p">,</span> <span class="n">bin_file</span><span class="p">)</span>
<span class="n">os</span><span class="p">.</span><span class="nf">lseek</span><span class="p">(</span><span class="n">in_mem_fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">os</span><span class="p">.</span><span class="n">SEEK_SET</span><span class="p">)</span>
<span class="n">os</span><span class="p">.</span><span class="nf">execve</span><span class="p">(</span><span class="n">in_mem_fd</span><span class="p">,</span> <span class="p">[</span><span class="sh">'</span><span class="s">-e</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">hello world</span><span class="sh">'</span><span class="p">],</span> <span class="p">{})</span>
</code></pre></div></div>

<p>Finally, running the script will net us the result we were expecting:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python3 script.py
hello world
</code></pre></div></div>

<hr>

<h1 id="conclusion">Conclusion</h1>

<p>What are the implications of this? For starters, you can embed any kind of
executable into a Python script. In the case of a malware, the script can
download any random executable from the internet, and run it without leaving a
file trace on your computer.</p>

<p>With enough trickery, the script can also hijack standard input and standard
output of the embedded executable, with the UI being indistinguishable from
just running the executable directly.</p>

<p>On a lighter note, you can, in theory, package your entire suite of
applications into a single Python script. It isn’t feasible in production,
sure, but you can rest well knowing that it is indeed, <em>possible</em>.</p>

<p>Nevertheless, I hope this little fun adventure was entertaining to read. Until
next time!</p>

<p>Happy Coding,</p>

<p>CodingIndex</p>

  </div>

    </div>
  </div>

    <footer>
      <div class="container-md p-3 text-gray text-center">
        <p>Copyright © CodingIndex 2023</p>
      </div>
    </footer>
  </body>
</html>

