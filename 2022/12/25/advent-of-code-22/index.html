







<!doctype html>
<html class="height-full">
  <head>
    <meta charset="utf-8">
    <meta name="description" content="EDIT: Merry Christmas, folks! The final day, Day 25 is out!NOTE: If you’re viewing this over feed / email, you won’t be able to see the new days, because the feed is too long and I don’t want to send you unnecessary data. Head over to the website to see what’s crackin’ for today (https://codingin..." />
    <title>CodingIndex's Random Shenanigans</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Blog posts (last 10, atom feed)">
    <link href="/feed/anime.xml" type="application/atom+xml" rel="alternate" title="Weaboo Corner (last 10, atom feed)">
    <link href="/assets/styles.css" rel="stylesheet" type="text/css">
    <link href="/favicon.png" rel="icon" type="image/png" sizes="128x128">
  </head>
  <body class="height-full" style="width: 100vw; overflow-x: hidden">




  <div class="container-xl pt-6 p-responsive text-center">
    

<img src="/CodingIndex.png" class="mb-3" style="max-width: 150px;" alt="CodingIndex Logo">
<p class="mb-3 f4 text-gray">A (human) index that likes to code<br><span class="f5">Also drinks way too much coffee <img class="emoji" title=":coffee:" alt=":coffee:" src="https://github.githubassets.com/images/icons/emoji/unicode/2615.png" height="20" width="20"></span></p>
<nav class="UnderlineNavi container-md"> 
  <div class="UnderlineNav-body" style="display: block">
    <a href="/" role="tab" title="Home" class="UnderlineNav-item selected">Home</a>
    <a href="/anime" role="tab" title="Anime" class="UnderlineNav-item ">Anime</a>
    <a href="/about" role="tab" title="About" class="UnderlineNav-item ">About</a>
  </div>
</nav>



    <div class="container-xl f4 text-left border rounded-2 bg-white p-3 p-sm-5 mt-6">
      <p class="f5"><a href="/" class="d-flex flex-items-center"><svg height="16" class="octicon octicon-chevron-left mr-2 v-align-middle" fill="#0366d6" aria-label="Home" viewbox="0 0 16 16" version="1.1" width="16" role="img"><path fill-rule="evenodd" d="M9.78 12.78a.75.75 0 01-1.06 0L4.47 8.53a.75.75 0 010-1.06l4.25-4.25a.75.75 0 011.06 1.06L6.06 8l3.72 3.72a.75.75 0 010 1.06z"></path></svg>Home</a></p>
      <h1 class="f00-light lh-condensed">Advent of Code 22</h1>
      <p class="text-gray mb-5">Published Dec 25, 2022 12:05</p>
      
  <div class="article">
    <p><strong>EDIT</strong>: Merry Christmas, folks! The final day, <a href="#day-25">Day 25</a> is out!</p>

<p><strong>NOTE</strong>: If you’re viewing this over feed / email, you won’t be able to see the new days, because the feed is too long and I don’t want to send you unnecessary data. Head over to the website to see what’s crackin’ for today (<a href="https://codingindex.xyz/2022/12/25/advent-of-code-22/">https://codingindex.xyz/2022/12/25/advent-of-code-22/</a>)!</p>

<!--more-->

<p><img class="emoji" title=":coffee:" alt=":coffee:" src="https://github.githubassets.com/images/icons/emoji/unicode/2615.png" height="20" width="20"> Hi!</p>

<p>After having absolutely <em>zero</em> blog posts for the past 11 months, including my treasured <a href="/anime">anime</a> page, here I am declaring that I will be participating in the <a href="https://adventofcode.com/" target="_blank" rel="noopener noreferrer">Advent of Code</a> (AOC).</p>

<p>I’ve never completed an AOC before, so it’ll be a nice challenge to breathe vitality into this blog before the New Years. To motivate me, I have invited my buddies over at <a href="https://modelconverge.xyz" target="_blank" rel="noopener noreferrer">modelconverge</a> and <a href="https://nikhilr.io" target="_blank" rel="noopener noreferrer">nikhilr</a> to join me.</p>

<p>Each of us will attempt each AOC, and discuss our solutions at the end of each week to judge each solution with its time-space complexity, and elegance. We will use any language we have at our disposal.</p>

<p>Throughout AOC, I will update this blog post in a rolling manner to discuss my thought processes from ideation to solution. Do check back every day!</p>

<p><strong>EDIT</strong>: Handy dandy checkbox to hide old days, until a full blog post comes out!</p>

<div>
<input type="checkbox" id="olddays">
<b>Expand Old Days (Implemented based on <a href="https://www.digitalocean.com/community/tutorials/css-collapsible" target="_blank" rel="noopener noreferrer">this DigitalOcean post</a> with no JavaScript)</b>

<style>
#olddays:checked ~ .olddays-collapsable {
  max-height: 100%;
}
#olddays-collapsable {
  max-height: 0px;
  overflow: hidden;
}
</style>
<div class="olddays-collapsable" id="olddays-collapsable">

    <h1 id="day-1">Day 1</h1>

    <p>Thanks to deadlines being a thing, I ended up doing Day 1 24 hours late. Anyways, it seems like we need to make a simple program to figure out who is carrying the most amount of calories among the elves.</p>

    <h2 id="part-1">Part 1</h2>

    <p>I broke down the problem into processing chunks of numbers at once:</p>

    <ol>
      <li>Each block is delimited by <code class="language-plaintext highlighter-rouge">\n\n</code> (two newlines), and</li>
      <li>Each calorie-qualifying item is delimited by <code class="language-plaintext highlighter-rouge">\n</code>.</li>
    </ol>

    <p>So, the steps to solve this problem will be:</p>

    <ol>
      <li>Define a list, <code class="language-plaintext highlighter-rouge">l</code>;</li>
      <li>Read input line by line;</li>
      <li>For each line, check if the string is just space;</li>
      <li>If it is just space, we add an integer, <code class="language-plaintext highlighter-rouge">0</code> into the list, <code class="language-plaintext highlighter-rouge">l</code>;</li>
      <li>Otherwise, we parse the input as an integer and add it to the last integer in <code class="language-plaintext highlighter-rouge">l</code>;</li>
      <li>Repeat step 2 until EOF;</li>
      <li>We take the maximum of the list <code class="language-plaintext highlighter-rouge">l</code>, completing our algorithm.</li>
    </ol>

    <p>Framing the problem another way, <code class="language-plaintext highlighter-rouge">l</code> is the accumulator of integers, and we are processing a list of strings with a function that:</p>

    <ol>
      <li>Adds a new number to the accumulator if string is empty;</li>
      <li>Otherwise, adds the integer representation of the string into the last element of the accumulator.</li>
    </ol>

    <p>Then, we take the maximum of the list. Naturally, this means that the problem can be solved with two lines of Python:</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="nb">reduce</span>

<span class="k">print</span><span class="p">(</span><span class="nb">max</span><span class="p">((</span><span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">accum</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">accum</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">y</span> <span class="o">==</span> <span class="s">""</span> <span class="k">else</span> <span class="n">accum</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">accum</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">y</span><span class="p">)],</span> <span class="nb">open</span><span class="p">(</span><span class="s">"input.txt"</span><span class="p">).</span><span class="n">read</span><span class="p">().</span><span class="n">splitlines</span><span class="p">(),</span> <span class="p">[</span><span class="mi">0</span><span class="p">]))))</span>
</code></pre></div>    </div>

    <p>Where the contents of <code class="language-plaintext highlighter-rouge">input.txt</code> are given by the puzzle input.</p>

    <h2 id="part-2">Part 2</h2>

    <p>The second part essentially want us to get the three highest elements in the list. So, just a small tweak to part 1:</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="nb">reduce</span>

<span class="k">print</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">accum</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">accum</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">y</span> <span class="o">==</span> <span class="s">""</span> <span class="k">else</span> <span class="n">accum</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">accum</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">y</span><span class="p">)],</span> <span class="nb">open</span><span class="p">(</span><span class="s">"input.txt"</span><span class="p">).</span><span class="n">read</span><span class="p">().</span><span class="n">splitlines</span><span class="p">(),</span> <span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)[:</span><span class="mi">3</span><span class="p">]))</span>
</code></pre></div>    </div>

    <p>All I did here was to replace <code class="language-plaintext highlighter-rouge">max</code> with a composition of <code class="language-plaintext highlighter-rouge">sum</code> and <code class="language-plaintext highlighter-rouge">sorted</code>.</p>

    <hr>

    <h1 id="day-2">Day 2</h1>

    <h2 id="part-1-1">Part 1</h2>

    <p>Parsing the problem into programmer monkey brain language, the question is essentially:</p>

    <ul>
      <li>Given an input:
        <ul>
          <li>Each line is a combination of two characters from different source ranges delimited by space, i.e.: <code class="language-plaintext highlighter-rouge">A X</code> where <code class="language-plaintext highlighter-rouge">A = ['A','B','C']</code> and <code class="language-plaintext highlighter-rouge">X = ['X','Y','Z']</code>.</li>
          <li>Lines delimited by <code class="language-plaintext highlighter-rouge">\n</code>.</li>
        </ul>
      </li>
      <li>
<code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">X</code> are enumeration representations of the possible moves in rock, paper and scissors. The truth table is as follows:</li>
    </ul>

    <table>
      <thead>
        <tr>
          <th><strong>Left</strong></th>
          <th><strong>Right</strong></th>
          <th><strong>State</strong></th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>A</td>
          <td>X</td>
          <td>Tie</td>
        </tr>
        <tr>
          <td>B</td>
          <td>Y</td>
          <td>Tie</td>
        </tr>
        <tr>
          <td>C</td>
          <td>Z</td>
          <td>Tie</td>
        </tr>
        <tr>
          <td>A</td>
          <td>Y</td>
          <td>Win</td>
        </tr>
        <tr>
          <td>B</td>
          <td>Z</td>
          <td>Win</td>
        </tr>
        <tr>
          <td>C</td>
          <td>X</td>
          <td>Win</td>
        </tr>
        <tr>
          <td>A</td>
          <td>Z</td>
          <td>Lose</td>
        </tr>
        <tr>
          <td>B</td>
          <td>X</td>
          <td>Lose</td>
        </tr>
        <tr>
          <td>C</td>
          <td>Y</td>
          <td>Lose</td>
        </tr>
      </tbody>
    </table>

    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">X</code>, <code class="language-plaintext highlighter-rouge">Y</code>, <code class="language-plaintext highlighter-rouge">Z</code> have a partial score of 1, 2, 3 respectively</li>
      <li>Winning will grant a partial score of 6, Ties will grant 3, and losing will grant 0.</li>
    </ul>

    <p>The first thing I did was to “normalize” and simplify the truth table by taking the difference between <code class="language-plaintext highlighter-rouge">X</code> and <code class="language-plaintext highlighter-rouge">A</code>. So, before simplification, the table looked like this:</p>

    <table>
      <thead>
        <tr>
          <th><strong>Left</strong></th>
          <th><strong>Right</strong></th>
          <th><strong>Diff</strong></th>
          <th><strong>State</strong></th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>1</td>
          <td>1</td>
          <td>0</td>
          <td>Tie</td>
        </tr>
        <tr>
          <td>2</td>
          <td>2</td>
          <td>0</td>
          <td>Tie</td>
        </tr>
        <tr>
          <td>3</td>
          <td>3</td>
          <td>0</td>
          <td>Tie</td>
        </tr>
        <tr>
          <td>1</td>
          <td>2</td>
          <td>1</td>
          <td>Win</td>
        </tr>
        <tr>
          <td>2</td>
          <td>3</td>
          <td>1</td>
          <td>Win</td>
        </tr>
        <tr>
          <td>3</td>
          <td>1</td>
          <td>-2</td>
          <td>Win</td>
        </tr>
        <tr>
          <td>1</td>
          <td>3</td>
          <td>2</td>
          <td>Lose</td>
        </tr>
        <tr>
          <td>2</td>
          <td>1</td>
          <td>-1</td>
          <td>Lose</td>
        </tr>
        <tr>
          <td>3</td>
          <td>2</td>
          <td>-1</td>
          <td>Lose</td>
        </tr>
      </tbody>
    </table>

    <p>I then simplify the table with the following thoughts:</p>
    <ul>
      <li>Consider only the difference and states;</li>
      <li>Losing will grant zero points, which makes it inconsequential in our score calculation, so it can be completely removed.</li>
    </ul>

    <p>So, the table looks like this:</p>

    <table>
      <thead>
        <tr>
          <th><strong>Diff</strong></th>
          <th><strong>State</strong></th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>0</td>
          <td>Tie</td>
        </tr>
        <tr>
          <td>1</td>
          <td>Win</td>
        </tr>
        <tr>
          <td>-2</td>
          <td>Win</td>
        </tr>
      </tbody>
    </table>

    <p>Now, the problem of obtaining the win/tie/loss partial score has been simplified to check for these 3 cases. So, I could now write something like:</p>

    <div class="language-c highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c1">// a is normalized left, x is normalized right</span>
<span class="kt">int</span> <span class="n">partial_score</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">x</span> <span class="o">-</span> <span class="n">a</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">6</span><span class="p">;</span>
</code></pre></div>    </div>

    <p>The next sub-problem to tackle will be to normalize our inputs. All ASCII characters can be expressed as integers, and hence can be normalized by the lowest value of each range. In other words:</p>

    <div class="language-c highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c1">// a is left, x is right</span>
<span class="kt">int</span> <span class="n">normalised_a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="sc">'A'</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">normalised_x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="sc">'X'</span><span class="p">;</span>
</code></pre></div>    </div>

    <p>Performing this normalization almost conforms to the partial sum where <code class="language-plaintext highlighter-rouge">'X', 'Y', 'Z' -&gt; 1, 2, 3</code>. Right now, the map looks like <code class="language-plaintext highlighter-rouge">'X', 'Y', 'Z' -&gt; 0, 1, 2</code>. To fix this, just add 1:</p>

    <div class="language-c highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c1">// normalised_x as above</span>
<span class="kt">int</span> <span class="n">partial_score</span> <span class="o">=</span> <span class="n">normalised_x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div>    </div>

    <p>So, the total score can now be expressed as:</p>

    <div class="language-c highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c1">// a is normalised left, x is normalised right</span>
<span class="kt">int</span> <span class="n">score</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">x</span> <span class="o">-</span> <span class="n">a</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">6</span><span class="p">;</span>
</code></pre></div>    </div>

    <p>All we need to do now is to do the preprocessing and required code to actually obtain <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">a</code>. I first wrote it in C, which looks like this:</p>

    <div class="language-c highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">eval_score</span><span class="p">(</span><span class="kt">char</span> <span class="n">a</span><span class="p">,</span> <span class="kt">char</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">opp_a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="sc">'A'</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">opp_b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="sc">'X'</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">opp_b</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">opp_b</span> <span class="o">-</span> <span class="n">opp_a</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">opp_b</span> <span class="o">-</span> <span class="n">opp_a</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">6</span> <span class="o">+</span> <span class="p">(</span><span class="n">opp_a</span> <span class="o">==</span> <span class="n">opp_b</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">FILE</span><span class="o">*</span> <span class="n">file</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"input.txt"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span>
  <span class="kt">long</span> <span class="n">accum_score</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">do</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">;</span>
    <span class="n">fscanf</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s">"%c %c</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">second</span><span class="p">);</span>
    <span class="n">accum_score</span> <span class="o">+=</span> <span class="n">eval_score</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">feof</span><span class="p">(</span><span class="n">file</span><span class="p">));</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"%ld</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">accum_score</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <p>This was too long, so I decided to re-write the same thing in JavaScript:</p>

    <div class="language-js highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="nx">inputStr</span> <span class="o">=</span> <span class="s2">``</span> <span class="c1">// puzzle input</span>

<span class="nx">inputStr</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">'</span><span class="se">\n</span><span class="dl">'</span><span class="p">).</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">acc</span><span class="p">,</span> <span class="nx">curr</span><span class="p">)</span> <span class="o">=&gt;</span>
        <span class="nx">acc</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span>
                <span class="p">((</span><span class="nx">codes</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">codes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span>
                        <span class="p">(</span><span class="nx">codes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="nx">codes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="nx">codes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="nx">codes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">6</span> <span class="o">+</span>
                        <span class="p">(</span><span class="nx">codes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="nx">codes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
                <span class="p">(((</span><span class="nx">raw</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">raw</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">charCodeAt</span><span class="p">()</span> <span class="o">-</span> <span class="mi">65</span><span class="p">,</span> <span class="nx">raw</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">charCodeAt</span><span class="p">()</span> <span class="o">-</span> <span class="mi">88</span><span class="p">])(</span><span class="nx">curr</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">'</span><span class="s1"> </span><span class="dl">'</span><span class="p">)))),</span> <span class="p">[])</span>
        <span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">acc</span><span class="p">,</span> <span class="nx">curr</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">acc</span> <span class="o">+</span> <span class="nx">curr</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div>    </div>

    <p>Which is shorter but kinda unreadable.</p>

    <h2 id="part-2-1">Part 2</h2>

    <p>Part 2 changes the interpretation of <code class="language-plaintext highlighter-rouge">X</code>. <code class="language-plaintext highlighter-rouge">"X"</code>, <code class="language-plaintext highlighter-rouge">"Y"</code>, and <code class="language-plaintext highlighter-rouge">"Z"</code> now represents <code class="language-plaintext highlighter-rouge">lose</code>, <code class="language-plaintext highlighter-rouge">tie</code>, and <code class="language-plaintext highlighter-rouge">win</code>. Upon closer inspection, this really only affects the partial sum used to calculate the score based on state; if anything, it made calculating the win/loss/tie partial score simple.</p>

    <p>It can be easily realised that associating tie to <code class="language-plaintext highlighter-rouge">0</code>, win to <code class="language-plaintext highlighter-rouge">1</code> and loss to <code class="language-plaintext highlighter-rouge">-1</code> will make deriving the rock/paper/scissors move simple.</p>

    <table>
      <thead>
        <tr>
          <th><strong>Left</strong></th>
          <th><strong>State</strong></th>
          <th><strong>Right</strong></th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>x</td>
          <td>Tie (0)</td>
          <td>x</td>
        </tr>
        <tr>
          <td>x</td>
          <td>Win (1)</td>
          <td>0 if x + 1 == 3 else x + 1</td>
        </tr>
        <tr>
          <td>x</td>
          <td>Lose (-1)</td>
          <td>2 if x - 1 == -1 else x - 1</td>
        </tr>
      </tbody>
    </table>

    <p>Remember that the normalised <code class="language-plaintext highlighter-rouge">"A", "B", "C" -&gt; 0, 1, 2</code>, so ties would imply <code class="language-plaintext highlighter-rouge">"A", "B", "C" -&gt; Scissors, Paper, Rock</code>, wins would imply <code class="language-plaintext highlighter-rouge">"A", "B", "C" -&gt; Paper, Rock, Scissors</code>, and losses will be <code class="language-plaintext highlighter-rouge">"A", "B", "C" -&gt; Scissors, Rock, Paper</code>.</p>

    <p>Hence, the code would be changed to:</p>

    <div class="language-js highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="nx">inputStr</span> <span class="o">=</span> <span class="s2">``</span>

<span class="nx">inputStr</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">'</span><span class="se">\n</span><span class="dl">'</span><span class="p">).</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">acc</span><span class="p">,</span> <span class="nx">curr</span><span class="p">)</span> <span class="o">=&gt;</span>
        <span class="nx">acc</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span>
                <span class="p">((</span><span class="nx">codes</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">((</span><span class="nx">codes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nx">codes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">?</span> <span class="mi">2</span> <span class="p">:</span> <span class="p">(</span><span class="nx">codes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nx">codes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">%</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span>
                        <span class="p">(</span><span class="nx">codes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">6</span> <span class="o">+</span>
                        <span class="p">(</span><span class="nx">codes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
                <span class="p">(((</span><span class="nx">raw</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">raw</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">charCodeAt</span><span class="p">()</span> <span class="o">-</span> <span class="mi">65</span><span class="p">,</span> <span class="nx">raw</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">charCodeAt</span><span class="p">()</span> <span class="o">-</span> <span class="mi">89</span><span class="p">])(</span><span class="nx">curr</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">'</span><span class="s1"> </span><span class="dl">'</span><span class="p">)))),</span> <span class="p">[])</span>
        <span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">acc</span><span class="p">,</span> <span class="nx">curr</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">acc</span> <span class="o">+</span> <span class="nx">curr</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div>    </div>

    <p>Notice the change at <code class="language-plaintext highlighter-rouge">raw[1].charCodeAt() - 89</code>, which essentially absorbed an offset of <code class="language-plaintext highlighter-rouge">-1</code>.</p>

    <hr>

    <h1 id="day-3">Day 3</h1>

    <h2 id="part-1-2">Part 1</h2>

    <p>Today’s part 1 problem can be broken down into the following sub-problems:</p>

    <ul>
      <li>Go through the input line by line;</li>
      <li>For each line, split the line by half, and find the intersect between the two lines;</li>
      <li>Due to the nature of the problem, it is guaranteed that the intersection is one and unique;</li>
      <li>For each of the intersections, calculate the respective priorities.</li>
    </ul>

    <p>I decided to use Haskell, because <img class="emoji" title=":shrug:" alt=":shrug:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f937.png" height="20" width="20">. Inputs in Haskell is notoriously complex, so I decided to bypass that by utilizing my browser’s JavaScript engine to convert multi-line strings to normal strings delimited by <code class="language-plaintext highlighter-rouge">\n</code>, like this:</p>

    <p><img src="/images/20221225_1.png" style="max-width: 800px; width: 100%; margin: 0 auto; display: block;" alt="Interpreting multi-string with JavaScript"></p>
    <p class="text-center text-gray lh-condensed-ultra f6">Converting to a single-line string with JavaScript</p>

    <p>Doing so, I will be able to bypass all input-related processing in Haskell by assigning the string to the variable.</p>

    <p>Let’s solve each sub-problem in Haskell:</p>

    <div class="language-haskell highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c1">-- input string</span>
<span class="n">input</span> <span class="o">=</span> <span class="s">""</span>

<span class="c1">-- going through line by line</span>
<span class="n">lines</span> <span class="n">input</span>

<span class="c1">-- split line by half</span>
<span class="n">splitAt</span> <span class="p">(</span><span class="n">round</span> <span class="o">$</span> <span class="p">(</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">$</span> <span class="n">fromIntegral</span> <span class="o">$</span> <span class="n">length</span> <span class="n">line</span><span class="p">)</span> <span class="n">line</span>

<span class="c1">-- find intersection between the two halfs</span>
<span class="n">intersect</span> <span class="n">splitted_xs</span> <span class="n">splitted_ys</span>

<span class="c1">-- calculate priority</span>
<span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="kr">if</span> <span class="n">x</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="sc">'a'</span><span class="o">..</span><span class="sc">'z'</span><span class="p">]</span> <span class="kr">then</span> <span class="n">ord</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">96</span> <span class="kr">else</span> <span class="n">ord</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">65</span> <span class="o">+</span> <span class="mi">27</span><span class="p">)</span> <span class="o">$</span> <span class="p">(</span><span class="o">!!</span> <span class="mi">0</span><span class="p">)</span> <span class="n">intersected_list</span>
</code></pre></div>    </div>

    <p>Some notes:</p>
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">length line</code> strictly returns an integer, which needs to be converted for division in Haskell;</li>
      <li>In the priority calculation, we subtract 96, which is 1 less than the ASCII value for ‘a’, so we introduce an offset of <code class="language-plaintext highlighter-rouge">+1</code>;</li>
      <li>The range <code class="language-plaintext highlighter-rouge">['A'..'Z']</code> has an offset of 26 + 1 after getting it’s sequence number from the ASCII value for ‘A’.</li>
    </ul>

    <p>Combining these together, we have:</p>

    <div class="language-haskell highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kr">import</span> <span class="nn">Data.Char</span>
<span class="kr">import</span> <span class="nn">Data.List</span>

<span class="n">input</span> <span class="o">=</span> <span class="s">""</span>
<span class="n">solution</span> <span class="n">input</span> <span class="o">=</span> <span class="n">sum</span> <span class="p">[(</span><span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="kr">if</span> <span class="n">x</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="sc">'a'</span><span class="o">..</span><span class="sc">'z'</span><span class="p">]</span> <span class="kr">then</span> <span class="n">ord</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">96</span> <span class="kr">else</span> <span class="n">ord</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">65</span> <span class="o">+</span> <span class="mi">27</span><span class="p">)</span> <span class="o">$</span> <span class="p">(</span><span class="o">!!</span> <span class="mi">0</span><span class="p">)</span> <span class="o">$</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">intersect</span> <span class="n">xs</span> <span class="n">ys</span><span class="p">)</span> <span class="o">$</span> <span class="n">splitAt</span> <span class="p">(</span><span class="n">round</span> <span class="o">$</span> <span class="p">(</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">$</span> <span class="n">fromIntegral</span> <span class="o">$</span> <span class="n">length</span> <span class="n">line</span><span class="p">)</span> <span class="n">line</span> <span class="o">|</span> <span class="n">line</span> <span class="o">&lt;-</span> <span class="n">lines</span> <span class="n">input</span><span class="p">]</span>
</code></pre></div>    </div>

    <h2 id="part-2-2">Part 2</h2>

    <p>The slight twist introduced here require us to do the following:</p>

    <ul>
      <li>Group the lines by 3;</li>
      <li>Instead of getting the intersect between the two halves of a string, get the intersect between all elements in the groups of 3.</li>
    </ul>

    <p>It is guaranteed by the nature of the problem that our input’s number of lines will be divisible by 3.</p>

    <p>There are many ways to group the lines by 3, and the way I chose is to maintain an accumulated list of lists, where each element list will contain 3 elements.</p>

    <p>With that, we solve the sub-problems:</p>

    <div class="language-haskell highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c1">-- grouping the lines by 3</span>
<span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">acc</span><span class="o">@</span><span class="p">(</span><span class="n">y</span><span class="o">:</span><span class="n">ys</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kr">if</span> <span class="n">length</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">3</span> <span class="kr">then</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">:</span><span class="n">acc</span> <span class="kr">else</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">y</span><span class="p">)</span><span class="o">:</span><span class="n">ys</span><span class="p">)</span> <span class="p">[</span><span class="kt">[]</span><span class="p">]</span> <span class="o">$</span> <span class="n">lines</span> <span class="n">input</span>

<span class="c1">-- intersecting 3 lines</span>
<span class="n">map</span> <span class="p">(</span><span class="n">foldr1</span> <span class="n">intersect</span><span class="p">)</span> <span class="n">output_of_above</span>
</code></pre></div>    </div>

    <p>Then, reassembling the final solution:</p>
    <div class="language-haskell highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kr">import</span> <span class="nn">Data.Char</span>
<span class="kr">import</span> <span class="nn">Data.List</span>

<span class="n">solution'</span> <span class="n">input</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">$</span> <span class="n">map</span> <span class="p">((</span><span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="kr">if</span> <span class="n">x</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="sc">'a'</span><span class="o">..</span><span class="sc">'z'</span><span class="p">]</span> <span class="kr">then</span> <span class="n">ord</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">96</span> <span class="kr">else</span> <span class="n">ord</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">65</span> <span class="o">+</span> <span class="mi">27</span><span class="p">)</span> <span class="o">.</span> <span class="p">(</span><span class="o">!!</span> <span class="mi">0</span><span class="p">))</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="n">foldr1</span> <span class="n">intersect</span><span class="p">)</span> <span class="o">$</span> <span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">acc</span><span class="o">@</span><span class="p">(</span><span class="n">y</span><span class="o">:</span><span class="n">ys</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kr">if</span> <span class="n">length</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">3</span> <span class="kr">then</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">:</span><span class="n">acc</span> <span class="kr">else</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">y</span><span class="p">)</span><span class="o">:</span><span class="n">ys</span><span class="p">)</span> <span class="p">[</span><span class="kt">[]</span><span class="p">]</span> <span class="o">$</span> <span class="n">lines</span> <span class="n">input</span>
</code></pre></div>    </div>

    <hr>

    <h1 id="day-4">Day 4</h1>

    <h2 id="part-1-3">Part 1</h2>

    <p>Feeling a little lazy today, I decided to work in Python. Today’s problem is broken down into the following, familiar sub-problems:</p>

    <ol>
      <li>Read input line by line;</li>
      <li>Split the line by <code class="language-plaintext highlighter-rouge">,</code>, which we will call segments;</li>
      <li>Split the segments by <code class="language-plaintext highlighter-rouge">-</code>, which we will call fragments;</li>
      <li>Convert resulting fragments to integers;</li>
      <li>Figure out if one of the two segments are fully contained in one or another;</li>
      <li>Count the number of fully contained lines.</li>
    </ol>

    <p>Let’s talk about step 5. In set theory, if we wanted to know if <code class="language-plaintext highlighter-rouge">A</code> is fully contained in <code class="language-plaintext highlighter-rouge">B</code>, then <code class="language-plaintext highlighter-rouge">A⊂B</code>; however, this can be simplified if <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code> are sorted lists, which is the case for ranges defined solely by their boundaries. So, if I had an input line of <code class="language-plaintext highlighter-rouge">6-6,4-6</code> we can verify quite quickly that the left range is fully contained in the right range, not because we imagined if all elements of the left range is in the right range, but because of the lower bounds: <code class="language-plaintext highlighter-rouge">6 &gt; 4</code>, and the upper bounds: <code class="language-plaintext highlighter-rouge">6 == 6</code>, so therefore <code class="language-plaintext highlighter-rouge">6-6</code> is in <code class="language-plaintext highlighter-rouge">4-6</code>.</p>

    <p>Similarly, for <code class="language-plaintext highlighter-rouge">2-8,3-7</code>, we see that <code class="language-plaintext highlighter-rouge">3 &gt; 2</code> and <code class="language-plaintext highlighter-rouge">7 &lt; 8</code>, so this means <code class="language-plaintext highlighter-rouge">3-7</code> must be in <code class="language-plaintext highlighter-rouge">2-8</code>.</p>

    <p>With that context, the sub-problems can be solve like so in Python:</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c1"># read input line by line e.g. "2-8,3-7"
</span><span class="nb">open</span><span class="p">(</span><span class="s">"input.txt"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">).</span><span class="n">readlines</span><span class="p">()</span>

<span class="c1"># split line by ',', so we get ["2-8", "3-7"]
</span><span class="n">segments</span> <span class="o">=</span> <span class="n">line</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">','</span><span class="p">)</span>

<span class="c1"># split a single segment by '-' so we get fragment = ["2", "8"]
</span><span class="n">fragment</span> <span class="o">=</span> <span class="n">segment</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">'-'</span><span class="p">)</span>
<span class="c1"># note that all fragments = [["2", "8"], ["3", "7"]]
</span>
<span class="c1"># convert to int [2, 8]
</span><span class="n">fragment_prime</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">fragment</span><span class="p">)</span>

<span class="c1"># compare the ranges
</span><span class="n">possibility_1</span> <span class="o">=</span> <span class="n">fragment_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">fragment_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">fragment_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">fragment_2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">possibility_2</span> <span class="o">=</span> <span class="n">fragment_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">fragment_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">fragment_2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">fragment_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">possibility_1</span> <span class="ow">or</span> <span class="n">possibility_2</span>
</code></pre></div>    </div>

    <p>The way I used to combine all of the sub-problems together is to use an unholy concoction of maps:</p>
    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">xys</span><span class="p">:</span> <span class="p">(</span><span class="n">xys</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">xys</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">xys</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">xys</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="n">xys</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">xys</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">xys</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">xys</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">segments</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">segment</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">segment</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">'-'</span><span class="p">))),</span> <span class="n">segments</span><span class="p">)),</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">line</span><span class="p">:</span> <span class="n">line</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">','</span><span class="p">),</span> <span class="nb">open</span><span class="p">(</span><span class="s">"input.txt"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">).</span><span class="n">readlines</span><span class="p">()))))))))</span>
</code></pre></div>    </div>

    <h2 id="part-2-3">Part 2</h2>

    <p>Part 2 changes the so-called “set operation” we are performing. Instead of “fully contains”, we are looking for overlaps, or in set terms we are looking for, “A∩B≠Ø”.</p>

    <p>Let’s consider the few possible cases, if we have a string in the format <code class="language-plaintext highlighter-rouge">a-b,x-y</code>:</p>

    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>case 1
......a###########b...
.x#y..................

case 2
..a######b...
.x###y....

case 3
..a###b....
....x###y..

case 4
.a####b.......
.........x##y.

case 5
....a####b....
......x#y.....
</code></pre></div>    </div>

    <p>The cases imply the following:</p>

    <ol>
      <li>No intersect: <code class="language-plaintext highlighter-rouge">a &gt; x</code>, <code class="language-plaintext highlighter-rouge">b &gt; x</code>, <code class="language-plaintext highlighter-rouge">x &lt; a</code>, <code class="language-plaintext highlighter-rouge">y &lt; a</code>;</li>
      <li>Intersect: <code class="language-plaintext highlighter-rouge">a &gt; x</code>, <code class="language-plaintext highlighter-rouge">b &gt; x</code>, <strong><code class="language-plaintext highlighter-rouge">x &lt; a</code>, <code class="language-plaintext highlighter-rouge">y &gt; a</code></strong>;</li>
      <li>Intersect: <strong><code class="language-plaintext highlighter-rouge">a &lt; x</code>, <code class="language-plaintext highlighter-rouge">b &gt; x</code></strong>, <code class="language-plaintext highlighter-rouge">x &gt; a</code>, <code class="language-plaintext highlighter-rouge">y &gt; a</code>;</li>
      <li>No intersect: <code class="language-plaintext highlighter-rouge">a &lt; x</code>, <code class="language-plaintext highlighter-rouge">b &lt; x</code>, <code class="language-plaintext highlighter-rouge">x &gt; a</code>, <code class="language-plaintext highlighter-rouge">y &gt; a</code>;</li>
      <li>Intersect: <strong><code class="language-plaintext highlighter-rouge">a &lt; x</code>, <code class="language-plaintext highlighter-rouge">b &gt; x</code></strong>, <code class="language-plaintext highlighter-rouge">x &gt; a</code>, <code class="language-plaintext highlighter-rouge">y &gt; a</code>.</li>
    </ol>

    <p>The relations in bold matter the most; we see that for any two ranges to intersect, the lower bound of the first range must be less than the lower bound of the second range, and the upper bound of the first range must be greater than the lower bound of the second range, <em>or</em> vice-versa.</p>

    <p>Writing that in code, the testing statement becomes:</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="n">possibility_1</span> <span class="o">=</span> <span class="n">fragment_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">fragment_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">fragment_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">fragment_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">possibility_2</span> <span class="o">=</span> <span class="n">fragment_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">fragment_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">fragment_2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">fragment_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">possibility_1</span> <span class="ow">or</span> <span class="n">possibility_2</span>
</code></pre></div>    </div>

    <p>So, our resulting code looks very similar to part 1, with a minor change of index in our comparison lambda:</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">xys</span><span class="p">:</span> <span class="p">(</span><span class="n">xys</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">xys</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">xys</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">xys</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="n">xys</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">xys</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">xys</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">xys</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">segments</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">segment</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">segment</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">'-'</span><span class="p">))),</span> <span class="n">segments</span><span class="p">)),</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">line</span><span class="p">:</span> <span class="n">line</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">','</span><span class="p">),</span> <span class="nb">open</span><span class="p">(</span><span class="s">"input.txt"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">).</span><span class="n">readlines</span><span class="p">()))))))))</span>
</code></pre></div>    </div>

    <hr>

    <h1 id="day-5">Day 5</h1>

    <p>Deadlines are looming, so I’ve haven’t got the time to compact this. However, a streak is a streak!</p>

    <h2 id="part-1-4">Part 1</h2>

    <p>Immediately after reading the question, I immediately thought of stacks. The sub-problems are as follows:</p>

    <ol>
      <li>Split the input into two, the visual representation and the instructions;</li>
      <li>Break down the visual representation into stacks;</li>
      <li>Break down the instructions into something we can use;</li>
      <li>Use the instructions to identify:
        <ul>
          <li>
<code class="language-plaintext highlighter-rouge">from</code> queue;</li>
          <li>
<code class="language-plaintext highlighter-rouge">to</code> queue;</li>
          <li>how many items to move.</li>
        </ul>
      </li>
    </ol>

    <p>Not being in the headspace to do function composition, I left the code separated in their respective chunks:</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">functools</span>                                                                              
                                                                                              
<span class="n">data</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">'input.txt'</span><span class="p">,</span> <span class="s">'r'</span><span class="p">).</span><span class="n">readlines</span><span class="p">()</span>                                                     
                                                                                              
<span class="c1"># \n here is the divider                                                                      
</span><span class="n">segments</span> <span class="o">=</span> <span class="n">functools</span><span class="p">.</span><span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">accum</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">accum</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">accum</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="s">'</span><span class="se">\n</span><span class="s">'</span> <span class="k">else</span> <span class="n">accum</span> <span class="o">+</span> <span class="p">[[]],</span> <span class="n">data</span><span class="p">,</span> <span class="p">[[]])</span>

<span class="c1"># all characters are +4 away from one another, first one at pos 1. reparse accordingly        
</span><span class="n">segments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">4</span><span class="p">)],</span> <span class="n">segments</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

<span class="c1"># flatten segments[0] into a queue-like structure                                             
</span><span class="n">stacks</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">segments</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]))]</span>                                             
<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>                                                               
    <span class="k">if</span> <span class="n">col</span> <span class="o">!=</span> <span class="s">' '</span><span class="p">:</span>
      <span class="n">stacks</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>                                                                   
<span class="n">stacks</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">stack</span><span class="p">))</span> <span class="k">for</span> <span class="n">stack</span> <span class="ow">in</span> <span class="n">stacks</span><span class="p">]</span>                                          

<span class="c1"># flatten segments[1] into a list of tuple instructions                                       
</span><span class="n">digit_fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">s</span><span class="p">.</span><span class="n">split</span><span class="p">()</span> <span class="k">if</span> <span class="n">x</span><span class="p">.</span><span class="n">isdigit</span><span class="p">()]</span>                               
<span class="n">instructions</span> <span class="o">=</span> <span class="p">[</span><span class="n">digit_fn</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

<span class="c1"># do the movements                                                                            
</span><span class="k">for</span> <span class="n">instruction</span> <span class="ow">in</span> <span class="n">instructions</span><span class="p">:</span>                                                              
  <span class="n">stack_from</span> <span class="o">=</span> <span class="n">instruction</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>                                                             
  <span class="n">stack_to</span> <span class="o">=</span> <span class="n">instruction</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> 
  <span class="n">number</span> <span class="o">=</span> <span class="n">instruction</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  
  <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number</span><span class="p">):</span>                                                                     
    <span class="n">stacks</span><span class="p">[</span><span class="n">stack_to</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">stacks</span><span class="p">[</span><span class="n">stack_from</span><span class="p">].</span><span class="n">pop</span><span class="p">())</span> 
  
<span class="c1"># get the top of all                                                                          
</span><span class="k">print</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">([</span><span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stacks</span><span class="p">]))</span>
</code></pre></div>    </div>

    <h2 id="part-2-4">Part 2</h2>

    <p>Part 2 essentially changes the data structure we are working with. Now, we’re breaking off lists at any arbitrary point, and appending it to another list (is there a name for this type of data structure)?</p>

    <p>However, since this is a small change, I decided to change two lines and reuse the rest of the code, meaning that the main data structure in use is misnamed. Regardless, here it is:</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">functools</span>                                                                              
                                                                                              
<span class="n">data</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">'input.txt'</span><span class="p">,</span> <span class="s">'r'</span><span class="p">).</span><span class="n">readlines</span><span class="p">()</span>                                                     
                                                                                              
<span class="c1"># \n here is the divider                                                                      
</span><span class="n">segments</span> <span class="o">=</span> <span class="n">functools</span><span class="p">.</span><span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">accum</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">accum</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">accum</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="s">'</span><span class="se">\n</span><span class="s">'</span> <span class="k">else</span> <span class="n">accum</span> <span class="o">+</span> <span class="p">[[]],</span> <span class="n">data</span><span class="p">,</span> <span class="p">[[]])</span>

<span class="c1"># all characters are +4 away from one another, first one at pos 1. reparse accordingly        
</span><span class="n">segments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">4</span><span class="p">)],</span> <span class="n">segments</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

<span class="c1"># flatten segments[0] into a queue-like structure                                             
</span><span class="n">stacks</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">segments</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]))]</span>                                             
<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>                                                               
    <span class="k">if</span> <span class="n">col</span> <span class="o">!=</span> <span class="s">' '</span><span class="p">:</span>
      <span class="n">stacks</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>                                                                   
<span class="n">stacks</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">stack</span><span class="p">))</span> <span class="k">for</span> <span class="n">stack</span> <span class="ow">in</span> <span class="n">stacks</span><span class="p">]</span>                                          

<span class="c1"># flatten segments[1] into a list of tuple instructions                                       
</span><span class="n">digit_fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">s</span><span class="p">.</span><span class="n">split</span><span class="p">()</span> <span class="k">if</span> <span class="n">x</span><span class="p">.</span><span class="n">isdigit</span><span class="p">()]</span>                               
<span class="n">instructions</span> <span class="o">=</span> <span class="p">[</span><span class="n">digit_fn</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

<span class="c1"># do the movements                                                                            
</span><span class="k">for</span> <span class="n">instruction</span> <span class="ow">in</span> <span class="n">instructions</span><span class="p">:</span>                                                              
  <span class="n">stack_from</span> <span class="o">=</span> <span class="n">instruction</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>                                                             
  <span class="n">stack_to</span> <span class="o">=</span> <span class="n">instruction</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> 
  <span class="n">number</span> <span class="o">=</span> <span class="n">instruction</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  
  <span class="n">stacks</span><span class="p">[</span><span class="n">stack_to</span><span class="p">].</span><span class="n">extend</span><span class="p">(</span><span class="n">stacks</span><span class="p">[</span><span class="n">stack_from</span><span class="p">][</span><span class="o">-</span><span class="n">number</span><span class="p">:])</span>                                       
  <span class="n">stacks</span><span class="p">[</span><span class="n">stack_from</span><span class="p">]</span> <span class="o">=</span> <span class="n">stacks</span><span class="p">[</span><span class="n">stack_from</span><span class="p">][:</span><span class="o">-</span><span class="n">number</span><span class="p">]</span>
  
<span class="c1"># get the top of all                                                                          
</span><span class="k">print</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">([</span><span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stacks</span><span class="p">]))</span>
</code></pre></div>    </div>

    <hr>

    <h1 id="day-6">Day 6</h1>

    <p>Oh no I can feel the deadlines! I’ve decided to take a crack at implementing another thing in C. Since I was also feeling lazy, I decided to use C.</p>

    <h2 id="part-1-5">Part 1</h2>

    <p>Today’s puzzle involves us picking out the position of the first unique character in a sliding frame of 4. The most obvious algorithm is generally as follows:</p>

    <ol>
      <li>Load the first 4 characters into a set</li>
      <li>If the set has a length of 4, then you are done, position 4 is the answer</li>
      <li>Otherwise, go on to the next position, load the previous 3 characters and itself into a set, and check length of set</li>
      <li>If length is 4, current position is the answer, otherwise, repeat step 3</li>
    </ol>

    <p>The above algorithm is probably also the fastest I know, since the set operations involved is <code class="language-plaintext highlighter-rouge">O(4)</code>. Iterating through the string, that’s <code class="language-plaintext highlighter-rouge">O(n)</code>, so the total runtime of this solution would be <code class="language-plaintext highlighter-rouge">O(4n)</code>.</p>

    <p>In C, however, we don’t have sets, and I don’t really feel like implementing one. Instead, I employed a technique known as dynamic programming to implement something like a queue, which memorizes 4 values at once. Whenever a new character is read from the input stream, the head of the queue is popped, and the new character is pushed into the queue.</p>

    <p>To speed up figuring out if there are any duplicate elements, I created a map of 26 characters and maintain a reference count of each alphabet in the queue. In theory, the function will simply need to iterate through the queue, lookup the alphabet in the map, look at the reference count, and if it’s all 1, we’ve found our character.</p>

    <p>This method has a rough time complexity of: <code class="language-plaintext highlighter-rouge">O(n)</code> for going through the string, <code class="language-plaintext highlighter-rouge">O(4)</code> for the dynamic programming implementation, <code class="language-plaintext highlighter-rouge">O(4)</code> for checking the queue. If 4 is an unknown, this’ll be <code class="language-plaintext highlighter-rouge">O(k^2 * n)</code>. Damn.</p>

    <p>So:</p>

    <div class="language-c highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">FILE</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"input.txt"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span>
  <span class="kt">char</span> <span class="n">exist_map</span><span class="p">[</span><span class="mi">26</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">n_processed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">buf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">((</span><span class="n">buf</span> <span class="o">=</span> <span class="n">fgetc</span><span class="p">(</span><span class="n">f</span><span class="p">))</span> <span class="o">!=</span> <span class="n">EOF</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">n_processed</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">exist_map</span><span class="p">[</span><span class="n">buf</span> <span class="o">-</span> <span class="sc">'a'</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">a</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">a</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">b</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">c</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"delimiter found at %lu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n_processed</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span><span class="n">a</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">exist_map</span> <span class="o">+</span> <span class="p">(</span><span class="n">buf</span> <span class="o">-</span> <span class="sc">'a'</span><span class="p">);</span>
    <span class="o">*</span><span class="n">d</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span> <span class="n">d</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">fclose</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div>    </div>

    <p>The dynamic programming implementation can be improved, but oh well.</p>

    <h2 id="part-2-5">Part 2</h2>

    <p>Increasing the required unique characters from 4 to 14 would have been much easier on Python, but in C, this means I had to abstract my functions, and use an array of <code class="language-plaintext highlighter-rouge">char*</code> instead of defining each position in the queue on my own.</p>

    <p>The two functions to abstract are:</p>

    <ul>
      <li>the one that figures out if all the reference counts relevant to the queue is 1</li>
      <li>the one that shifts the queue to the left by 1, and adding the new value into the queue</li>
    </ul>

    <p>Improving the “queue” can be easily seen in this example, which involves introducing variables to keep a pointer of where the head and tail is. However, I was lazy. So:</p>

    <div class="language-c highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">char</span> <span class="nf">areOnes</span><span class="p">(</span><span class="kt">char</span><span class="o">**</span> <span class="n">pointers</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">pointers</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> 
<span class="p">}</span> 
  
<span class="kt">void</span> <span class="nf">leftShiftExistMap</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">map</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">pointers</span><span class="p">,</span> <span class="kt">char</span> <span class="n">newVal</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pointers</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span><span class="p">(</span><span class="n">pointers</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">pointers</span><span class="p">[</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">map</span> <span class="o">+</span> <span class="p">(</span><span class="n">newVal</span> <span class="o">-</span> <span class="sc">'a'</span><span class="p">);</span>
  <span class="o">*</span><span class="p">(</span><span class="n">pointers</span><span class="p">[</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">pointers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pointers</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
  <span class="n">pointers</span><span class="p">[</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>   
    
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">FILE</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"input.txt"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span>
  <span class="kt">char</span> <span class="n">exist_map</span><span class="p">[</span><span class="mi">26</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">pointers</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="nb">NULL</span><span class="p">};</span>
  <span class="kt">size_t</span> <span class="n">n_processed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">buf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">((</span><span class="n">buf</span> <span class="o">=</span> <span class="n">fgetc</span><span class="p">(</span><span class="n">f</span><span class="p">))</span> <span class="o">!=</span> <span class="n">EOF</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">n_processed</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">exist_map</span><span class="p">[</span><span class="n">buf</span> <span class="o">-</span> <span class="sc">'a'</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">pointers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">areOnes</span><span class="p">(</span><span class="n">pointers</span><span class="p">,</span> <span class="mi">14</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"delimiter found at %lu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n_processed</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">leftShiftExistMap</span><span class="p">(</span><span class="n">exist_map</span><span class="p">,</span> <span class="n">pointers</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">14</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">fclose</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <p>The time complexity is still the same, which is <code class="language-plaintext highlighter-rouge">O(k^2*n)</code> where <code class="language-plaintext highlighter-rouge">k = 14</code>. Use the right tools (i.e. Python) for the right job!</p>

    <hr>

    <h1 id="day-7">Day 7</h1>

    <p>After a mere 4 hours of sleep, I continued to rush deadlines fueled by nothing but coffee in my stomach. Suffice to say, I’m not entirely satisfied with the work I’ve turned in, but what’s done is done, am I right?</p>

    <p>Day 7 was done together with Day 8, because time was just simply not on my side. But hey, I’ve done both, cut me some slack!</p>

    <h2 id="part-1-6">Part 1</h2>

    <p>An interesting use case is presented in day 7, where we essentially had to rebuild the folder structure based on the output of a few commands, and figure out the sum of the set of folders (including subdirectories) that exceeds 100000.</p>

    <p>My very tired and uncaffeinated (half-life of coffee was out) brain immediately thought “trees” and jumped straight into the code. We also have to write a simple parser to figure out what each line in the output did / displayed, so that we can use the information meaningfully.</p>

    <p>So the sub-problems were:</p>

    <ul>
      <li>Figure out what each line said (parsing);</li>
      <li>Create a new node if the line enters a directory.</li>
    </ul>

    <p>Parsing each line is simple, by using spaces as delimiters and tokenizing each word:</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="n">tokens</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">strip</span><span class="p">().</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)</span>  <span class="c1"># x is a line
</span><span class="k">if</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">"$"</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">'ls'</span><span class="p">:</span>
    <span class="c1"># do something
</span>  <span class="k">elif</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s">'..'</span><span class="p">:</span>
    <span class="c1"># do something
</span>  <span class="k">elif</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s">'/'</span><span class="p">:</span>
    <span class="c1"># do something
</span>  <span class="k">else</span><span class="p">:</span>
    <span class="c1"># do something, is a directory
</span><span class="k">elif</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">isdigit</span><span class="p">():</span>
    <span class="c1"># is size of file
</span><span class="k">elif</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">'dir'</span><span class="p">:</span>
    <span class="c1"># is telling us directory exist
</span></code></pre></div>    </div>

    <p>All we need to do now is to create a <code class="language-plaintext highlighter-rouge">Node</code> class that represents our tree:</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dirname</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">dirname</span> <span class="o">=</span> <span class="n">dirname</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">dirname</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">dirname</span>

  <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">dirname</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">"{} {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">dirname</span><span class="p">,</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">nodes</span><span class="p">])</span>

  <span class="k">def</span> <span class="nf">getSize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">value</span> <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="nb">sum</span><span class="p">([</span><span class="n">x</span><span class="p">.</span><span class="n">getSize</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">nodes</span><span class="p">])</span>
</code></pre></div>    </div>

    <p>And then combine all the code together. I also add a <code class="language-plaintext highlighter-rouge">getSolutionSize</code> function in <code class="language-plaintext highlighter-rouge">Node</code>, which traverses the tree depth-first, gets the space occupied on the diskif it’s larger than <code class="language-plaintext highlighter-rouge">100000</code> (specified in the problem), and accumulates the size.:</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dirname</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">dirname</span> <span class="o">=</span> <span class="n">dirname</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">dirname</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">dirname</span>

  <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">dirname</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">"{} {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">dirname</span><span class="p">,</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">nodes</span><span class="p">])</span>

  <span class="k">def</span> <span class="nf">getSolutionSize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
      <span class="k">return</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">getSize</span><span class="p">()</span>
      <span class="k">return</span> <span class="p">(</span><span class="mi">0</span> <span class="k">if</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="mi">100000</span> <span class="k">else</span> <span class="n">size</span><span class="p">)</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">([</span><span class="n">x</span><span class="p">.</span><span class="n">getSolutionSize</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">nodes</span><span class="p">])</span>

  <span class="k">def</span> <span class="nf">getSize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">value</span> <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="nb">sum</span><span class="p">([</span><span class="n">x</span><span class="p">.</span><span class="n">getSize</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">nodes</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">parselines</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">rootNode</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">xs</span> <span class="o">==</span> <span class="p">[]:</span> <span class="k">return</span>

  <span class="n">x</span> <span class="o">=</span> <span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">tokens</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">strip</span><span class="p">().</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">"$"</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">'ls'</span><span class="p">:</span>
      <span class="n">parselines</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">rootNode</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s">'..'</span><span class="p">:</span>
      <span class="n">parselines</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">rootNode</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">parent</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s">'/'</span><span class="p">:</span>
      <span class="n">parselines</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">rootNode</span><span class="p">,</span> <span class="n">rootNode</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">n</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">node</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">node</span><span class="p">.</span><span class="n">nodes</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">.</span><span class="n">nodes</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
      <span class="n">parselines</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">rootNode</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">isdigit</span><span class="p">():</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">node</span><span class="p">)</span>
    <span class="n">n</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">node</span><span class="p">.</span><span class="n">nodes</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">parselines</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">rootNode</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">'dir'</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">node</span><span class="p">)</span>
    <span class="n">node</span><span class="p">.</span><span class="n">nodes</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">parselines</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">rootNode</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>

<span class="n">n</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="s">'/'</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">"input.txt"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">).</span><span class="n">readlines</span><span class="p">()[</span><span class="mi">1</span><span class="p">:]</span>
<span class="n">sys</span><span class="p">.</span><span class="n">setrecursionlimit</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">parselines</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">n</span><span class="p">.</span><span class="n">getSolutionSize</span><span class="p">())</span>
</code></pre></div>    </div>

    <p>Because we use recursion extensively, we have to increase our recursion limit to something we can work with.</p>

    <h2 id="part-2-6">Part 2</h2>

    <p>In Part 2, we find the folder with lowest value that is greater than the free space we need. Luckily, this is a small change (I use tuples, but actually we can just omit the <code class="language-plaintext highlighter-rouge">dirname</code> to remove that information, as we don’t need it for our solution):</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dirname</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">dirname</span> <span class="o">=</span> <span class="n">dirname</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">dirname</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">dirname</span>

  <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">dirname</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">"{} {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">dirname</span><span class="p">,</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">nodes</span><span class="p">])</span>

  <span class="k">def</span> <span class="nf">getSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
      <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">dirname</span><span class="p">,</span> <span class="mi">999999</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">bestTuple</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">dirname</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">getSize</span><span class="p">())</span>
      <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">nodes</span><span class="p">:</span>
        <span class="n">childTuple</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">getSolution</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">childTuple</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span> <span class="ow">and</span> <span class="n">childTuple</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">bestTuple</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
          <span class="n">bestTuple</span> <span class="o">=</span> <span class="n">childTuple</span>
      <span class="k">return</span> <span class="n">bestTuple</span>

  <span class="k">def</span> <span class="nf">getSize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">value</span> <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="nb">sum</span><span class="p">([</span><span class="n">x</span><span class="p">.</span><span class="n">getSize</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">nodes</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">parselines</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">rootNode</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">xs</span> <span class="o">==</span> <span class="p">[]:</span> <span class="k">return</span>

  <span class="n">x</span> <span class="o">=</span> <span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">tokens</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">strip</span><span class="p">().</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">"$"</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">'ls'</span><span class="p">:</span>
      <span class="n">parselines</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">rootNode</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s">'..'</span><span class="p">:</span>
      <span class="n">parselines</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">rootNode</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">parent</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s">'/'</span><span class="p">:</span>
      <span class="n">parselines</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">rootNode</span><span class="p">,</span> <span class="n">rootNode</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">n</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">node</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">node</span><span class="p">.</span><span class="n">nodes</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">.</span><span class="n">nodes</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
      <span class="n">parselines</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">rootNode</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">isdigit</span><span class="p">():</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">node</span><span class="p">)</span>
    <span class="n">n</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">node</span><span class="p">.</span><span class="n">nodes</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">parselines</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">rootNode</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">'dir'</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">node</span><span class="p">)</span>
    <span class="n">node</span><span class="p">.</span><span class="n">nodes</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">parselines</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">rootNode</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>

<span class="n">n</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="s">'/'</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">"input.txt"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">).</span><span class="n">readlines</span><span class="p">()[</span><span class="mi">1</span><span class="p">:]</span>
<span class="n">sys</span><span class="p">.</span><span class="n">setrecursionlimit</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">parselines</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">n</span><span class="p">.</span><span class="n">getSolution</span><span class="p">(</span><span class="mi">30000000</span> <span class="o">-</span> <span class="mi">70000000</span> <span class="o">+</span> <span class="n">n</span><span class="p">.</span><span class="n">getSize</span><span class="p">()))</span>
</code></pre></div>    </div>

    <p><code class="language-plaintext highlighter-rouge">70000000</code> is the total disk space and <code class="language-plaintext highlighter-rouge">30000000</code> is the free space we need. The only change was to <code class="language-plaintext highlighter-rouge">getSolutionSize()</code>, which was changed to <code class="language-plaintext highlighter-rouge">getSolution()</code>:</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="nf">getSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
      <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">dirname</span><span class="p">,</span> <span class="mi">999999</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">bestTuple</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">dirname</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">getSize</span><span class="p">())</span>
      <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">nodes</span><span class="p">:</span>
        <span class="n">childTuple</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">getSolution</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">childTuple</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span> <span class="ow">and</span> <span class="n">childTuple</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">bestTuple</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
          <span class="n">bestTuple</span> <span class="o">=</span> <span class="n">childTuple</span>
      <span class="k">return</span> <span class="n">bestTuple</span>
</code></pre></div>    </div>

    <p>The code block figures out if a child is closer to the target value than itself, done recursively.</p>

    <hr>

    <h1 id="day-8">Day 8</h1>

    <p>Are you tired of human-readable code yet?</p>

    <h2 id="part-1-7">Part 1</h2>

    <p>This is a classic problem, in the sense that many applications rely on figuring out if adjacent cells are blocking the view of a current cell. An example could be collision detection (blocking view distance = 1). The problem we are trying to solve, in programmer terms, is: given grid of numbers, find out if all the numbers to any of the edges of the grid are less than the value at the current (x,y).</p>

    <p>Interestingly, this problem doesn’t have sub-problems, since it’s quite a well-contained problem. The algorithm to solve this would be:</p>

    <ol>
      <li>Go through every x and y starting from <code class="language-plaintext highlighter-rouge">(1, 1)</code>, ending at <code class="language-plaintext highlighter-rouge">(max_x - 1, max_y - 1)</code>
</li>
      <li>Iterate from <code class="language-plaintext highlighter-rouge">0 to x - 1</code>, find out if there are any values that exceed the value at (x,y)</li>
      <li>Repeat step 2 for <code class="language-plaintext highlighter-rouge">x + 1</code> to <code class="language-plaintext highlighter-rouge">max_x - 1</code>
</li>
      <li>Repeat step 2 for <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">y - 1</code>
</li>
      <li>Repeat step 2 for <code class="language-plaintext highlighter-rouge">y + 1</code> to <code class="language-plaintext highlighter-rouge">max_y - 1</code>
</li>
      <li>If any of steps 2 to 5 reports that there are no values that exceed the value at (x,y), then the current (x,y) has met the target condition.</li>
      <li>Collect all the results, and count all (x,y)s that met the condition in step 6</li>
    </ol>

    <p>The code, is hence:</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">itertools</span>
<span class="n">trees</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">int</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span> <span class="k">if</span> <span class="n">y</span> <span class="o">!=</span> <span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="s">'input.txt'</span><span class="p">,</span> <span class="s">'r'</span><span class="p">).</span><span class="n">readlines</span><span class="p">()]</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">itertools</span><span class="p">.</span><span class="n">starmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">row</span><span class="p">,</span> <span class="n">r_trees</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="p">.</span><span class="n">starmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">col</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="nb">all</span><span class="p">([</span><span class="n">trees</span><span class="p">[</span><span class="n">c_u</span><span class="p">][</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tree</span> <span class="k">for</span> <span class="n">c_u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span> <span class="ow">or</span> <span class="nb">all</span><span class="p">([</span><span class="n">trees</span><span class="p">[</span><span class="n">c_d</span><span class="p">][</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tree</span> <span class="k">for</span> <span class="n">c_d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">row</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">trees</span><span class="p">))])</span> <span class="ow">or</span> <span class="nb">all</span><span class="p">([</span><span class="n">trees</span><span class="p">[</span><span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">r_l</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tree</span> <span class="k">for</span> <span class="n">r_l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span> <span class="ow">or</span> <span class="nb">all</span><span class="p">([</span><span class="n">trees</span><span class="p">[</span><span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">r_r</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tree</span> <span class="k">for</span> <span class="n">r_r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">col</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">r_trees</span><span class="p">))]),</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">r_trees</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))),</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">trees</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

<span class="k">print</span><span class="p">(</span><span class="nb">sum</span><span class="p">([</span><span class="nb">sum</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">result</span><span class="p">])</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">trees</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">trees</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span>
</code></pre></div>    </div>

    <p>The most readable thing on the planet, I know.</p>

    <h2 id="part-2-7">Part 2</h2>

    <p>Instead of figuring out how many (x,y)s have larger values than all the values to any edges of the grid, we now compute a score for each (x,y) based on <em>how many</em> values there is until the current value <code class="language-plaintext highlighter-rouge">&lt;=</code> a value along the path to the edge of the grid, composited with multiplication.</p>

    <p>It’s really changing the function <code class="language-plaintext highlighter-rouge">all</code> to <code class="language-plaintext highlighter-rouge">sum list itertools.takewhile</code>, which sums the list of True values, while current value is still more than the values it traverses to reach the edge. As the stopping number themselves is counted into the sum (+1), we need to handle the case where all of the numbers were lower than the value at (x,y), which shouldn’t have the +1 offset. A <code class="language-plaintext highlighter-rouge">min</code> function is applied to handle that case. So:</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">itertools</span>
<span class="n">trees</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">int</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span> <span class="k">if</span> <span class="n">y</span> <span class="o">!=</span> <span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="s">'input.txt'</span><span class="p">,</span> <span class="s">'r'</span><span class="p">).</span><span class="n">readlines</span><span class="p">()]</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">itertools</span><span class="p">.</span><span class="n">starmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">row</span><span class="p">,</span> <span class="n">r_trees</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="p">.</span><span class="n">starmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">col</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="nb">min</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="p">.</span><span class="n">takewhile</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="n">trees</span><span class="p">[</span><span class="n">c_u</span><span class="p">][</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tree</span> <span class="k">for</span> <span class="n">c_u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)])))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="nb">min</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="p">.</span><span class="n">takewhile</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="n">trees</span><span class="p">[</span><span class="n">c_d</span><span class="p">][</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tree</span> <span class="k">for</span> <span class="n">c_d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">row</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">trees</span><span class="p">))])))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">trees</span><span class="p">)</span> <span class="o">-</span> <span class="n">row</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="nb">min</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="p">.</span><span class="n">takewhile</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="n">trees</span><span class="p">[</span><span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">r_l</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tree</span> <span class="k">for</span> <span class="n">r_l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)])))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="nb">min</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="p">.</span><span class="n">takewhile</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="n">trees</span><span class="p">[</span><span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">r_r</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tree</span> <span class="k">for</span> <span class="n">r_r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">col</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">r_trees</span><span class="p">))])))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">r_trees</span><span class="p">)</span> <span class="o">-</span> <span class="n">col</span> <span class="o">-</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">r_trees</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))),</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">trees</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

<span class="k">print</span><span class="p">(</span><span class="nb">max</span><span class="p">([</span><span class="nb">max</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">result</span><span class="p">]))</span>
</code></pre></div>    </div>

    <hr>

    <h1 id="day-9">Day 9</h1>

    <p>Ah yes, nothing like simulating ropes innit?</p>

    <h2 id="part-1-8">Part 1</h2>

    <p>Our adventures today bring us to simulating a head and tail, where tail has well-defined behaviour, which the prompt has kindly provided:</p>

    <ul>
      <li>if the head and tail are on different rows and columns, move towards the head diagonally</li>
      <li>else, move towards the head laterally / vertically.</li>
    </ul>

    <p>The head is given a list of directions and number of squares to move. So, the sub-problems are:</p>

    <ul>
      <li>parse instruction and number of squares to move</li>
      <li>every time the head moves, check if the tail needs to move
        <ul>
          <li>if the tail is within 1 square of the head, then it doesn’t need to move</li>
          <li>otherwise, move based on the behaviour given by the prompt</li>
        </ul>
      </li>
      <li>once the next position of the tail is decided, put it in the set</li>
      <li>at the end of the procedure, count the number of elements in the set</li>
    </ul>

    <p>My code today is a lot more readable, so it’s quite obvious how the sub-problems are defined:</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="n">head_instructions</span> <span class="o">=</span> <span class="p">[(</span><span class="n">direction</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">.</span><span class="n">strip</span><span class="p">()))</span> <span class="k">for</span> <span class="n">direction</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="p">[</span><span class="n">x</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="s">'input.txt'</span><span class="p">,</span> <span class="s">'r'</span><span class="p">).</span><span class="n">readlines</span><span class="p">()]]</span>

<span class="n">tail_positions</span> <span class="o">=</span> <span class="p">{(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)}</span>
<span class="n">last_head_pos</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">last_tail_pos</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="k">for</span> <span class="n">instruction</span> <span class="ow">in</span> <span class="n">head_instructions</span><span class="p">:</span>
  <span class="nb">dir</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="n">instruction</span>
  <span class="n">h_x</span><span class="p">,</span><span class="n">h_y</span> <span class="o">=</span> <span class="n">last_head_pos</span>
  <span class="n">t_x</span><span class="p">,</span><span class="n">t_y</span> <span class="o">=</span> <span class="n">last_tail_pos</span>

  <span class="n">step</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="nb">dir</span> <span class="ow">in</span> <span class="s">'LD'</span> <span class="k">else</span> <span class="mi">1</span>

  <span class="k">for</span> <span class="n">incr</span> <span class="ow">in</span> <span class="p">[</span><span class="n">step</span><span class="p">]</span> <span class="o">*</span> <span class="n">val</span><span class="p">:</span>
    <span class="n">h_y</span> <span class="o">+=</span> <span class="n">step</span> <span class="k">if</span> <span class="nb">dir</span> <span class="ow">in</span> <span class="s">'UD'</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="n">h_x</span> <span class="o">+=</span> <span class="n">step</span> <span class="k">if</span> <span class="nb">dir</span> <span class="ow">in</span> <span class="s">'LR'</span> <span class="k">else</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">h_x</span> <span class="o">-</span> <span class="n">t_x</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">h_y</span> <span class="o">-</span> <span class="n">t_y</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
      <span class="k">continue</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">t_x</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">0</span> <span class="k">if</span> <span class="n">h_x</span> <span class="o">==</span> <span class="n">t_x</span> <span class="k">else</span> <span class="p">(</span><span class="n">h_x</span> <span class="o">-</span> <span class="n">t_x</span><span class="p">)</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="n">h_x</span> <span class="o">-</span> <span class="n">t_x</span><span class="p">))</span>
      <span class="n">t_y</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">0</span> <span class="k">if</span> <span class="n">h_y</span> <span class="o">==</span> <span class="n">t_y</span> <span class="k">else</span> <span class="p">(</span><span class="n">h_y</span> <span class="o">-</span> <span class="n">t_y</span><span class="p">)</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="n">h_y</span> <span class="o">-</span> <span class="n">t_y</span><span class="p">))</span>
      <span class="n">tail_positions</span><span class="p">.</span><span class="n">add</span><span class="p">((</span><span class="n">t_x</span><span class="p">,</span> <span class="n">t_y</span><span class="p">))</span>

  <span class="n">last_head_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">h_x</span><span class="p">,</span> <span class="n">h_y</span><span class="p">)</span>
  <span class="n">last_tail_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">t_x</span><span class="p">,</span> <span class="n">t_y</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tail_positions</span><span class="p">))</span>
</code></pre></div>    </div>

    <h2 id="part-2-8">Part 2</h2>

    <p>Part 2 gives us more points to control (i.e. the tail follows a point which follows another point, etc until the head). This means we have to maintain the positions of all the points, and compare the positions pairwise. Luckily for us, the behaviour is the same. So, for each step in our instructions, we go through the positions pairwise and to update positions. Since we are interested in how the tail moves, we only store all the co-ordinates visited by the tail in our set.</p>

    <p>So:</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="n">head_instructions</span> <span class="o">=</span> <span class="p">[(</span><span class="n">direction</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">.</span><span class="n">strip</span><span class="p">()))</span> <span class="k">for</span> <span class="n">direction</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="p">[</span><span class="n">x</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="s">'input.txt'</span><span class="p">,</span> <span class="s">'r'</span><span class="p">).</span><span class="n">readlines</span><span class="p">()]]</span>

<span class="n">tail_positions</span> <span class="o">=</span> <span class="p">{(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)}</span>
<span class="n">last_positions</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">instruction</span> <span class="ow">in</span> <span class="n">head_instructions</span><span class="p">:</span>
  <span class="nb">dir</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="n">instruction</span>
  <span class="n">step</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="nb">dir</span> <span class="ow">in</span> <span class="s">'LD'</span> <span class="k">else</span> <span class="mi">1</span>

  <span class="k">for</span> <span class="n">incr</span> <span class="ow">in</span> <span class="p">[</span><span class="n">step</span><span class="p">]</span> <span class="o">*</span> <span class="n">val</span><span class="p">:</span>
    <span class="n">g_x</span><span class="p">,</span> <span class="n">g_y</span> <span class="o">=</span> <span class="n">last_positions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">g_y</span> <span class="o">+=</span> <span class="n">step</span> <span class="k">if</span> <span class="nb">dir</span> <span class="ow">in</span> <span class="s">'UD'</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="n">g_x</span> <span class="o">+=</span> <span class="n">step</span> <span class="k">if</span> <span class="nb">dir</span> <span class="ow">in</span> <span class="s">'LR'</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="n">last_positions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">g_x</span><span class="p">,</span> <span class="n">g_y</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">last_positions</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
      <span class="n">h_x</span><span class="p">,</span><span class="n">h_y</span> <span class="o">=</span> <span class="n">last_positions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
      <span class="n">t_x</span><span class="p">,</span><span class="n">t_y</span> <span class="o">=</span> <span class="n">last_positions</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

      <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">h_x</span> <span class="o">-</span> <span class="n">t_x</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">h_y</span> <span class="o">-</span> <span class="n">t_y</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">continue</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">t_x</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">0</span> <span class="k">if</span> <span class="n">h_x</span> <span class="o">==</span> <span class="n">t_x</span> <span class="k">else</span> <span class="p">(</span><span class="n">h_x</span> <span class="o">-</span> <span class="n">t_x</span><span class="p">)</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="n">h_x</span> <span class="o">-</span> <span class="n">t_x</span><span class="p">))</span>
        <span class="n">t_y</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">0</span> <span class="k">if</span> <span class="n">h_y</span> <span class="o">==</span> <span class="n">t_y</span> <span class="k">else</span> <span class="p">(</span><span class="n">h_y</span> <span class="o">-</span> <span class="n">t_y</span><span class="p">)</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="n">h_y</span> <span class="o">-</span> <span class="n">t_y</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">9</span><span class="p">:</span>
          <span class="n">tail_positions</span><span class="p">.</span><span class="n">add</span><span class="p">((</span><span class="n">t_x</span><span class="p">,</span> <span class="n">t_y</span><span class="p">))</span>

      <span class="n">last_positions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">h_x</span><span class="p">,</span> <span class="n">h_y</span><span class="p">)</span>
      <span class="n">last_positions</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">t_x</span><span class="p">,</span> <span class="n">t_y</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tail_positions</span><span class="p">))</span>
</code></pre></div>    </div>

    <hr>

    <h1 id="day-10">Day 10</h1>

    <p>CPU instructions!</p>

    <h2 id="part-1-9">Part 1</h2>

    <p>This problem is what I would classify as a parser-type problem; it usually involves the programmer writing some sort of basic parser.</p>

    <p>The sub-problems are:</p>

    <ul>
      <li>For each line, split the line by the space character</li>
      <li>Based on the instruction:
        <ul>
          <li>
<code class="language-plaintext highlighter-rouge">addx</code> increment cycles by two, figure out if within the two increments if we’ve crossed <code class="language-plaintext highlighter-rouge">20</code> or <code class="language-plaintext highlighter-rouge">- 20 mod 40</code>, and modify the signal strength accordingly</li>
          <li>
<code class="language-plaintext highlighter-rouge">noop</code> increment cycles by one, figure out if we’ve crossed <code class="language-plaintext highlighter-rouge">20</code> or <code class="language-plaintext highlighter-rouge">- 20 mod 40</code>, and modify the signal strength accordingly</li>
        </ul>
      </li>
    </ul>

    <p>Thinking that this would be easy to do in Haskell, I gave it a go:</p>

    <div class="language-haskell highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="n">inputStr</span> <span class="o">=</span> <span class="s">""</span>

<span class="n">solution</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Integer</span>
<span class="n">solution</span> <span class="n">input</span> <span class="o">=</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="kr">_</span><span class="p">,</span><span class="kr">_</span><span class="p">,</span><span class="n">z</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="p">)</span> <span class="o">$</span> <span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span><span class="n">accum</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">step</span> <span class="n">x</span> <span class="p">(</span><span class="kr">if</span> <span class="n">null</span> <span class="n">xs</span> <span class="kr">then</span> <span class="mi">0</span> <span class="kr">else</span> <span class="p">(</span><span class="n">read</span> <span class="o">$</span> <span class="n">head</span> <span class="n">xs</span><span class="p">))</span> <span class="n">accum</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">$</span> <span class="n">map</span> <span class="n">words</span> <span class="o">$</span> <span class="n">lines</span> <span class="n">input</span>
  <span class="kr">where</span>  
        <span class="n">stepAddX</span> <span class="n">x</span> <span class="n">accum</span><span class="o">@</span><span class="p">(</span><span class="n">cycles</span><span class="p">,</span><span class="n">sums</span><span class="p">,</span><span class="n">sigstr</span><span class="p">)</span> <span class="n">y</span> <span class="o">=</span> <span class="kr">if</span> <span class="p">((</span><span class="n">cycles</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="mi">20</span><span class="p">)</span> <span class="o">||</span> <span class="p">((</span><span class="n">cycles</span> <span class="o">+</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">20</span><span class="p">)</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">40</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="kr">then</span> <span class="p">(</span><span class="n">cycles</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">sums</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">sigstr</span> <span class="o">+</span> <span class="kr">if</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">1</span> <span class="kr">then</span> <span class="n">sums</span> <span class="o">*</span> <span class="p">(</span><span class="n">cycles</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="kr">else</span> <span class="p">(</span><span class="n">sums</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">cycles</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span> <span class="kr">else</span> <span class="p">(</span><span class="n">cycles</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">sums</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">sigstr</span><span class="p">)</span>
        <span class="n">step</span> <span class="s">"noop"</span> <span class="kr">_</span> <span class="n">accum</span><span class="o">@</span><span class="p">(</span><span class="n">cycles</span><span class="p">,</span><span class="n">sums</span><span class="p">,</span><span class="n">sigstr</span><span class="p">)</span> <span class="o">=</span> <span class="kr">if</span> <span class="p">((</span><span class="n">cycles</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">20</span><span class="p">)</span> <span class="o">||</span> <span class="p">((</span><span class="n">cycles</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">20</span><span class="p">)</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">40</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="kr">then</span> <span class="p">(</span><span class="n">cycles</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sums</span><span class="p">,</span> <span class="n">sigstr</span> <span class="o">+</span> <span class="n">sums</span> <span class="o">*</span> <span class="p">(</span><span class="n">cycles</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="kr">else</span> <span class="p">(</span><span class="n">cycles</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sums</span><span class="p">,</span> <span class="n">sigstr</span><span class="p">)</span>
        <span class="n">step</span> <span class="s">"addx"</span> <span class="n">x</span> <span class="n">accum</span><span class="o">@</span><span class="p">(</span><span class="n">cycles</span><span class="p">,</span><span class="kr">_</span><span class="p">,</span><span class="kr">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">stepAddX</span> <span class="n">x</span> <span class="n">accum</span> <span class="p">(</span><span class="kr">if</span> <span class="n">odd</span> <span class="n">cycles</span> <span class="kr">then</span> <span class="mi">1</span> <span class="kr">else</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div>    </div>

    <p>Compiles fine, but gives nonsensical values. I’ll give you some time, figure out what may have went wrong here.</p>

    <p>Have you thought about it yet?</p>

    <p>Right, the reason why this doesn’t work, is because we’re talking about <code class="language-plaintext highlighter-rouge">20</code> and <code class="language-plaintext highlighter-rouge">-20 mod 40</code>, which is a step function. The key to this error is <code class="language-plaintext highlighter-rouge">foldr</code>, which <strong>processes elements starting from the last element</strong>. This costed me 3 hours, no joke.</p>

    <p>So, the final code works once I changed <code class="language-plaintext highlighter-rouge">foldr</code> to <code class="language-plaintext highlighter-rouge">foldl</code>, which processes lists starting from the first element.</p>

    <div class="language-haskell highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="n">inputStr</span> <span class="o">=</span> <span class="s">""</span>

<span class="n">solution</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Integer</span>
<span class="n">solution</span> <span class="n">input</span> <span class="o">=</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="kr">_</span><span class="p">,</span><span class="kr">_</span><span class="p">,</span><span class="n">z</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="p">)</span> <span class="o">$</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">accum</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">step</span> <span class="n">x</span> <span class="p">(</span><span class="kr">if</span> <span class="n">null</span> <span class="n">xs</span> <span class="kr">then</span> <span class="mi">0</span> <span class="kr">else</span> <span class="p">(</span><span class="n">read</span> <span class="o">$</span> <span class="n">head</span> <span class="n">xs</span><span class="p">))</span> <span class="n">accum</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">$</span> <span class="n">map</span> <span class="n">words</span> <span class="o">$</span> <span class="n">lines</span> <span class="n">input</span>
  <span class="kr">where</span>
        <span class="n">stepAddX</span> <span class="n">x</span> <span class="n">accum</span><span class="o">@</span><span class="p">(</span><span class="n">cycles</span><span class="p">,</span><span class="n">sums</span><span class="p">,</span><span class="n">sigstr</span><span class="p">)</span> <span class="n">y</span> <span class="o">=</span> <span class="kr">if</span> <span class="p">((</span><span class="n">cycles</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="mi">20</span><span class="p">)</span> <span class="o">||</span> <span class="p">((</span><span class="n">cycles</span> <span class="o">+</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">20</span><span class="p">)</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">40</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="kr">then</span> <span class="p">(</span><span class="n">cycles</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">sums</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">sigstr</span> <span class="o">+</span> <span class="kr">if</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">1</span> <span class="kr">then</span> <span class="n">sums</span> <span class="o">*</span> <span class="p">(</span><span class="n">cycles</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="kr">else</span> <span class="p">(</span><span class="n">sums</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">cycles</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span> <span class="kr">else</span> <span class="p">(</span><span class="n">cycles</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">sums</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">sigstr</span><span class="p">)</span>
        <span class="n">step</span> <span class="s">"noop"</span> <span class="kr">_</span> <span class="n">accum</span><span class="o">@</span><span class="p">(</span><span class="n">cycles</span><span class="p">,</span><span class="n">sums</span><span class="p">,</span><span class="n">sigstr</span><span class="p">)</span> <span class="o">=</span> <span class="kr">if</span> <span class="p">((</span><span class="n">cycles</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">20</span><span class="p">)</span> <span class="o">||</span> <span class="p">((</span><span class="n">cycles</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">20</span><span class="p">)</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">40</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="kr">then</span> <span class="p">(</span><span class="n">cycles</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sums</span><span class="p">,</span> <span class="n">sigstr</span> <span class="o">+</span> <span class="n">sums</span> <span class="o">*</span> <span class="p">(</span><span class="n">cycles</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="kr">else</span> <span class="p">(</span><span class="n">cycles</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sums</span><span class="p">,</span> <span class="n">sigstr</span><span class="p">)</span>
        <span class="n">step</span> <span class="s">"addx"</span> <span class="n">x</span> <span class="n">accum</span><span class="o">@</span><span class="p">(</span><span class="n">cycles</span><span class="p">,</span><span class="kr">_</span><span class="p">,</span><span class="kr">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">stepAddX</span> <span class="n">x</span> <span class="n">accum</span> <span class="p">(</span><span class="kr">if</span> <span class="n">odd</span> <span class="n">cycles</span> <span class="kr">then</span> <span class="mi">1</span> <span class="kr">else</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div>    </div>

    <h2 id="part-2-9">Part 2</h2>

    <p>Each day’s part 2 is typically a quick edit of each day’s part 1. However, not for this particular sub-problem. By changing the purpose of the CPU instructions, I had to pretty much change my entire function definition.</p>

    <p>Luckily for me, for the most part, <code class="language-plaintext highlighter-rouge">cycles</code> and <code class="language-plaintext highlighter-rouge">sums</code> still have the same concepts. Hence, the only thing I really needed to modify was <code class="language-plaintext highlighter-rouge">sigstr</code>, and how I render the output:</p>

    <div class="language-haskell highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kr">import</span> <span class="nn">Data.List.Split</span> <span class="p">(</span><span class="nf">chunksOf</span><span class="p">)</span>

<span class="n">inputStr</span> <span class="o">=</span> <span class="s">""</span>

<span class="n">solution</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span>
<span class="n">solution</span> <span class="n">input</span> <span class="o">=</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="kr">_</span><span class="p">,</span><span class="kr">_</span><span class="p">,</span><span class="n">z</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">chunksOf</span> <span class="mi">40</span> <span class="o">$</span> <span class="n">reverse</span> <span class="n">z</span><span class="p">)</span> <span class="o">$</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">accum</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">step</span> <span class="n">x</span> <span class="p">(</span><span class="kr">if</span> <span class="n">null</span> <span class="n">xs</span> <span class="kr">then</span> <span class="mi">0</span> <span class="kr">else</span> <span class="p">(</span><span class="n">read</span> <span class="o">$</span> <span class="n">head</span> <span class="n">xs</span><span class="p">))</span> <span class="n">accum</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s">"#"</span><span class="p">)</span> <span class="o">$</span> <span class="n">map</span> <span class="n">words</span> <span class="o">$</span> <span class="n">lines</span> <span class="n">input</span>
  <span class="kr">where</span>
        <span class="n">isWithin</span> <span class="n">cycles</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">cycles</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">40</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cycles</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">40</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">x</span>
        <span class="n">step</span> <span class="s">"noop"</span> <span class="kr">_</span> <span class="p">(</span><span class="n">cycles</span><span class="p">,</span><span class="n">lastx</span><span class="p">,</span><span class="n">result</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">cycles</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">lastx</span><span class="p">,</span> <span class="p">(</span><span class="kr">if</span> <span class="p">(</span><span class="n">isWithin</span> <span class="p">(</span><span class="n">cycles</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="n">lastx</span><span class="p">)</span> <span class="kr">then</span> <span class="sc">'#'</span> <span class="kr">else</span> <span class="sc">'.'</span><span class="p">)</span> <span class="o">:</span> <span class="n">result</span><span class="p">)</span>
        <span class="n">step</span> <span class="s">"addx"</span> <span class="n">x</span> <span class="p">(</span><span class="n">cycles</span><span class="p">,</span><span class="n">lastx</span><span class="p">,</span><span class="n">result</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">cycles</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">lastx</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="kr">if</span> <span class="n">isWithin</span> <span class="p">(</span><span class="n">cycles</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="n">lastx</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span> <span class="kr">then</span> <span class="sc">'#'</span> <span class="kr">else</span> <span class="sc">'.'</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="kr">if</span> <span class="n">isWithin</span> <span class="p">(</span><span class="n">cycles</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="n">lastx</span> <span class="kr">then</span> <span class="sc">'#'</span> <span class="kr">else</span> <span class="sc">'.'</span><span class="p">)</span> <span class="o">:</span> <span class="n">result</span><span class="p">)</span>
</code></pre></div>    </div>

    <p>The answer would be a list of Strings, which I then manually copy and paste into a text editor to reformat into text that had any meaning to me.</p>

    <hr>

    <h1 id="day-11">Day 11</h1>

    <p>I’ll be honest; this is the hardest part 2 yet. I solved part 2 instinctual, but it took a long time for me to figure out <em>why</em> my solution worked.</p>

    <h2 id="part-1-10">Part 1</h2>

    <p>Part 1 is quite simple; in simple programmer terms, we have some queues of items, and move the items around based on conditions that have its parameters changed based on the input.</p>

    <p>Let’s deconstruct the problem a little bit more:</p>

    <ul>
      <li>The condition parameters are:
        <ul>
          <li>the operator, which is either <code class="language-plaintext highlighter-rouge">+</code> or <code class="language-plaintext highlighter-rouge">*</code>
</li>
          <li>the operand, which is either a fixed integer, or <code class="language-plaintext highlighter-rouge">old</code>, which refers to the value of the item</li>
        </ul>
      </li>
      <li>Based on the condition being true/false, the item is redirected to another queue also defined by the input. e.g. If condition is true, send to queue 2. Else, send to queue 3.</li>
    </ul>

    <p>So, the sub-problems are:</p>

    <ul>
      <li>Parse the input into blocks</li>
      <li>Extract the necessary information from each block: starting items, the operation, the operand, the test parameter, and the queues to send the item to depending on the condition</li>
      <li>For each round, for each block, send items to their new queues based on the condition</li>
      <li>Get the top two queues that processed the most items</li>
    </ul>

    <p>I decided to write my code with some level of structure this time round, because the implementation is slightly complicated compared to the past days.</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">islice</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="nb">reduce</span>

<span class="k">class</span> <span class="nc">Monkey</span><span class="p">:</span>
  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">):</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">items_inspected</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">parse_block</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
  
  <span class="k">def</span> <span class="nf">parse_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">):</span>
    <span class="bp">self</span><span class="p">.</span><span class="nb">id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)[</span><span class="mi">1</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">items</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
    <span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">items</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s">' ,'</span><span class="p">)))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">block</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]]</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">operation</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span> <span class="k">if</span> <span class="n">block</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="s">'*'</span> <span class="k">else</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">is_mult</span> <span class="o">=</span> <span class="n">block</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="s">'*'</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">operand</span> <span class="o">=</span> <span class="n">block</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)[</span><span class="mi">5</span><span class="p">]</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">test</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)[</span><span class="mi">3</span><span class="p">])</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">true_result</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="mi">4</span><span class="p">].</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)[</span><span class="mi">5</span><span class="p">])</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">false_result</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="mi">5</span><span class="p">].</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)[</span><span class="mi">5</span><span class="p">])</span>
  
  <span class="k">def</span> <span class="nf">throw_items</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">monkeys</span><span class="p">):</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">.</span><span class="n">items</span><span class="p">.</span><span class="n">empty</span><span class="p">():</span>
      <span class="n">item</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">items</span><span class="p">.</span><span class="n">get</span><span class="p">()</span>
      <span class="n">worry</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">operation</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">item</span> <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">operand</span> <span class="o">==</span> <span class="s">'old'</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">operand</span><span class="p">))</span> <span class="o">//</span> <span class="mi">3</span> 
      <span class="n">monkeys</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">true_result</span> <span class="k">if</span> <span class="n">worry</span> <span class="o">%</span> <span class="bp">self</span><span class="p">.</span><span class="n">test</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">self</span><span class="p">.</span><span class="n">false_result</span><span class="p">].</span><span class="n">items</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">worry</span><span class="p">)</span>
      <span class="bp">self</span><span class="p">.</span><span class="n">items_inspected</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">processor</span><span class="p">(</span><span class="n">monkeys</span><span class="p">,</span> <span class="n">target_rounds</span><span class="p">):</span>
  <span class="k">for</span> <span class="n">n_rounds</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">target_rounds</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">monkey</span> <span class="ow">in</span> <span class="n">monkeys</span><span class="p">:</span>
      <span class="n">monkey</span><span class="p">.</span><span class="n">throw_items</span><span class="p">(</span><span class="n">monkeys</span><span class="p">)</span>
  
  <span class="n">best_two</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">monkeys</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">.</span><span class="n">items_inspected</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">best_two</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">items_inspected</span> <span class="o">*</span> <span class="n">best_two</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">items_inspected</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
  <span class="n">lines</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">'input.txt'</span><span class="p">,</span> <span class="s">'r'</span><span class="p">).</span><span class="n">readlines</span><span class="p">()</span>
  <span class="n">blocks</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">accum</span><span class="p">,</span> <span class="n">line</span><span class="p">:</span> <span class="n">accum</span> <span class="o">+</span> <span class="p">[[]]</span> <span class="k">if</span> <span class="n">line</span> <span class="o">==</span> <span class="s">'</span><span class="se">\n</span><span class="s">'</span> <span class="k">else</span> <span class="n">accum</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">accum</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">line</span><span class="p">.</span><span class="n">strip</span><span class="p">()]],</span> <span class="n">lines</span><span class="p">,</span> <span class="p">[[]])</span>
  <span class="n">monkeys</span> <span class="o">=</span> <span class="p">[</span><span class="n">Monkey</span><span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">blocks</span><span class="p">]</span>

  <span class="k">print</span><span class="p">(</span><span class="n">processor</span><span class="p">(</span><span class="n">monkeys</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
</code></pre></div>    </div>

    <h2 id="part-2-10">Part 2</h2>

    <p>In this part, the condition was changed to no longer include the <code class="language-plaintext highlighter-rouge">// 3</code>, meaning that the numbers grew out of proportion, especially when we want 10000 rounds. In Python, large integers, although take time to function, and hence, the program will take too long to complete.</p>

    <p>Hence, part 2’s prompt suggested that we find a better way to represent the <code class="language-plaintext highlighter-rouge">worry</code> variable. I went to inspect the counts of the queue at the end of 10, 20 and 30 rounds; even though there is some correlation in the rate of change of counts, it is not strictly linear. This is because the operations are different; inspect the input:</p>

    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>Monkey 0:
  Starting items: 79, 98
  Operation: new = old * 19
  Test: divisible by 23
    If true: throw to monkey 2
    If false: throw to monkey 3

Monkey 1:
  Starting items: 54, 65, 75, 74
  Operation: new = old + 6
  Test: divisible by 19
    If true: throw to monkey 2
    If false: throw to monkey 0

Monkey 2:
  Starting items: 79, 60, 97
  Operation: new = old * old
  Test: divisible by 13
    If true: throw to monkey 1
    If false: throw to monkey 3

Monkey 3:
  Starting items: 74
  Operation: new = old + 3
  Test: divisible by 17
    If true: throw to monkey 0
    If false: throw to monkey 1
</code></pre></div>    </div>

    <p>There is a high probability that a value will go through queues 0, 3, and 1, but a probability still exists that it will go through queue 2, which affects the final queue count. Hence, attempting to map the queue count linearly is not viable.</p>

    <p>The next thing I looked at was the input. I tried to think about how the operations will affect the divisibility of the items and concluded (after 30 minutes of thinking) that there is no fixed pattern, due addition. If all operations were multiplications, then the story would be different; we would be able to definitively tell if a number will be divisible by the condition the first time we look at the item, or the operand.</p>

    <p>The next observation I made was that each test was relatively constant; they are always in the format: <code class="language-plaintext highlighter-rouge">divisible by &lt;prime number&gt;</code>. For a moment, I thought of some math, like “how would I know if 2^x + 3^y = 7n, where x, y, n are natural numbers?” -&gt; the answer is I have no idea.</p>

    <p>Then, my instincts took over and I just replaced <code class="language-plaintext highlighter-rouge">// 3</code> with <code class="language-plaintext highlighter-rouge">mod (sum of all test prime numbers in the input)</code> and ran the script on the input without blinking twice. To my surprise, it worked; it was one of those situations where my instincts completed its processes far ahead of the capabilities of my logical thinking.</p>

    <p>The code change was one of those that looks insignificant (it literally replaces 4 characters with a modulo), but had a few hours of effort put into it.</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">queue</span> <span class="kn">import</span> <span class="n">Queue</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">islice</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="nb">reduce</span>

<span class="k">class</span> <span class="nc">Monkey</span><span class="p">:</span>
  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">):</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">items_inspected</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">parse_block</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">parse_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">):</span>
    <span class="bp">self</span><span class="p">.</span><span class="nb">id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)[</span><span class="mi">1</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">items</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
    <span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">items</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s">' ,'</span><span class="p">)))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">block</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]]</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">operation</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span> <span class="k">if</span> <span class="n">block</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="s">'*'</span> <span class="k">else</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">is_mult</span> <span class="o">=</span> <span class="n">block</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="s">'*'</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">operand</span> <span class="o">=</span> <span class="n">block</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)[</span><span class="mi">5</span><span class="p">]</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">test</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)[</span><span class="mi">3</span><span class="p">])</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">true_result</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="mi">4</span><span class="p">].</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)[</span><span class="mi">5</span><span class="p">])</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">false_result</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="mi">5</span><span class="p">].</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)[</span><span class="mi">5</span><span class="p">])</span>

  <span class="k">def</span> <span class="nf">throw_items</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">monkeys</span><span class="p">):</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">.</span><span class="n">items</span><span class="p">.</span><span class="n">empty</span><span class="p">():</span>
      <span class="n">item</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">items</span><span class="p">.</span><span class="n">get</span><span class="p">()</span>
      <span class="n">worry</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">operation</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">item</span> <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">operand</span> <span class="o">==</span> <span class="s">'old'</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">operand</span><span class="p">))</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">17</span> <span class="o">*</span> <span class="mi">7</span> <span class="o">*</span> <span class="mi">11</span> <span class="o">*</span> <span class="mi">19</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">*</span> <span class="mi">13</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
      <span class="n">monkeys</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">true_result</span> <span class="k">if</span> <span class="n">worry</span> <span class="o">%</span> <span class="bp">self</span><span class="p">.</span><span class="n">test</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">self</span><span class="p">.</span><span class="n">false_result</span><span class="p">].</span><span class="n">items</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">worry</span><span class="p">)</span>
      <span class="bp">self</span><span class="p">.</span><span class="n">items_inspected</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">processor</span><span class="p">(</span><span class="n">monkeys</span><span class="p">,</span> <span class="n">target_rounds</span><span class="p">):</span>
  <span class="k">for</span> <span class="n">n_rounds</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">target_rounds</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">monkey</span> <span class="ow">in</span> <span class="n">monkeys</span><span class="p">:</span>
      <span class="n">monkey</span><span class="p">.</span><span class="n">throw_items</span><span class="p">(</span><span class="n">monkeys</span><span class="p">)</span>

  <span class="n">best_two</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">monkeys</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">.</span><span class="n">items_inspected</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">best_two</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">items_inspected</span> <span class="o">*</span> <span class="n">best_two</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">items_inspected</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
  <span class="n">lines</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">'input.txt'</span><span class="p">,</span> <span class="s">'r'</span><span class="p">).</span><span class="n">readlines</span><span class="p">()</span>
  <span class="n">blocks</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">accum</span><span class="p">,</span> <span class="n">line</span><span class="p">:</span> <span class="n">accum</span> <span class="o">+</span> <span class="p">[[]]</span> <span class="k">if</span> <span class="n">line</span> <span class="o">==</span> <span class="s">'</span><span class="se">\n</span><span class="s">'</span> <span class="k">else</span> <span class="n">accum</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">accum</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">line</span><span class="p">.</span><span class="n">strip</span><span class="p">()]],</span> <span class="n">lines</span><span class="p">,</span> <span class="p">[[]])</span>
  <span class="n">monkeys</span> <span class="o">=</span> <span class="p">[</span><span class="n">Monkey</span><span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">blocks</span><span class="p">]</span>

  <span class="k">print</span><span class="p">(</span><span class="n">processor</span><span class="p">(</span><span class="n">monkeys</span><span class="p">,</span> <span class="mi">1000</span><span class="p">))</span>
</code></pre></div>    </div>

    <p>After taking a shower, my logical thinking finally reached a conclusion.</p>

    <p>Let’s break this down into a much simpler problem. Let’s say we have two test prime numbers, 2 and 3. There are 4 things that could possibly happen after applying the operation to our item’s value:</p>

    <ol>
      <li>It’s divisible by 2 and not divisible by 3;</li>
      <li>It’s not divisible by 2 and divisible by 3;</li>
      <li>It’s divisible by 2 and divisible by 3;</li>
      <li>It’s not divisible by 2 and not divisible by 3.</li>
    </ol>

    <p>So, if we were to talk about the possible values of each of the bullet points:</p>

    <ol>
      <li>[2, 4, 8, 10, etc]</li>
      <li>[3, 6, 9, 15, etc]</li>
      <li>[6, 12, 18, 24, etc]</li>
      <li>[1, 5, 7, 11, etc]</li>
    </ol>

    <p>Let’s think about all the numbers in their prime factors:</p>

    <ol>
      <li>[2, 4, 2 * 3 + 2, 2 * 3 + 4, etc]</li>
      <li>[3, 6 + 0, 2 * 3 + 3, 2^2 * 3 + 3, etc]</li>
      <li>[2 * 3, 2^2 * 3, 2 * 3^2, 2^3 * 3^2, etc]</li>
      <li>[1, 5, 2 * 3 + 1, 2 * 3 + 5, etc]</li>
    </ol>

    <p>If we link this to our question, we realise that our these numbers are a combination of multiplication and addition. A further observation suggests that all numbers more than 6 can be broken down into <code class="language-plaintext highlighter-rouge">n = q * 6 + r</code>, where <code class="language-plaintext highlighter-rouge">n</code> is the original number, <code class="language-plaintext highlighter-rouge">q</code> is some number, and <code class="language-plaintext highlighter-rouge">r</code> is a number less than 6. We then realize that <code class="language-plaintext highlighter-rouge">r</code> is the remainder, and we also know that <code class="language-plaintext highlighter-rouge">n % 6 == r</code>.</p>

    <p>We then realize that if we add a number, <code class="language-plaintext highlighter-rouge">m</code>, such that <code class="language-plaintext highlighter-rouge">n</code> is still not divisible by 6, and <code class="language-plaintext highlighter-rouge">r + m &lt; 6</code> then: <code class="language-plaintext highlighter-rouge">n + m = q * 6 + r + m</code>. Since <code class="language-plaintext highlighter-rouge">n + m</code> is not divisible by 6, then surely <code class="language-plaintext highlighter-rouge">r + m</code> is not divisible by 6. Likewise, for 2: <code class="language-plaintext highlighter-rouge">r + m &lt; 6</code>, then: <code class="language-plaintext highlighter-rouge">n + m = q * 6 + r + m</code>, since <code class="language-plaintext highlighter-rouge">n + m</code> is not divisible by 2, then surely <code class="language-plaintext highlighter-rouge">r + m</code> is not divisible by 2, and so on. This wouldn’t work if we try to test for divisibility by 7: <code class="language-plaintext highlighter-rouge">r + m &lt; 6</code> then: <code class="language-plaintext highlighter-rouge">n + m =/= q * 6 + r + m</code>, <code class="language-plaintext highlighter-rouge">r + m</code> not divisible by 7 (which is the case for all possible values of <code class="language-plaintext highlighter-rouge">r + m</code>, since <code class="language-plaintext highlighter-rouge">r + m</code> is within 0 to 6) does not necessarily mean <code class="language-plaintext highlighter-rouge">n + m</code> is not divisible by 7.</p>

    <p>So, what this means is that any addition that does not make the expression immediately divisible by <strong><code class="language-plaintext highlighter-rouge">6</code> is added to the remainder</strong>, and we know that the <strong>modulo of the remainder is equal to the modulo of the original number</strong>. Since <code class="language-plaintext highlighter-rouge">6</code> can be broken down into the primes <code class="language-plaintext highlighter-rouge">2</code> and <code class="language-plaintext highlighter-rouge">3</code>, which are our test prime numbers, therefore, by performing modulo on all the test prime numbers within our input, we can fully express the divisibility of our number with any one of the primes just by maintaining the remainder.</p>

    <p>Hence,</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>      <span class="n">worry</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">operation</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">item</span> <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">operand</span> <span class="o">==</span> <span class="s">'old'</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">operand</span><span class="p">))</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">17</span> <span class="o">*</span> <span class="mi">7</span> <span class="o">*</span> <span class="mi">11</span> <span class="o">*</span> <span class="mi">19</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">*</span> <span class="mi">13</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
</code></pre></div>    </div>

    <p>must work (the prime numbers are the terms I’m too lazy to evaluate).</p>

    <hr>

    <h1 id="day-12">Day 12</h1>

    <p>Today is quite obviously a path-finding challenge.</p>

    <h2 id="part-1-11">Part 1</h2>

    <p>Admittedly, I spend an embarrassing amount of time figuring out that while I can only go up by one altitude unit at a time, I can actually descend more than 1 level at a time. I decided to use Breadth First Search to perform path-finding, since it’s good enough for the use case.</p>

    <p>For every node I’ve visited, I replace it’s position with <code class="language-plaintext highlighter-rouge">#</code>, which denotes a visited node. So:</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="n">grid</span> <span class="o">=</span> <span class="p">[[</span><span class="n">y</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span><span class="p">.</span><span class="n">strip</span><span class="p">()]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="s">'input.txt'</span><span class="p">,</span> <span class="s">'r'</span><span class="p">).</span><span class="n">readlines</span><span class="p">()]</span>   
<span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">20</span><span class="p">]</span> <span class="o">=</span> <span class="s">'a'</span>
                                                                              
<span class="k">def</span> <span class="nf">bfs</span><span class="p">(</span><span class="n">pos</span><span class="p">):</span>
  <span class="n">q</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>                                                                 
  <span class="n">p</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>                                                                 
  <span class="n">q</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
  
  <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>                                                                 
    <span class="k">while</span> <span class="ow">not</span> <span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">():</span>                                                      
      <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">get</span><span class="p">()</span>                                                          
      <span class="n">elevation</span> <span class="o">=</span> <span class="s">'a'</span> <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="s">'S'</span> <span class="k">else</span> <span class="n">grid</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span>                    
      <span class="n">grid</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="s">'#'</span>                                                        
      <span class="n">moves</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>                
      
      <span class="k">if</span> <span class="n">elevation</span> <span class="o">==</span> <span class="s">'E'</span><span class="p">:</span> 
        <span class="k">return</span> <span class="n">count</span>                                                          
      
      <span class="k">for</span> <span class="n">new_x</span><span class="p">,</span> <span class="n">new_y</span> <span class="ow">in</span> <span class="n">moves</span><span class="p">:</span>                                              
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">new_x</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">new_y</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> \             
          <span class="ow">and</span> <span class="n">grid</span><span class="p">[</span><span class="n">new_y</span><span class="p">][</span><span class="n">new_x</span><span class="p">]</span> <span class="o">!=</span> <span class="s">'#'</span> \                                     
          <span class="ow">and</span> <span class="p">(</span><span class="o">-</span><span class="mi">999</span> <span class="o">&lt;=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">new_y</span><span class="p">][</span><span class="n">new_x</span><span class="p">])</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="n">elevation</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span> \        
          <span class="ow">or</span> <span class="p">(</span><span class="n">elevation</span> <span class="o">==</span> <span class="s">'z'</span> <span class="ow">and</span> <span class="n">grid</span><span class="p">[</span><span class="n">new_y</span><span class="p">][</span><span class="n">new_x</span><span class="p">]</span> <span class="o">==</span> <span class="s">'E'</span><span class="p">)):</span>               
            <span class="n">p</span><span class="p">.</span><span class="n">put</span><span class="p">((</span><span class="n">new_x</span><span class="p">,</span> <span class="n">new_y</span><span class="p">))</span>
          
    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">p</span> 
    <span class="n">p</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>                                                               
    
<span class="k">print</span><span class="p">(</span><span class="n">bfs</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">)))</span>
</code></pre></div>    </div>

    <p>It might be worth it to mention that <code class="language-plaintext highlighter-rouge">-999</code> is too large of a magnitude. <code class="language-plaintext highlighter-rouge">-2</code> would have been good enough; this means that I would be able to descend a maximum of <code class="language-plaintext highlighter-rouge">-2</code>. Experimental results for the win.</p>

    <p>Also, if you think hard-coding the starting position is hacky, then you can look away.</p>

    <h2 id="part-2-11">Part 2</h2>

    <p>Part 2 requires us to find a better starting position, so that we minimize the amount of steps it takes to reach the peak, denoted by <code class="language-plaintext highlighter-rouge">E</code>. So, I first approached the problem the dumb way, which was to iterate through all positions of <code class="language-plaintext highlighter-rouge">a</code>, the lowest altitude, and accumulate the minimum.</p>

    <p>Obviously, that was slow, so I thought about using another algorithm, like Dijkstra’s Shortest Path algorithm; however, there would be no benefit whatsoever over BFS since the weights of each nodes are the same.</p>

    <p>Hence, I decided to perform a reverse BFS; instead of checking for <code class="language-plaintext highlighter-rouge">E</code>, I check for the closest <code class="language-plaintext highlighter-rouge">a</code>, given that we can instead ascend 2 levels and descend only 1 level (inverse of our ascending constraints).</p>

    <p>So:</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">queue</span> <span class="kn">import</span> <span class="n">Queue</span>                                                       

<span class="n">grid</span> <span class="o">=</span> <span class="p">[[</span><span class="n">y</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span><span class="p">.</span><span class="n">strip</span><span class="p">()]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="s">'input.txt'</span><span class="p">,</span> <span class="s">'r'</span><span class="p">).</span><span class="n">readlines</span><span class="p">()]</span>

<span class="k">def</span> <span class="nf">bfs</span><span class="p">(</span><span class="n">pos</span><span class="p">):</span>
  <span class="n">q</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
  <span class="n">p</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span> 
  <span class="n">q</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> 
      
  <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">while</span> <span class="bp">True</span><span class="p">:</span> 
    <span class="k">while</span> <span class="ow">not</span> <span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">():</span>
      <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">get</span><span class="p">()</span>
      <span class="n">elevation</span> <span class="o">=</span> <span class="s">'z'</span> <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="s">'E'</span> <span class="k">else</span> <span class="n">grid</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span>
      <span class="n">grid</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="s">'#'</span>
      <span class="n">moves</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        
      <span class="k">if</span> <span class="n">elevation</span> <span class="o">==</span> <span class="s">'a'</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">count</span>
          
      <span class="k">for</span> <span class="n">new_x</span><span class="p">,</span> <span class="n">new_y</span> <span class="ow">in</span> <span class="n">moves</span><span class="p">:</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">new_x</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">new_y</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> \
          <span class="ow">and</span> <span class="n">grid</span><span class="p">[</span><span class="n">new_y</span><span class="p">][</span><span class="n">new_x</span><span class="p">]</span> <span class="o">!=</span> <span class="s">'#'</span> \
          <span class="ow">and</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">&lt;=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">new_y</span><span class="p">][</span><span class="n">new_x</span><span class="p">])</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="n">elevation</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span> \
          <span class="ow">or</span> <span class="p">(</span><span class="n">elevation</span> <span class="o">==</span> <span class="s">'a'</span> <span class="ow">and</span> <span class="n">grid</span><span class="p">[</span><span class="n">new_y</span><span class="p">][</span><span class="n">new_x</span><span class="p">]</span> <span class="o">==</span> <span class="s">'S'</span><span class="p">)):</span>
            <span class="n">p</span><span class="p">.</span><span class="n">put</span><span class="p">((</span><span class="n">new_x</span><span class="p">,</span> <span class="n">new_y</span><span class="p">))</span>
    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">p</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>

<span class="k">print</span><span class="p">(</span><span class="n">bfs</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">20</span><span class="p">)))</span>
</code></pre></div>    </div>

    <hr>

    <h1 id="day-13">Day 13</h1>

    <p>Nothing like spending 5 hours on Advent of Code, eh?</p>

    <p>Felt a little down, so I decided to use good old C to do this. Little did I know, that was going to be a huge ordeal.</p>

    <h2 id="part-1-12">Part 1</h2>

    <p>This part was essentially about parsing. I may be able to summarize what I’ve essentially did here, but the process to get there is error-prone; I had to painstakingly debug the corner cases that occurred during my parsing.</p>

    <p>In hindsight, it might have been a better idea to list all the possible corner cases before attempting the problem.</p>

    <p>The input we are to parse can come in the following format:</p>

    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>[[[[3],[]],5],[[],[7,[3,3,3],2,[1],[6,7,9]],[],8,1],[9,[0,0,[5,3,5,1],[2],2],3],[2,[0,4]]]
[[[]],[[[],10,[8,0,5,5],[5,4,8,10,1],[6,8,0,3,5]],2,[9,[5],[9,2],[]],[8,[]]]]
</code></pre></div>    </div>

    <p>Defining the first list as ‘a’, and the second list as ‘b’, if:</p>

    <ul>
      <li>We are comparing two lists, then we compare elements in the two lists
        <ul>
          <li>If list ‘a’ terminates early (less elements than ‘b’), then the two lists are in order</li>
          <li>If list ‘b’ terminates early (less elements than ‘a’), then the two lists are not in order</li>
        </ul>
      </li>
      <li>We are comparing two values, then we just take the integers and directly compare them</li>
      <li>We are comparing a list and a value, in which we re-package the value as a singleton list, and attempt to compare them again.</li>
    </ul>

    <p>Sounds easy, but it was actually much more difficult than I imagined. I converted each comparison method above into their own function, and wrapped all three functions around a main function called “think” that decides which comparison method to choose based on the current tokens. I then confirmed that the list pairs are either greater, or less than one another. Hence, I was able to discard all thoughts related to equality.</p>

    <p>Now, time to think about each case step by step, which I only thought was a good idea in hindsight. Let’s say the current character in ‘a’ and ‘b’ are ‘x’ and ‘y’:</p>

    <ol>
      <li>If ‘x’ and ‘y’ are ‘[’ then we use the list comparison method</li>
      <li>If ‘x’ and ‘y’ does not have any list-related symbols (‘[’ and ‘]’), then we use the value comparison method</li>
      <li>Else:
        <ol>
          <li>If ‘x’ denotes the end of the list and ‘y’ is a value, we compare the number of lists open in ‘a’ and ‘b’ at the moment, and return 1 or -1 if they are not the same. Otherwise, we get the successor of x, and start from step 1 again. This allows us to reach a point where we can compare two values, or return early if the list sizes assert that they’re unequal.</li>
          <li>If ‘x’ is a value and ‘y’ denotes the end of the list, we compare the number of lists open in ‘a’ and ‘b’ at the moment, and return 1 or -1 if they are not the same value. Otherwise, we get the successor of y, and start from step 1 again.</li>
          <li>If both ‘x’ and ‘y’ denotes the end of the list, we compare the number of lists open in ‘a’ and ‘b’ just in case, and gets the successor of both ‘x’ and ‘y’, repeating step 1.</li>
        </ol>
      </li>
      <li>Else, if we can tell that ‘x’ is a value while ‘y’ is a list, we use the re-packaging comparison method</li>
      <li>Else, if we can tell that ‘x’ is a list while ‘y’ is a value, we use the re-packaging comparison method, but we negate the value we acquire from the method.</li>
    </ol>

    <p>Embarrasingly enough, it took me a long time to figure out that two digit numbers exist within our problem-space; I’ve been comparing ASCII for a few hours not knowing why my solution didn’t work.</p>

    <p>With the steps described above, it becomes possible to define a recursive function that steps through the list, building kinda like a syntax tree on the stack:</p>

    <div class="language-c highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">comparevaluethenlist</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">l_levels</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">r_levels</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">comparevalue</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">l_levels</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">r_levels</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">comparelist</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">l_levels</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">r_levels</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">think</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">l_levels</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">r_levels</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">comparevaluethenlist</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">l_levels</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">r_levels</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">think</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">l_levels</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r_levels</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">think</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">l_levels</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">r_levels</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">a</span> <span class="o">==</span> <span class="sc">'['</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">b</span> <span class="o">==</span> <span class="sc">'['</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">comparelist</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">l_levels</span><span class="p">,</span> <span class="n">r_levels</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">res</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">a</span> <span class="o">!=</span> <span class="sc">'['</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">a</span> <span class="o">!=</span> <span class="sc">']'</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">b</span> <span class="o">!=</span> <span class="sc">'['</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">b</span> <span class="o">!=</span> <span class="sc">']'</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">comparevalue</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">l_levels</span><span class="p">,</span> <span class="n">r_levels</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">a</span> <span class="o">==</span> <span class="sc">']'</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">b</span> <span class="o">!=</span> <span class="sc">']'</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">l_levels</span><span class="o">--</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">l_levels</span> <span class="o">&lt;</span> <span class="n">r_levels</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">l_levels</span> <span class="o">&gt;</span> <span class="n">r_levels</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

    <span class="n">a</span><span class="o">++</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">a</span> <span class="o">==</span> <span class="sc">','</span><span class="p">)</span> <span class="n">a</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">think</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">l_levels</span><span class="p">,</span> <span class="n">r_levels</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">a</span> <span class="o">!=</span> <span class="sc">']'</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">b</span> <span class="o">==</span> <span class="sc">']'</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">r_levels</span><span class="o">--</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">l_levels</span> <span class="o">&lt;</span> <span class="n">r_levels</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">l_levels</span> <span class="o">&gt;</span> <span class="n">r_levels</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

    <span class="n">b</span><span class="o">++</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">b</span> <span class="o">==</span> <span class="sc">','</span><span class="p">)</span> <span class="n">b</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">think</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">l_levels</span><span class="p">,</span> <span class="n">r_levels</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">a</span> <span class="o">==</span> <span class="sc">']'</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">b</span> <span class="o">==</span> <span class="sc">']'</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">l_levels</span><span class="o">--</span><span class="p">;</span>
    <span class="n">r_levels</span><span class="o">--</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">l_levels</span> <span class="o">&lt;</span> <span class="n">r_levels</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">l_levels</span> <span class="o">&gt;</span> <span class="n">r_levels</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

    <span class="n">a</span><span class="o">++</span><span class="p">;</span>
    <span class="n">b</span><span class="o">++</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">a</span> <span class="o">==</span> <span class="sc">','</span><span class="p">)</span> <span class="n">a</span><span class="o">++</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">b</span> <span class="o">==</span> <span class="sc">','</span><span class="p">)</span> <span class="n">b</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">think</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">l_levels</span><span class="p">,</span> <span class="n">r_levels</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">a</span> <span class="o">!=</span> <span class="sc">'['</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">a</span> <span class="o">!=</span> <span class="sc">']'</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">comparevaluethenlist</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">l_levels</span><span class="p">,</span> <span class="n">r_levels</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">b</span> <span class="o">!=</span> <span class="sc">'['</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">b</span> <span class="o">!=</span> <span class="sc">']'</span><span class="p">)</span>
      <span class="k">return</span> <span class="o">-</span><span class="n">comparevaluethenlist</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">r_levels</span><span class="p">,</span> <span class="n">l_levels</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">comparevalue</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">l_levels</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">r_levels</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>

  <span class="kt">char</span> <span class="n">numBufA</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
  <span class="kt">char</span> <span class="n">numBufB</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">tokA_com</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="sc">','</span><span class="p">),</span> <span class="o">*</span><span class="n">tokA_brac</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="sc">']'</span><span class="p">),</span> 
    <span class="o">*</span><span class="n">tokB_com</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="sc">','</span><span class="p">),</span> <span class="o">*</span><span class="n">tokB_brac</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="sc">']'</span><span class="p">);</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">tokA</span> <span class="o">=</span> <span class="p">(</span><span class="n">tokA_com</span> <span class="o">&lt;</span> <span class="n">tokA_brac</span> <span class="o">&amp;&amp;</span> <span class="n">tokA_com</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">?</span> <span class="n">tokA_com</span> <span class="o">:</span> <span class="n">tokA_brac</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">tokB</span> <span class="o">=</span> <span class="p">(</span><span class="n">tokB_com</span> <span class="o">&lt;</span> <span class="n">tokB_brac</span> <span class="o">&amp;&amp;</span> <span class="n">tokB_com</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">?</span> <span class="n">tokB_com</span> <span class="o">:</span> <span class="n">tokB_brac</span><span class="p">;</span>
  <span class="n">strncpy</span><span class="p">(</span><span class="n">numBufA</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">tokA</span> <span class="o">-</span> <span class="n">a</span><span class="p">);</span>
  <span class="n">numBufA</span><span class="p">[</span><span class="n">tokA</span> <span class="o">-</span> <span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>

  <span class="n">strncpy</span><span class="p">(</span><span class="n">numBufB</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">tokB</span> <span class="o">-</span> <span class="n">b</span><span class="p">);</span>
  <span class="n">numBufB</span><span class="p">[</span><span class="n">tokB</span> <span class="o">-</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">a_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">a_i</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">numBufA</span><span class="p">);</span>
  <span class="n">b_i</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">numBufB</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">a_i</span> <span class="o">&gt;</span> <span class="n">b_i</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a_i</span> <span class="o">&lt;</span> <span class="n">b_i</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">+=</span> <span class="n">tokA</span> <span class="o">-</span> <span class="n">a</span><span class="p">;</span>
  <span class="n">b</span> <span class="o">+=</span> <span class="n">tokB</span> <span class="o">-</span> <span class="n">b</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">b</span> <span class="o">==</span> <span class="sc">','</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">b</span> <span class="o">!=</span> <span class="sc">','</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">a</span> <span class="o">==</span> <span class="sc">','</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">a</span> <span class="o">==</span> <span class="sc">','</span><span class="p">)</span> <span class="n">a</span><span class="o">++</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">b</span> <span class="o">==</span> <span class="sc">','</span><span class="p">)</span> <span class="n">b</span><span class="o">++</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">think</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">l_levels</span><span class="p">,</span> <span class="n">r_levels</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">comparelist</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">l_levels</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">r_levels</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">l_levels</span><span class="o">++</span><span class="p">;</span>
  <span class="n">r_levels</span><span class="o">++</span><span class="p">;</span>
  <span class="n">a</span><span class="o">++</span><span class="p">;</span> <span class="n">b</span><span class="o">++</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">a</span> <span class="o">==</span> <span class="sc">','</span><span class="p">)</span> <span class="n">a</span><span class="o">++</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">b</span> <span class="o">==</span> <span class="sc">','</span><span class="p">)</span> <span class="n">b</span><span class="o">++</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">think</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">l_levels</span><span class="p">,</span> <span class="n">r_levels</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">parse</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">line1</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">line2</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">comparelist</span><span class="p">(</span><span class="n">line1</span><span class="p">,</span> <span class="n">line2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">accum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;;</span>
  <span class="kt">char</span> <span class="n">line1</span><span class="p">[</span><span class="mi">1000</span><span class="p">],</span> <span class="n">line2</span><span class="p">[</span><span class="mi">1000</span><span class="p">];</span>
  <span class="kt">FILE</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"input.txt"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span>
  <span class="k">do</span> <span class="p">{</span>
    <span class="n">count</span><span class="o">++</span><span class="p">;</span>
    <span class="n">fscanf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">line1</span><span class="p">);</span>
    <span class="n">fscanf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">line2</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">parse</span><span class="p">(</span><span class="n">line1</span><span class="p">,</span> <span class="n">line2</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">accum</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">feof</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
  <span class="n">fclose</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"Result: %ld</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">accum</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <p>After some hours of debugging, I also had to introduce <code class="language-plaintext highlighter-rouge">c</code> to maintain information that we are currently within a list that has been <em>upgraded</em> from a value for the sake of comparison, so that we can return early upon encountering a <code class="language-plaintext highlighter-rouge">,</code>. This has by far the most corner cases in this problem.</p>

    <h2 id="part-2-12">Part 2</h2>

    <p>Part 2 repurposes the <code class="language-plaintext highlighter-rouge">think</code> function into a binary comparison function. Luckily, I have already defined <code class="language-plaintext highlighter-rouge">think</code> to return values required by the <code class="language-plaintext highlighter-rouge">qsort</code> standard library function, so I simply used that, and appended <code class="language-plaintext highlighter-rouge">[[2]]</code> and <code class="language-plaintext highlighter-rouge">[[6]]</code> into the <code class="language-plaintext highlighter-rouge">input.txt</code> file, and multiplied their indices after sorting to acquire the final solution:</p>

    <div class="language-c highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">comparevaluethenlist</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">l_levels</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">r_levels</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">comparevalue</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">l_levels</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">r_levels</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">comparelist</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">l_levels</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">r_levels</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">think</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">l_levels</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">r_levels</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">comparevaluethenlist</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">l_levels</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">r_levels</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">think</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">l_levels</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r_levels</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">think</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">l_levels</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">r_levels</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">a</span> <span class="o">==</span> <span class="sc">'['</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">b</span> <span class="o">==</span> <span class="sc">'['</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">comparelist</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">l_levels</span><span class="p">,</span> <span class="n">r_levels</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">res</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">a</span> <span class="o">!=</span> <span class="sc">'['</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">a</span> <span class="o">!=</span> <span class="sc">']'</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">b</span> <span class="o">!=</span> <span class="sc">'['</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">b</span> <span class="o">!=</span> <span class="sc">']'</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">comparevalue</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">l_levels</span><span class="p">,</span> <span class="n">r_levels</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">a</span> <span class="o">==</span> <span class="sc">']'</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">b</span> <span class="o">!=</span> <span class="sc">']'</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">l_levels</span><span class="o">--</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">l_levels</span> <span class="o">&lt;</span> <span class="n">r_levels</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">l_levels</span> <span class="o">&gt;</span> <span class="n">r_levels</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

    <span class="n">a</span><span class="o">++</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">a</span> <span class="o">==</span> <span class="sc">','</span><span class="p">)</span> <span class="n">a</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">think</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">l_levels</span><span class="p">,</span> <span class="n">r_levels</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">a</span> <span class="o">!=</span> <span class="sc">']'</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">b</span> <span class="o">==</span> <span class="sc">']'</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">r_levels</span><span class="o">--</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">l_levels</span> <span class="o">&lt;</span> <span class="n">r_levels</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">l_levels</span> <span class="o">&gt;</span> <span class="n">r_levels</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

    <span class="n">b</span><span class="o">++</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">b</span> <span class="o">==</span> <span class="sc">','</span><span class="p">)</span> <span class="n">b</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">think</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">l_levels</span><span class="p">,</span> <span class="n">r_levels</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">a</span> <span class="o">==</span> <span class="sc">']'</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">b</span> <span class="o">==</span> <span class="sc">']'</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">l_levels</span><span class="o">--</span><span class="p">;</span>
    <span class="n">r_levels</span><span class="o">--</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">l_levels</span> <span class="o">&lt;</span> <span class="n">r_levels</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">l_levels</span> <span class="o">&gt;</span> <span class="n">r_levels</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

    <span class="n">a</span><span class="o">++</span><span class="p">;</span>
    <span class="n">b</span><span class="o">++</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">a</span> <span class="o">==</span> <span class="sc">','</span><span class="p">)</span> <span class="n">a</span><span class="o">++</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">b</span> <span class="o">==</span> <span class="sc">','</span><span class="p">)</span> <span class="n">b</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">think</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">l_levels</span><span class="p">,</span> <span class="n">r_levels</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">a</span> <span class="o">!=</span> <span class="sc">'['</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">a</span> <span class="o">!=</span> <span class="sc">']'</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">comparevaluethenlist</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">l_levels</span><span class="p">,</span> <span class="n">r_levels</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">b</span> <span class="o">!=</span> <span class="sc">'['</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">b</span> <span class="o">!=</span> <span class="sc">']'</span><span class="p">)</span>
      <span class="k">return</span> <span class="o">-</span><span class="n">comparevaluethenlist</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">r_levels</span><span class="p">,</span> <span class="n">l_levels</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">comparevalue</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">l_levels</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">r_levels</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">numBufA</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
  <span class="kt">char</span> <span class="n">numBufB</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">tokA_com</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="sc">','</span><span class="p">),</span> <span class="o">*</span><span class="n">tokA_brac</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="sc">']'</span><span class="p">),</span> 
    <span class="o">*</span><span class="n">tokB_com</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="sc">','</span><span class="p">),</span> <span class="o">*</span><span class="n">tokB_brac</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="sc">']'</span><span class="p">);</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">tokA</span> <span class="o">=</span> <span class="p">(</span><span class="n">tokA_com</span> <span class="o">&lt;</span> <span class="n">tokA_brac</span> <span class="o">&amp;&amp;</span> <span class="n">tokA_com</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">?</span> <span class="n">tokA_com</span> <span class="o">:</span> <span class="n">tokA_brac</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">tokB</span> <span class="o">=</span> <span class="p">(</span><span class="n">tokB_com</span> <span class="o">&lt;</span> <span class="n">tokB_brac</span> <span class="o">&amp;&amp;</span> <span class="n">tokB_com</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">?</span> <span class="n">tokB_com</span> <span class="o">:</span> <span class="n">tokB_brac</span><span class="p">;</span>
  <span class="n">strncpy</span><span class="p">(</span><span class="n">numBufA</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">tokA</span> <span class="o">-</span> <span class="n">a</span><span class="p">);</span>
  <span class="n">numBufA</span><span class="p">[</span><span class="n">tokA</span> <span class="o">-</span> <span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>

  <span class="n">strncpy</span><span class="p">(</span><span class="n">numBufB</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">tokB</span> <span class="o">-</span> <span class="n">b</span><span class="p">);</span>
  <span class="n">numBufB</span><span class="p">[</span><span class="n">tokB</span> <span class="o">-</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">a_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">a_i</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">numBufA</span><span class="p">);</span>
  <span class="n">b_i</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">numBufB</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">a_i</span> <span class="o">&gt;</span> <span class="n">b_i</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a_i</span> <span class="o">&lt;</span> <span class="n">b_i</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">+=</span> <span class="n">tokA</span> <span class="o">-</span> <span class="n">a</span><span class="p">;</span>
  <span class="n">b</span> <span class="o">+=</span> <span class="n">tokB</span> <span class="o">-</span> <span class="n">b</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">b</span> <span class="o">==</span> <span class="sc">','</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">b</span> <span class="o">!=</span> <span class="sc">','</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">a</span> <span class="o">==</span> <span class="sc">','</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">a</span> <span class="o">==</span> <span class="sc">','</span><span class="p">)</span> <span class="n">a</span><span class="o">++</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">b</span> <span class="o">==</span> <span class="sc">','</span><span class="p">)</span> <span class="n">b</span><span class="o">++</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">think</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">l_levels</span><span class="p">,</span> <span class="n">r_levels</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">comparelist</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">l_levels</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">r_levels</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">l_levels</span><span class="o">++</span><span class="p">;</span>
  <span class="n">r_levels</span><span class="o">++</span><span class="p">;</span>
  <span class="n">a</span><span class="o">++</span><span class="p">;</span> <span class="n">b</span><span class="o">++</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">a</span> <span class="o">==</span> <span class="sc">','</span><span class="p">)</span> <span class="n">a</span><span class="o">++</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">b</span> <span class="o">==</span> <span class="sc">','</span><span class="p">)</span> <span class="n">b</span><span class="o">++</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">think</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">l_levels</span><span class="p">,</span> <span class="n">r_levels</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">comparison</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">line1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">line2</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">comparelist</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">line1</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">line2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">lines</span><span class="p">[</span><span class="mi">1000</span><span class="p">][</span><span class="mi">1000</span><span class="p">];</span>
  <span class="kt">FILE</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"input.txt"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span>
  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">feof</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
    <span class="n">fscanf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">lines</span><span class="p">[</span><span class="n">count</span><span class="o">++</span><span class="p">]);</span>
  <span class="n">fclose</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>

  <span class="n">qsort</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="mi">1000</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">),</span> <span class="n">comparison</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s">"[[2]]"</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s">"[[6]]"</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="n">result</span> <span class="o">*=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"Result: %ld</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <hr>

    <h1 id="day-14">Day 14</h1>

    <p>Bury me in sand, please.</p>

    <h2 id="part-1-13">Part 1</h2>

    <p>Today’s problem involved the following sub-problems:</p>

    <ol>
      <li>Drawing lines on a grid;</li>
      <li>Simulating the behaviour of sand particles, where:
        <ol>
          <li>If it can go down, it goes down</li>
          <li>If it can’t go down, but can go bottom left, do that</li>
          <li>If it can’t go down, but can go bottom right, do that</li>
          <li>If it can’t go anywhere, settle the sand and move on to the next sand</li>
        </ol>
      </li>
    </ol>

    <p>What about the size of the grid? Well, since our input is fixed, we really don’t have to figure that out; just guess a large enough size, I’m sure that won’t come back to bite me in the future <img class="emoji" title=":new_moon_with_face:" alt=":new_moon_with_face:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f31a.png" height="20" width="20">. The first sub-problem was easily solved like so:</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="n">grid</span> <span class="o">=</span> <span class="p">[[</span><span class="s">'.'</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">600</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">200</span><span class="p">)]</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'input.txt'</span><span class="p">,</span> <span class="s">'r'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
  <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">readline</span><span class="p">()</span>
  <span class="k">while</span> <span class="n">line</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">line</span><span class="p">:</span>
      <span class="n">xys</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">x</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">','</span><span class="p">)))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">line</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="s">'-&gt;'</span><span class="p">]</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xys</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">xys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">xys</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">while</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
          <span class="n">grid</span><span class="p">[</span><span class="n">y1</span><span class="p">][</span><span class="n">x1</span><span class="p">]</span> <span class="o">=</span> <span class="s">'#'</span>
          <span class="n">x1</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">x1</span> <span class="o">&gt;</span> <span class="n">x2</span> <span class="k">else</span> <span class="mi">1</span>

        <span class="k">while</span> <span class="nb">abs</span><span class="p">(</span><span class="n">y1</span> <span class="o">-</span> <span class="n">y2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
          <span class="n">grid</span><span class="p">[</span><span class="n">y1</span><span class="p">][</span><span class="n">x1</span><span class="p">]</span> <span class="o">=</span> <span class="s">'#'</span>
          <span class="n">y1</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">y1</span> <span class="o">&gt;</span> <span class="n">y2</span> <span class="k">else</span> <span class="mi">1</span>
      
        <span class="n">grid</span><span class="p">[</span><span class="n">y1</span><span class="p">][</span><span class="n">x1</span><span class="p">]</span> <span class="o">=</span> <span class="s">'#'</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">readline</span><span class="p">()</span>
</code></pre></div>    </div>

    <p>The input looks like this:</p>

    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>498,4 -&gt; 498,6 -&gt; 496,6
503,4 -&gt; 502,4 -&gt; 502,9 -&gt; 494,9
</code></pre></div>    </div>

    <p>So, when parsing each line, we need to strip spaces, filter out <code class="language-plaintext highlighter-rouge">-&gt;</code>, and split the resultant string by <code class="language-plaintext highlighter-rouge">,</code>. We also want to convert each list of strings into a tuple of integers, so we also do that in the same line.</p>

    <p>For each adjacent <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code>, we attempt to draw the walls that will affect sand interactions.</p>

    <p>To solve the next sub-problem, we convert the behavior in to a bunch of if statements, and keep looping until one grain of sand enters the void, defined by anything falling out of <code class="language-plaintext highlighter-rouge">y = 200</code>:</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="n">voided</span> <span class="o">=</span> <span class="bp">False</span>
<span class="n">settled_grains</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="ow">not</span> <span class="n">voided</span><span class="p">:</span>
  <span class="n">grain_x</span><span class="p">,</span> <span class="n">grain_y</span> <span class="o">=</span> <span class="p">(</span><span class="mi">500</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">is_occupied</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">==</span> <span class="s">'#'</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">==</span> <span class="s">'+'</span>
  <span class="n">settled</span> <span class="o">=</span> <span class="bp">False</span>
  <span class="k">while</span> <span class="ow">not</span> <span class="n">settled</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">grain_y</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">200</span><span class="p">:</span>
      <span class="n">voided</span> <span class="o">=</span> <span class="bp">True</span>
      <span class="k">break</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">is_occupied</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">grain_y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">grain_x</span><span class="p">]):</span>
      <span class="n">grain_y</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">grain_x</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_occupied</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">grain_y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">grain_x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]):</span>
      <span class="n">grain_x</span> <span class="o">-=</span> <span class="mi">1</span>
      <span class="n">grain_y</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">grain_x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="mi">600</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_occupied</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">grain_y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">grain_x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]):</span>
      <span class="n">grain_x</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="n">grain_y</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">settled</span> <span class="o">=</span> <span class="bp">True</span>
      <span class="n">grid</span><span class="p">[</span><span class="n">grain_y</span><span class="p">][</span><span class="n">grain_x</span><span class="p">]</span> <span class="o">=</span> <span class="s">'+'</span>

  <span class="k">if</span> <span class="ow">not</span> <span class="n">voided</span><span class="p">:</span>
    <span class="n">settled_grains</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></div>    </div>

    <p>Piecing it all together:</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="n">grid</span> <span class="o">=</span> <span class="p">[[</span><span class="s">'.'</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">600</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">200</span><span class="p">)]</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'input.txt'</span><span class="p">,</span> <span class="s">'r'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
  <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">readline</span><span class="p">()</span>
  <span class="k">while</span> <span class="n">line</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">line</span><span class="p">:</span>
      <span class="n">xys</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">x</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">','</span><span class="p">)))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">line</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="s">'-&gt;'</span><span class="p">]</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xys</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">xys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">xys</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">while</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
          <span class="n">grid</span><span class="p">[</span><span class="n">y1</span><span class="p">][</span><span class="n">x1</span><span class="p">]</span> <span class="o">=</span> <span class="s">'#'</span>
          <span class="n">x1</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">x1</span> <span class="o">&gt;</span> <span class="n">x2</span> <span class="k">else</span> <span class="mi">1</span>

        <span class="k">while</span> <span class="nb">abs</span><span class="p">(</span><span class="n">y1</span> <span class="o">-</span> <span class="n">y2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
          <span class="n">grid</span><span class="p">[</span><span class="n">y1</span><span class="p">][</span><span class="n">x1</span><span class="p">]</span> <span class="o">=</span> <span class="s">'#'</span>
          <span class="n">y1</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">y1</span> <span class="o">&gt;</span> <span class="n">y2</span> <span class="k">else</span> <span class="mi">1</span>

        <span class="n">grid</span><span class="p">[</span><span class="n">y1</span><span class="p">][</span><span class="n">x1</span><span class="p">]</span> <span class="o">=</span> <span class="s">'#'</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">readline</span><span class="p">()</span>

<span class="n">voided</span> <span class="o">=</span> <span class="bp">False</span>
<span class="n">settled_grains</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="ow">not</span> <span class="n">voided</span><span class="p">:</span>
  <span class="n">grain_x</span><span class="p">,</span> <span class="n">grain_y</span> <span class="o">=</span> <span class="p">(</span><span class="mi">500</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">is_occupied</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">==</span> <span class="s">'#'</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">==</span> <span class="s">'+'</span>
  <span class="n">settled</span> <span class="o">=</span> <span class="bp">False</span>
  <span class="k">while</span> <span class="ow">not</span> <span class="n">settled</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">grain_y</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">200</span><span class="p">:</span>
      <span class="n">voided</span> <span class="o">=</span> <span class="bp">True</span>
      <span class="k">break</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">is_occupied</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">grain_y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">grain_x</span><span class="p">]):</span>
      <span class="n">grain_y</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">grain_x</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_occupied</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">grain_y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">grain_x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]):</span>
      <span class="n">grain_x</span> <span class="o">-=</span> <span class="mi">1</span>
      <span class="n">grain_y</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">grain_x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="mi">600</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_occupied</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">grain_y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">grain_x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]):</span>
      <span class="n">grain_x</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="n">grain_y</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">settled</span> <span class="o">=</span> <span class="bp">True</span>
      <span class="n">grid</span><span class="p">[</span><span class="n">grain_y</span><span class="p">][</span><span class="n">grain_x</span><span class="p">]</span> <span class="o">=</span> <span class="s">'+'</span>

  <span class="k">if</span> <span class="ow">not</span> <span class="n">voided</span><span class="p">:</span>
    <span class="n">settled_grains</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="k">print</span><span class="p">(</span><span class="n">settled_grains</span><span class="p">)</span>
</code></pre></div>    </div>

    <h2 id="part-2-13">Part 2</h2>

    <p>In this part, we realize that the void doesn’t exist (damn it, there goes one option). Instead, there is an infinite floor at <code class="language-plaintext highlighter-rouge">max_y + 2</code>, where <code class="language-plaintext highlighter-rouge">max_y</code> is the largest <code class="language-plaintext highlighter-rouge">y</code> found while parsing the lines.</p>

    <p>Luckily for me, that was simple to do; we just store the maximum <code class="language-plaintext highlighter-rouge">y</code> every time we see one:</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>        <span class="n">highest_y</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">highest_y</span><span class="p">)</span>
</code></pre></div>    </div>

    <p>Then, after reading the entire input, we just fill that <code class="language-plaintext highlighter-rouge">y</code> with the floor symbol:</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="n">grid</span><span class="p">[</span><span class="n">highest_y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s">'#'</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">600</span><span class="p">)]</span>
</code></pre></div>    </div>

    <p>Next, our stop condition has changed to sand particles settling at <code class="language-plaintext highlighter-rouge">(500, 0)</code>, meaning that the generator of sand particles will subsequently be blocked.</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>    <span class="k">else</span><span class="p">:</span>
      <span class="n">settled</span> <span class="o">=</span> <span class="bp">True</span>
      <span class="n">grid</span><span class="p">[</span><span class="n">grain_y</span><span class="p">][</span><span class="n">grain_x</span><span class="p">]</span> <span class="o">=</span> <span class="s">'o'</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">grain_x</span><span class="p">,</span> <span class="n">grain_y</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">500</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">settled_grains</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">break</span>
</code></pre></div>    </div>

    <p>However, all these changes weren’t enough, as I was greeted by the “wrong answer” prompt on AOC. Turns out, due to the floor, the sand particles tend to create large pyramids. This means that there is a large base, which can’t fit into our grid. Incidentally, I decided to re-assign settled grains as <code class="language-plaintext highlighter-rouge">'o'</code>, to differentiate between falling grains and settled grains.</p>

    <p>Luckily, since we know our sand particles are generated from <code class="language-plaintext highlighter-rouge">(500, 0)</code>, we know for sure that the maximum <code class="language-plaintext highlighter-rouge">x</code> is somewhere around <code class="language-plaintext highlighter-rouge">750</code> due to how equilateral triangles work. To be safe, we increase the grid size all the way to <code class="language-plaintext highlighter-rouge">1000</code>. So, the final code looks like this.</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="n">grid</span> <span class="o">=</span> <span class="p">[[</span><span class="s">'.'</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">200</span><span class="p">)]</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'input.txt'</span><span class="p">,</span> <span class="s">'r'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
  <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">readline</span><span class="p">()</span>
  <span class="n">highest_y</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">while</span> <span class="n">line</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">line</span><span class="p">:</span>
      <span class="n">xys</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">x</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">','</span><span class="p">)))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">line</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="s">'-&gt;'</span><span class="p">]</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xys</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">xys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">xys</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">highest_y</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">highest_y</span><span class="p">)</span>
        <span class="k">while</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
          <span class="n">grid</span><span class="p">[</span><span class="n">y1</span><span class="p">][</span><span class="n">x1</span><span class="p">]</span> <span class="o">=</span> <span class="s">'#'</span>
          <span class="n">x1</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">x1</span> <span class="o">&gt;</span> <span class="n">x2</span> <span class="k">else</span> <span class="mi">1</span>

        <span class="k">while</span> <span class="nb">abs</span><span class="p">(</span><span class="n">y1</span> <span class="o">-</span> <span class="n">y2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
          <span class="n">grid</span><span class="p">[</span><span class="n">y1</span><span class="p">][</span><span class="n">x1</span><span class="p">]</span> <span class="o">=</span> <span class="s">'#'</span>
          <span class="n">y1</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">y1</span> <span class="o">&gt;</span> <span class="n">y2</span> <span class="k">else</span> <span class="mi">1</span>

        <span class="n">grid</span><span class="p">[</span><span class="n">y1</span><span class="p">][</span><span class="n">x1</span><span class="p">]</span> <span class="o">=</span> <span class="s">'#'</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">readline</span><span class="p">()</span>
<span class="n">grid</span><span class="p">[</span><span class="n">highest_y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s">'#'</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">)]</span>

<span class="n">stop</span> <span class="o">=</span> <span class="bp">False</span>
<span class="n">settled_grains</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="ow">not</span> <span class="n">stop</span><span class="p">:</span>
  <span class="n">grain_x</span><span class="p">,</span> <span class="n">grain_y</span> <span class="o">=</span> <span class="p">(</span><span class="mi">500</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">is_occupied</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">==</span> <span class="s">'#'</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">==</span> <span class="s">'o'</span>
  <span class="n">settled</span> <span class="o">=</span> <span class="bp">False</span>
  <span class="k">while</span> <span class="ow">not</span> <span class="n">settled</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">grain_y</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">200</span><span class="p">:</span>
      <span class="n">stop</span> <span class="o">=</span> <span class="bp">True</span>
      <span class="k">break</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">is_occupied</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">grain_y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">grain_x</span><span class="p">]):</span>
      <span class="n">grain_y</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">grain_x</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_occupied</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">grain_y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">grain_x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]):</span>
      <span class="n">grain_x</span> <span class="o">-=</span> <span class="mi">1</span>
      <span class="n">grain_y</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">grain_x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="mi">1000</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_occupied</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">grain_y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">grain_x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]):</span> <span class="c1">#and not is_occupied(grid[grain_y][grain_x + 1]):
</span>      <span class="n">grain_x</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="n">grain_y</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">settled</span> <span class="o">=</span> <span class="bp">True</span>
      <span class="n">grid</span><span class="p">[</span><span class="n">grain_y</span><span class="p">][</span><span class="n">grain_x</span><span class="p">]</span> <span class="o">=</span> <span class="s">'o'</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">grain_x</span><span class="p">,</span> <span class="n">grain_y</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">500</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">settled_grains</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">break</span>

  <span class="k">if</span> <span class="ow">not</span> <span class="n">stop</span><span class="p">:</span>
    <span class="n">settled_grains</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="k">print</span><span class="p">(</span><span class="n">settled_grains</span><span class="p">)</span>
</code></pre></div>    </div>

    <hr>

    <h1 id="day-15">Day 15</h1>

    <p>Today was an excellent lesson in how time &amp; space can grow into sizes that would be noticeable.</p>

    <h2 id="part-1-14">Part 1</h2>

    <p>In pure logical terms, there are two entities in question: the sensor, and the beacon. Both of these entities have a position, and can be mapped with the relation: <code class="language-plaintext highlighter-rouge">sensor -&gt; beacon</code>.</p>

    <p>The problem constraints that the position are integers, and each relation <code class="language-plaintext highlighter-rouge">sensor -&gt; beacon</code> represents the sensor to its closest beacon in Manhattan distance.</p>

    <blockquote>
      <p>Manhattan distance is the distance in the x-axis + the distance in the y-axis, which is different from typical distance that is typically the hypotenuse of x and y.</p>
    </blockquote>

    <p>With the constraints out of the way, behold the question: get the number of positions that is not within the Manhattan distance of any <code class="language-plaintext highlighter-rouge">sensor -&gt; beacon</code> relation. The position is constraint by y, so we essentially get a row of positions that fulfils the condition.</p>

    <p>At first, I thought about performing a BFS on every source, and then marking visited nodes. Then, I just count the number of unmarked nodes, and we’d be done. Of course, this works, but subsequently, the puzzle input looks like this:</p>

    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>Sensor at x=2832148, y=322979: closest beacon is at x=3015667, y=-141020
Sensor at x=1449180, y=3883502: closest beacon is at x=2656952, y=4188971
</code></pre></div>    </div>

    <p>which I interpreted as “aw crap, I’d need like a hundred gigabytes of memory to store a grid that size”. Instead, let’s approach the problem from another angle: we take the possible positions, which is defined by the minimum <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> seen in the input minus the largest distance we know, to the maximum <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> plus the largest distance. Luckily for us, since <code class="language-plaintext highlighter-rouge">y</code> is constrained to a single row, we only need to process one row, and <code class="language-plaintext highlighter-rouge">x</code> columns.</p>

    <p>Then, calculate the Manhattan distance from the possible positions to every sensor, and check if they are less than the distance within the <code class="language-plaintext highlighter-rouge">sensor -&gt; beacon</code> relation. If they are, then those positions are considered visited; otherwise, those positions are unvisited. Finally, just count the number of unvisited positions, as required of us.</p>

    <p>The above text is summarized as:</p>

    <ol>
      <li>Parse input</li>
      <li>For each unvisited position, for each sensor, check if distance from sensor to position is less than relation distance</li>
      <li>If all distances are more than relation distance, count it as unvisited</li>
      <li>Repeat 2 until all possible positions have been tested</li>
      <li>Return number of unvisited position</li>
    </ol>

    <p>Code:</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="n">min_x</span><span class="p">,</span> <span class="n">min_y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
<span class="n">max_x</span><span class="p">,</span> <span class="n">max_y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
<span class="n">max_dist</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">coordinate_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">beacons</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'input.txt'</span><span class="p">,</span> <span class="s">'r'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
  <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">readline</span><span class="p">()</span>
  <span class="k">while</span> <span class="n">line</span><span class="p">:</span>
    <span class="n">tokens</span> <span class="o">=</span> <span class="n">line</span><span class="p">.</span><span class="n">strip</span><span class="p">().</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)</span>
    <span class="n">s_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">rstrip</span><span class="p">(</span><span class="s">','</span><span class="p">).</span><span class="n">split</span><span class="p">(</span><span class="s">'='</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">s_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">rstrip</span><span class="p">(</span><span class="s">':'</span><span class="p">).</span><span class="n">split</span><span class="p">(</span><span class="s">'='</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">b_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">8</span><span class="p">].</span><span class="n">rstrip</span><span class="p">(</span><span class="s">','</span><span class="p">).</span><span class="n">split</span><span class="p">(</span><span class="s">'='</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">b_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">9</span><span class="p">].</span><span class="n">rstrip</span><span class="p">(</span><span class="s">','</span><span class="p">).</span><span class="n">split</span><span class="p">(</span><span class="s">'='</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">min_x</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">s_x</span><span class="p">,</span> <span class="n">b_x</span><span class="p">,</span> <span class="n">min_y</span><span class="p">)</span>
    <span class="n">min_y</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">s_y</span><span class="p">,</span> <span class="n">b_y</span><span class="p">,</span> <span class="n">min_y</span><span class="p">)</span>
    <span class="n">max_x</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">s_x</span><span class="p">,</span> <span class="n">b_x</span><span class="p">,</span> <span class="n">max_x</span><span class="p">)</span>
    <span class="n">max_y</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">s_y</span><span class="p">,</span> <span class="n">b_y</span><span class="p">,</span> <span class="n">max_y</span><span class="p">)</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">b_x</span> <span class="o">-</span> <span class="n">s_x</span><span class="p">)</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">b_y</span> <span class="o">-</span> <span class="n">s_y</span><span class="p">)</span>
    <span class="n">max_dist</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_dist</span><span class="p">,</span> <span class="n">dist</span><span class="p">)</span>

    <span class="n">coordinate_map</span><span class="p">[(</span><span class="n">s_x</span><span class="p">,</span> <span class="n">s_y</span><span class="p">)]</span> <span class="o">=</span> <span class="n">dist</span>
    <span class="n">beacons</span><span class="p">.</span><span class="n">add</span><span class="p">((</span><span class="n">b_x</span><span class="p">,</span> <span class="n">b_y</span><span class="p">))</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">readline</span><span class="p">()</span>

<span class="n">target_y</span> <span class="o">=</span> <span class="mi">2000000</span>
<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">min_x</span> <span class="o">-</span> <span class="n">max_dist</span><span class="p">,</span> <span class="n">max_x</span> <span class="o">+</span> <span class="n">max_dist</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
  <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">coordinate_map</span><span class="p">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">s_x</span><span class="p">,</span> <span class="n">s_y</span> <span class="o">=</span> <span class="n">k</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">s_x</span><span class="p">)</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">target_y</span> <span class="o">-</span> <span class="n">s_y</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">target_y</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">beacons</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">target_y</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">coordinate_map</span> <span class="ow">and</span> <span class="n">dist</span> <span class="o">&lt;=</span> <span class="n">v</span><span class="p">:</span>
      <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="k">break</span>

<span class="k">print</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
</code></pre></div>    </div>

    <h2 id="part-2-14">Part 2</h2>

    <p>Part 2 requires us to limit our search space and find one position that all beacons cannot reach; the problem guarantees that there is only 1 such position within the x and y constraints. Our y-constraint is released, which creates a huge problem for us; now, our constraints are x between 0 to 4000000 and y between 0 to 4000000.</p>

    <p>If I were to draw a grid, and assuming each unit of data we talk about here is 1 byte, that’s like 16 terabytes of data. ‘Tis but a small issue, let’s just buy more RAM.</p>

    <p>Luckily, part 1 doesn’t really store anything in a grid; we have great space complexity, so why not just use it? Turns out, we will experience time issues; even though the algorithm is O(x * n) in time-complexity, where <code class="language-plaintext highlighter-rouge">x</code> is the column size of the theoretical grid and <code class="language-plaintext highlighter-rouge">n</code> is the number of sensors, the algorithm in this new context is now O(y * x * n), since <code class="language-plaintext highlighter-rouge">y</code> is no longer just a constant. <code class="language-plaintext highlighter-rouge">n</code> is a small number, so it basically doesn’t matter, but <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> <em>multiplied</em> together is <em>huge</em>. Suffice to say, the code doesn’t finish with a few hours.</p>

    <p>Instead, let’s slightly change how we approach the problem; instead of finding unreachable locations line by line, we make the following observations instead:</p>

    <ul>
      <li>The unreachable location <em>must</em> exist outside the boundary of the Manhattan distance in the <code class="language-plaintext highlighter-rouge">sensor -&gt; beacon</code> relation.</li>
      <li>Since there is only <em>one</em> unreachable location, the unreachable location <em>must</em> be within Manhattan distance + 1, but not within Manhattan distance.</li>
      <li>The unreachable location is, well, unreachable from all the sensors.</li>
    </ul>

    <p>Hence, we can generate all the points between Manhattan distance and Manhattan distance + 1.</p>

    <p>However, this presents a problem; if the Manhattan distance is some absurd size, like 100000, and we have 16 sensors, then we have an absurd number of generated points, which should be 16 * 4 * 100000 = 6400000 points. If each point takes 16 bytes to store, as each number is an Int, then we get 102,400,000 bytes, which is 102.4GB of RAM. No biggie, just buy more RAM, amirite?</p>

    <p>Well ok, we’ve reduced the storage our solution requires from 16TB to 102.4GB, which is 0.64% of the original size we needed, which is <strong>an improvement</strong> <img class="emoji" title=":tada:" alt=":tada:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f389.png" height="20" width="20">. However, that’s not good enough. So what do we do instead?</p>

    <p>We make sacrifices in time. Now, for <em>every</em> <code class="language-plaintext highlighter-rouge">sensor</code> position, we generate all the unreachable locations from that one sensor position, and check if the unreachable locations is also unreachable from every <em>other</em> <code class="language-plaintext highlighter-rouge">sensor</code> position. Rinse and repeat until we find that one bloody point.</p>

    <p>Originally, if we burned 102.4GB of RAM, then our time complexity would be O(m * n), where <code class="language-plaintext highlighter-rouge">m</code> is the number of points generated, <code class="language-plaintext highlighter-rouge">n</code> is the number of <code class="language-plaintext highlighter-rouge">sensor</code> positions. Now, we burn a cool 100MB of RAM, and have a time complexity of O(m * n^2). In this particular case, I feel that this is a perfectly reasonable trade-off for our problem.</p>

    <p>Hence, the Python code:</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="n">coordinate_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">beacons</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'input.txt'</span><span class="p">,</span> <span class="s">'r'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
  <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">readline</span><span class="p">()</span>
  <span class="k">while</span> <span class="n">line</span><span class="p">:</span>
    <span class="n">tokens</span> <span class="o">=</span> <span class="n">line</span><span class="p">.</span><span class="n">strip</span><span class="p">().</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)</span>
    <span class="n">s_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">rstrip</span><span class="p">(</span><span class="s">','</span><span class="p">).</span><span class="n">split</span><span class="p">(</span><span class="s">'='</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">s_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">rstrip</span><span class="p">(</span><span class="s">':'</span><span class="p">).</span><span class="n">split</span><span class="p">(</span><span class="s">'='</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">b_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">8</span><span class="p">].</span><span class="n">rstrip</span><span class="p">(</span><span class="s">','</span><span class="p">).</span><span class="n">split</span><span class="p">(</span><span class="s">'='</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">b_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">9</span><span class="p">].</span><span class="n">rstrip</span><span class="p">(</span><span class="s">','</span><span class="p">).</span><span class="n">split</span><span class="p">(</span><span class="s">'='</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">b_x</span> <span class="o">-</span> <span class="n">s_x</span><span class="p">)</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">b_y</span> <span class="o">-</span> <span class="n">s_y</span><span class="p">)</span>

    <span class="n">coordinate_map</span><span class="p">[(</span><span class="n">s_x</span><span class="p">,</span> <span class="n">s_y</span><span class="p">)]</span> <span class="o">=</span> <span class="n">dist</span>
    <span class="n">beacons</span><span class="p">.</span><span class="n">add</span><span class="p">((</span><span class="n">b_x</span><span class="p">,</span> <span class="n">b_y</span><span class="p">))</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">readline</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">sensor_barrier_coords</span><span class="p">(</span><span class="n">sensor_pos</span><span class="p">):</span>
  <span class="n">s_x</span><span class="p">,</span> <span class="n">s_y</span> <span class="o">=</span> <span class="n">sensor_pos</span>
  <span class="n">dist</span> <span class="o">=</span> <span class="n">coordinate_map</span><span class="p">[</span><span class="n">sensor_pos</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="n">res</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dist</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
      <span class="n">res</span><span class="p">.</span><span class="n">add</span><span class="p">((</span><span class="n">s_x</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">s_y</span> <span class="o">+</span> <span class="p">(</span><span class="n">dist</span> <span class="o">-</span> <span class="n">i</span><span class="p">)))</span>
      <span class="n">res</span><span class="p">.</span><span class="n">add</span><span class="p">((</span><span class="n">s_x</span> <span class="o">-</span> <span class="n">i</span><span class="p">,</span> <span class="n">s_y</span> <span class="o">-</span> <span class="p">(</span><span class="n">dist</span> <span class="o">-</span> <span class="n">i</span><span class="p">)))</span>
      <span class="n">res</span><span class="p">.</span><span class="n">add</span><span class="p">((</span><span class="n">s_x</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">s_y</span> <span class="o">-</span> <span class="p">(</span><span class="n">dist</span> <span class="o">-</span> <span class="n">i</span><span class="p">)))</span>
      <span class="n">res</span><span class="p">.</span><span class="n">add</span><span class="p">((</span><span class="n">s_x</span> <span class="o">-</span> <span class="n">i</span><span class="p">,</span> <span class="n">s_y</span> <span class="o">+</span> <span class="p">(</span><span class="n">dist</span> <span class="o">-</span> <span class="n">i</span><span class="p">)))</span>

  <span class="k">return</span> <span class="n">res</span>

<span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">coordinate_map</span><span class="p">.</span><span class="n">items</span><span class="p">():</span>
  <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">sensor_barrier_coords</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
    <span class="n">exclusive</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">pos</span>
    <span class="k">if</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">beacons</span> <span class="ow">or</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">coordinate_map</span><span class="p">:</span>
      <span class="k">continue</span>

    <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">4000000</span> <span class="ow">or</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">4000000</span><span class="p">:</span>
      <span class="k">continue</span>

    <span class="k">for</span> <span class="n">k1</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">coordinate_map</span><span class="p">.</span><span class="n">items</span><span class="p">():</span>
      <span class="n">s_x</span><span class="p">,</span> <span class="n">s_y</span> <span class="o">=</span> <span class="n">k1</span>

      <span class="n">dist</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">s_x</span><span class="p">)</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">s_y</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;=</span> <span class="n">v</span><span class="p">:</span>
        <span class="n">exclusive</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">break</span>

    <span class="k">if</span> <span class="n">exclusive</span><span class="p">:</span>
      <span class="k">print</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="mi">4000000</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
      <span class="nb">exit</span><span class="p">()</span>
</code></pre></div>    </div>

    <blockquote>
      <p><code class="language-plaintext highlighter-rouge">x * 4000000 + y</code> is just the problem statement’s instruction on how to encode the answer for AOC to check if the result is valid.</p>
    </blockquote>

    <hr>

    <h1 id="day-16">Day 16</h1>

    <p>This day was, for lack of a better phrase, really difficult. Part 1 was relatively simple, although I did struggle for a day to get it working, while I needed some hints for part 2.</p>

    <h2 id="part-1-15">Part 1</h2>

    <p>Part 1 presents an input that looks something like this:</p>

    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>Valve AA has flow rate=0; tunnels lead to valves DD, II, BB
Valve BB has flow rate=13; tunnels lead to valves CC, AA
Valve CC has flow rate=2; tunnels lead to valves DD, BB
Valve DD has flow rate=20; tunnels lead to valves CC, AA, EE
Valve EE has flow rate=3; tunnels lead to valves FF, DD
Valve FF has flow rate=0; tunnels lead to valves EE, GG
Valve GG has flow rate=0; tunnels lead to valves FF, HH
Valve HH has flow rate=22; tunnel leads to valve GG
Valve II has flow rate=0; tunnels lead to valves AA, JJ
Valve JJ has flow rate=21; tunnel leads to valve II
</code></pre></div>    </div>

    <p>To understand this problem, there are a few pieces of important information that we need to extract from the context:</p>

    <ul>
      <li>Valve <code class="language-plaintext highlighter-rouge">XX</code> denotes a node;</li>
      <li>
<code class="language-plaintext highlighter-rouge">flow rate=xx;</code> denotes a weight to the node;</li>
      <li>
<code class="language-plaintext highlighter-rouge">... DD, II, BB</code> denotes what the node is connected to.</li>
    </ul>

    <p>Each of the valves must be “turned on” to have an impact on the context. The highest sum over a period of 30 units of time will be the solution to the problem.</p>

    <p>If we were to directly translate the input to a graph without much thought, we will end up with a undirected cyclic graph, which for lack of a better term, is a pain to work with.</p>

    <p>Hence, I decided to boil it down using Dijkstra’s Algorithm - before that, I got myself a refresher on how to properly implement priority queues with a flat array, which is possible because it is a complete binary tree.</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="n">heap_rep</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">def</span> <span class="nf">queue_add</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
  <span class="k">global</span> <span class="n">heap_rep</span>
  <span class="n">heap_rep</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
  <span class="n">curr_ind</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">heap_rep</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

  <span class="c1"># =&gt; odd number = left child, even number = right child
</span>  <span class="n">parent</span> <span class="o">=</span> <span class="p">(</span><span class="n">curr_ind</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span> <span class="k">if</span> <span class="n">curr_ind</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">(</span><span class="n">curr_ind</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
  <span class="k">while</span> <span class="n">parent</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">heap_rep</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">heap_rep</span><span class="p">[</span><span class="n">curr_ind</span><span class="p">]:</span>
    <span class="n">heap_rep</span><span class="p">[</span><span class="n">parent</span><span class="p">],</span> <span class="n">heap_rep</span><span class="p">[</span><span class="n">curr_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">heap_rep</span><span class="p">[</span><span class="n">curr_ind</span><span class="p">],</span> <span class="n">heap_rep</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span>
    <span class="n">curr_ind</span> <span class="o">=</span> <span class="n">parent</span>
    <span class="n">parent</span> <span class="o">=</span> <span class="p">(</span><span class="n">curr_ind</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span> <span class="k">if</span> <span class="n">curr_ind</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">(</span><span class="n">curr_ind</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

<span class="k">def</span> <span class="nf">queue_pop</span><span class="p">():</span>
  <span class="k">global</span> <span class="n">heap_rep</span>
  <span class="n">retval</span> <span class="o">=</span> <span class="n">heap_rep</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">heap_rep</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">heap_rep</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">heap_rep</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">heap_rep</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">ueap_rep</span> <span class="o">=</span> <span class="n">heap_rep</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

  <span class="n">indx</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">left_child</span> <span class="o">=</span> <span class="n">indx</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="n">right_child</span> <span class="o">=</span> <span class="n">indx</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">left_child</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">heap_rep</span><span class="p">)</span> <span class="ow">and</span> <span class="n">heap_rep</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">heap_rep</span><span class="p">[</span><span class="n">left_child</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="n">right_child</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">heap_rep</span><span class="p">)</span> <span class="ow">and</span> <span class="n">heap_rep</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">heap_rep</span><span class="p">[</span><span class="n">right_child</span><span class="p">]):</span>
    <span class="k">if</span> <span class="n">right_child</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">heap_rep</span><span class="p">)</span> <span class="ow">and</span> <span class="n">heap_rep</span><span class="p">[</span><span class="n">left_child</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">heap_rep</span><span class="p">[</span><span class="n">right_child</span><span class="p">]:</span>
      <span class="n">heap_rep</span><span class="p">[</span><span class="n">indx</span><span class="p">],</span> <span class="n">heap_rep</span><span class="p">[</span><span class="n">right_child</span><span class="p">]</span> <span class="o">=</span> <span class="n">heap_rep</span><span class="p">[</span><span class="n">right_child</span><span class="p">],</span> <span class="n">heap_rep</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span>
      <span class="n">indx</span> <span class="o">=</span> <span class="n">right_child</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">heap_rep</span><span class="p">[</span><span class="n">indx</span><span class="p">],</span> <span class="n">heap_rep</span><span class="p">[</span><span class="n">left_child</span><span class="p">]</span> <span class="o">=</span> <span class="n">heap_rep</span><span class="p">[</span><span class="n">left_child</span><span class="p">],</span> <span class="n">heap_rep</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span>
      <span class="n">indx</span> <span class="o">=</span> <span class="n">left_child</span>

    <span class="n">left_child</span> <span class="o">=</span> <span class="n">indx</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">right_child</span> <span class="o">=</span> <span class="n">indx</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span>
  <span class="k">return</span> <span class="n">retval</span>

<span class="n">queue_add</span><span class="p">(</span><span class="mi">14</span><span class="p">)</span>
<span class="n">queue_add</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="n">queue_add</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="n">queue_add</span><span class="p">(</span><span class="mi">18</span><span class="p">)</span>
<span class="n">queue_add</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="n">queue_add</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>
<span class="n">queue_add</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="n">queue_add</span><span class="p">(</span><span class="mi">31</span><span class="p">)</span>
<span class="n">queue_add</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">heap_rep</span><span class="p">)</span>
<span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">heap_rep</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
  <span class="k">print</span><span class="p">(</span><span class="n">queue_pop</span><span class="p">())</span>
</code></pre></div>    </div>

    <blockquote>
      <p>NOTE: Yes, the code looks ugly. It was meant to be a refresher after all!</p>
    </blockquote>

    <p>Then, I used <a href="https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/" target="_blank" rel="noopener noreferrer">GeeksForGeeks’s</a> picture of their graph as reference to test my Dijkstra’s algorithm:</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c1"># testing implementation of d algo
</span>
<span class="n">list_of_distances</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">association_list</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># add some values
</span><span class="n">association_list</span><span class="p">.</span><span class="n">append</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">)])</span>
<span class="n">association_list</span><span class="p">.</span><span class="n">append</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">)])</span>
<span class="n">association_list</span><span class="p">.</span><span class="n">append</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">)])</span>
<span class="n">association_list</span><span class="p">.</span><span class="n">append</span><span class="p">([(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">14</span><span class="p">)])</span>
<span class="n">association_list</span><span class="p">.</span><span class="n">append</span><span class="p">([(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)])</span>
<span class="n">association_list</span><span class="p">.</span><span class="n">append</span><span class="p">([(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">14</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="n">association_list</span><span class="p">.</span><span class="n">append</span><span class="p">([(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="n">association_list</span><span class="p">.</span><span class="n">append</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="n">association_list</span><span class="p">.</span><span class="n">append</span><span class="p">([(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)])</span>

<span class="c1"># calculate distances
</span><span class="n">list_of_distances</span> <span class="o">=</span> <span class="p">[</span><span class="mi">999999</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">association_list</span><span class="p">))]</span>
<span class="n">list_of_distances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1"># non-priority queue implementation
</span><span class="n">spt_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">spt_set</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_of_distances</span><span class="p">):</span>
  <span class="n">min_index</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">min_distance</span> <span class="o">=</span> <span class="mi">999999</span>
  <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">list_of_distances</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">spt_set</span><span class="p">:</span>
      <span class="k">continue</span>

    <span class="k">if</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">min_distance</span><span class="p">:</span>
      <span class="n">min_index</span> <span class="o">=</span> <span class="n">k</span>
      <span class="n">min_distance</span> <span class="o">=</span> <span class="n">v</span>

  <span class="n">spt_set</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">min_index</span><span class="p">)</span>

  <span class="k">for</span> <span class="n">association</span> <span class="ow">in</span> <span class="n">association_list</span><span class="p">[</span><span class="n">min_index</span><span class="p">]:</span>
    <span class="n">list_of_distances</span><span class="p">[</span><span class="n">association</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">min_distance</span> <span class="o">+</span> <span class="n">association</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">list_of_distances</span><span class="p">[</span><span class="n">association</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>

<span class="c1"># get path from one to another
</span><span class="k">print</span><span class="p">(</span><span class="n">list_of_distances</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">):</span>
  <span class="n">target</span> <span class="o">=</span> <span class="n">i</span>
  <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>
  <span class="k">while</span> <span class="n">target</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">min_dist</span> <span class="o">=</span> <span class="mi">999999</span>
    <span class="n">min_ind</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">association</span> <span class="ow">in</span> <span class="n">association_list</span><span class="p">[</span><span class="n">target</span><span class="p">]:</span>
      <span class="n">dist</span> <span class="o">=</span> <span class="n">list_of_distances</span><span class="p">[</span><span class="n">association</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="n">association</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
      <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="n">min_dist</span><span class="p">:</span>
        <span class="n">min_ind</span> <span class="o">=</span> <span class="n">association</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">min_dist</span> <span class="o">=</span> <span class="n">dist</span>
    <span class="n">path</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">min_ind</span><span class="p">)</span>
    <span class="n">target</span> <span class="o">=</span> <span class="n">min_ind</span>

  <span class="k">print</span><span class="p">(</span><span class="s">'-&gt;'</span><span class="p">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">path</span><span class="p">)]))</span>
</code></pre></div>    </div>

    <p>Great, warm-up done. Let’s talk about the problem now.</p>

    <p>The distance between each node (that is connected anyway), is actually just 1 unit; so, we boil down those 1-unit nodes into edges. When those nodes become edges, we realize that <strong>information about how we traverse from one node to another is lost</strong>. In other words, we could be doing crazy things like walking back and forth a node but not actually turning on the valve at that node <em>gasp</em>. Thankfully, that is <strong>exactly what we want</strong>. The conversion process looks something like this:</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_distances</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">associations</span><span class="p">):</span>
  <span class="n">to_visit</span> <span class="o">=</span> <span class="n">PriorityQueue</span><span class="p">()</span>
  <span class="n">distances</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
  <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">associations</span><span class="p">.</span><span class="n">keys</span><span class="p">():</span>
    <span class="n">distances</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">999999</span>

  <span class="n">distances</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">to_visit</span><span class="p">.</span><span class="n">put</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">source</span><span class="p">))</span>

  <span class="k">while</span> <span class="ow">not</span> <span class="n">to_visit</span><span class="p">.</span><span class="n">empty</span><span class="p">():</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">node</span> <span class="o">=</span> <span class="n">to_visit</span><span class="p">.</span><span class="n">get</span><span class="p">()</span>
    <span class="n">association</span> <span class="o">=</span> <span class="n">associations</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">association</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
      <span class="k">if</span> <span class="n">distances</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">distances</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">distances</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">to_visit</span><span class="p">.</span><span class="n">put</span><span class="p">((</span><span class="n">distances</span><span class="p">[</span><span class="n">neighbor</span><span class="p">],</span> <span class="n">neighbor</span><span class="p">))</span>

  <span class="k">return</span> <span class="n">distances</span>
</code></pre></div>    </div>

    <p>Let’s talk about the structure we get from this. If we were to pass <code class="language-plaintext highlighter-rouge">source</code> the root node, we’ll get the minimum spanning tree (i.e. the minimum distance from the current node to any other node in the graph). So, if we were to iterate through a list of <em>all of the nodes with a valve that has a flow rate</em>, then we’ll get a map of minimum spanning trees from all nodes. Some questions you may now have is:</p>

    <ol>
      <li>
        <p>Wouldn’t the minimum spanning tree from every other node simply be an adjustment of the distance traveled from the starting node, to the ending node?</p>

        <p>Me: No, because remember that we lost information about how to actually traverse from one node to another; we only know the distance. Imagine a cyclic graph, <code class="language-plaintext highlighter-rouge">A &lt;-&gt; B &lt;-&gt; C &lt;-&gt; D &lt;-&gt; A</code>, and only <code class="language-plaintext highlighter-rouge">A</code>, <code class="language-plaintext highlighter-rouge">B</code> and <code class="language-plaintext highlighter-rouge">D</code> are nodes with valves, which means a minimum spanning tree that looks like this: <code class="language-plaintext highlighter-rouge">A &lt;-1-&gt; B, A &lt;-3-&gt; D</code>. If I was at <code class="language-plaintext highlighter-rouge">A</code>, and I first go to <code class="language-plaintext highlighter-rouge">D</code>, I travel a distance of <code class="language-plaintext highlighter-rouge">3</code>. How would I then travel to <code class="language-plaintext highlighter-rouge">B</code>? We know that the distance from <code class="language-plaintext highlighter-rouge">A</code> to <code class="language-plaintext highlighter-rouge">D</code> is <code class="language-plaintext highlighter-rouge">3</code>, and the distance from <code class="language-plaintext highlighter-rouge">A</code> to <code class="language-plaintext highlighter-rouge">B</code> is <code class="language-plaintext highlighter-rouge">1</code>. So is the answer <code class="language-plaintext highlighter-rouge">4</code>? Of course not, there is a shorter path that connected <code class="language-plaintext highlighter-rouge">B</code> to <code class="language-plaintext highlighter-rouge">D</code> through <code class="language-plaintext highlighter-rouge">C</code>, which means the answer is actually <code class="language-plaintext highlighter-rouge">2</code>. but we wouldn’t have known that with just the minimum spanning tree of <code class="language-plaintext highlighter-rouge">A</code>. So, we necessarily must generate the spanning tree of all the node with valves.</p>
      </li>
      <li>
        <p>What is the resulting structure?</p>

        <p>Me: Before I answer this question, let me go through what went through my head for over half a day. “This structure must be a web, because each node has it’s own minimum spanning tree!” Naturally, I thought that I ended up with a 3D fully connected web. It took me a while before I was able to re-interpret the graph as a directed acyclic graph, a.k.a a tree. Realizing it is a tree has many benefits, which includes: being able to actually solve the problem. To see how it is a tree, remember that the graph has lost all information about paths through the actual nodes. Then, each node is now represented as actually <em>turning on</em> the nodes, because remember, with information lost about paths, it also suggests that someone could navigate the through the nodes with valves to reach a more important valve before coming back later. Since you are unable to turn on a valve twice, this means that in a graph, the arrow always points outwards, and there will never be a situation where a path will point back to itself. Hence, it is directed and acyclic, which makes the resulting structure a tree.</p>
      </li>
      <li>
        <p>How does this new structure solve the problem?</p>
      </li>
    </ol>

    <p>Now that it’s represented as a tree, we can use a variety of ways (like I tried to do) to solve the problem. However, there is one extremely important thing about the problem that makes it challenging to use conventional graph search algorithms: we are <em>maximizing</em> our sum.</p>

    <p>All pathfinding algorithm <em>minimizes</em> paths. In a nutshell, this means we have to either look for fantastic heuristics that can turn our maximizing problem into minimizing problems, or figure out another way.</p>

    <p>Heuristics are hard, particularly because approximate ones may not yield an accurate result, while an accurate one will either take too long to compute, or is very challenging to define. For instance, A* Search and Dijkstra both require heuristics to make decisions on what to explore next; if we had heuristics that kept on increasing in value, the pathfinding algorithm will be stuck on a single path, and <strong>we end up with an inaccurate result</strong>. Even if we were to solve that problem by inversing the heuristic, we still find that our reliance on the accumulated pressure, which is always increasing, causes the heuristics to produce inaccurate results. Heuristics work the best if it is calculated between two nodes, and does not have any context-wide variables, such as time, which is required to calculate the total pressure amassed between any two nodes.</p>

    <p>Then, you may ask. What about using a slightly inaccurate heuristic, such as <code class="language-plaintext highlighter-rouge">time / pressure</code>? The larger the time, the more unideal that path. The lower the pressure amassed, the more unideal the path. Perfect!</p>

    <p>Perfect?</p>

    <p>Well, I tried it out, and it somehow worked for the example, but not the actual input. The rationale is simple: it’s actually <code class="language-plaintext highlighter-rouge">(w1 * time) / (w2 * pressure)</code>, where <code class="language-plaintext highlighter-rouge">w1</code> and <code class="language-plaintext highlighter-rouge">w2</code> are arbitrary weights dictating how important time and pressure is. This is the nature of approximation - we need to declare how important something is to the other. However, for our use-case, we need precise answers; hence, even approximate heuristics are not suitable.</p>

    <p>There is likely a proper heuristic that can be used for this particular problem, but I decided that it is no longer worth the effort. Instead, I explored BFS and DFS.</p>

    <p>I didn’t think too much about BFS, because I had a gut feeling that it wouldn’t be suitable for the rest of the puzzle; turns out, in part 2, where I actually implement BFS because I ran out of options, I was actually right. The space complexity of BFS is <code class="language-plaintext highlighter-rouge">|V|</code>, which is synonymous with every node in existence. When we reach part 2, we can see why storing <code class="language-plaintext highlighter-rouge">|V|</code> is a terrible idea. Meanwhile, for DFS, the space complexity is however many edges we have for the node we are currently processing, which is <code class="language-plaintext highlighter-rouge">|E|</code>. In a nutshell, for our problem in particular, the storage complexity of DFS is beneficial.</p>

    <p>DFS is great because we can do anything with it; even a problem like maximizing accumulated sums. Although there are better ways to do it, like <a href="/2022/01/25/duty-planning-with-linear-programming/">linear programming</a>, the nature of the problem probably disallows us to express the problem as a linear equation (I tried boiling it down to a linear equation, but after spending a fair bit of time, I decided not to).</p>

    <p>So, after figuring out that it’s a tree, and DFS is the way forward, and attempting to implement the other searches as an experiment, I ended up with a simple implementation like so:</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">queue</span> <span class="kn">import</span> <span class="n">PriorityQueue</span>

<span class="k">def</span> <span class="nf">get_distances</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">associations</span><span class="p">):</span>
  <span class="n">to_visit</span> <span class="o">=</span> <span class="n">PriorityQueue</span><span class="p">()</span>
  <span class="n">distances</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
  <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">associations</span><span class="p">.</span><span class="n">keys</span><span class="p">():</span>
    <span class="n">distances</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">999999</span>

  <span class="n">distances</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">to_visit</span><span class="p">.</span><span class="n">put</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">source</span><span class="p">))</span>

  <span class="k">while</span> <span class="ow">not</span> <span class="n">to_visit</span><span class="p">.</span><span class="n">empty</span><span class="p">():</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">node</span> <span class="o">=</span> <span class="n">to_visit</span><span class="p">.</span><span class="n">get</span><span class="p">()</span>
    <span class="n">association</span> <span class="o">=</span> <span class="n">associations</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">association</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
      <span class="k">if</span> <span class="n">distances</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">distances</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">distances</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">to_visit</span><span class="p">.</span><span class="n">put</span><span class="p">((</span><span class="n">distances</span><span class="p">[</span><span class="n">neighbor</span><span class="p">],</span> <span class="n">neighbor</span><span class="p">))</span>

  <span class="k">return</span> <span class="n">distances</span>

<span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">pressure</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">important_nodes</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">time</span> <span class="o">&gt;=</span> <span class="mi">30</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">pressure</span>

  <span class="n">distances</span> <span class="o">=</span> <span class="n">get_distances</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">associations</span><span class="p">)</span>
  <span class="n">best_pressure</span> <span class="o">=</span> <span class="n">pressure</span>

  <span class="k">for</span> <span class="n">impt_node</span> <span class="ow">in</span> <span class="n">important_nodes</span><span class="p">:</span>
    <span class="n">node</span><span class="p">,</span> <span class="p">(</span><span class="n">point_pressure</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">impt_node</span>
    <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
      <span class="k">continue</span>

    <span class="n">new_time</span> <span class="o">=</span> <span class="n">time</span> <span class="o">+</span> <span class="n">distances</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">new_pressure</span> <span class="o">=</span> <span class="n">pressure</span> <span class="o">+</span> <span class="n">point_pressure</span> <span class="o">*</span> <span class="p">(</span><span class="mi">30</span> <span class="o">-</span> <span class="n">new_time</span><span class="p">)</span>
    <span class="n">new_visited</span> <span class="o">=</span> <span class="n">visited</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">new_visited</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">new_time</span><span class="p">,</span> <span class="n">new_pressure</span><span class="p">,</span> <span class="n">new_visited</span><span class="p">,</span> <span class="n">important_nodes</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">res</span> <span class="o">&gt;</span> <span class="n">best_pressure</span><span class="p">:</span>
      <span class="n">best_pressure</span> <span class="o">=</span> <span class="n">res</span>

  <span class="k">return</span> <span class="n">best_pressure</span>

<span class="n">associations</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'input.txt'</span><span class="p">,</span> <span class="s">'r'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
  <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">strip</span><span class="p">().</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)</span>
  <span class="k">while</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s">''</span><span class="p">:</span>
    <span class="n">associations</span><span class="p">[</span><span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">4</span><span class="p">].</span><span class="n">rstrip</span><span class="p">(</span><span class="s">';'</span><span class="p">).</span><span class="n">split</span><span class="p">(</span><span class="s">'='</span><span class="p">)[</span><span class="mi">1</span><span class="p">]),</span>
      <span class="p">[</span><span class="n">valve</span><span class="p">.</span><span class="n">strip</span><span class="p">(</span><span class="s">','</span><span class="p">)</span> <span class="k">for</span> <span class="n">valve</span> <span class="ow">in</span> <span class="n">line</span><span class="p">[</span><span class="mi">9</span><span class="p">:]])</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">strip</span><span class="p">().</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">dfs</span><span class="p">(</span><span class="s">'AA'</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">set</span><span class="p">(),</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">associations</span><span class="p">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]))</span>
</code></pre></div>    </div>

    <p>And wouldn’t you know, it worked!</p>

    <h2 id="part-2-15">Part 2</h2>

    <p>This part is the main reason why I spent 4 days to write the blog post from Day 16 to Day 19. The problem introduces a new entity that can explore the graph, which is affectionately chosen to be an elephant, and cuts the amount of time we have to explore the nodes to 26 units of time.</p>

    <p>To save you the trouble from thinking about it: no, a double for-loop in DFS doesn’t work. Well, it would, if you run the program for 16 hours (actual calculations), but it is definitely not the intended solution.</p>

    <p>Of course, it didn’t stop me from trying:</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">info_source_1</span><span class="p">,</span> <span class="n">info_source_2</span><span class="p">,</span> <span class="n">pressure</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">important_nodes</span><span class="p">,</span> <span class="n">distances_map</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
  <span class="n">source_1</span><span class="p">,</span> <span class="n">time_1</span> <span class="o">=</span> <span class="n">info_source_1</span>
  <span class="n">source_2</span><span class="p">,</span> <span class="n">time_2</span> <span class="o">=</span> <span class="n">info_source_2</span>

  <span class="k">if</span> <span class="n">time_2</span> <span class="o">&gt;=</span> <span class="mi">26</span> <span class="ow">and</span> <span class="n">time_1</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">info_source_2</span><span class="p">,</span> <span class="n">info_source_1</span><span class="p">,</span> <span class="n">pressure</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">important_nodes</span><span class="p">,</span> <span class="n">distances_map</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">time_1</span> <span class="o">&gt;=</span> <span class="mi">26</span> <span class="ow">and</span> <span class="n">time_2</span> <span class="o">&gt;=</span> <span class="mi">26</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">pressure</span>

  <span class="n">distances_1</span> <span class="o">=</span> <span class="n">distances_map</span><span class="p">[</span><span class="n">source_1</span><span class="p">]</span>
  <span class="n">distances_2</span> <span class="o">=</span> <span class="n">distances_map</span><span class="p">[</span><span class="n">source_2</span><span class="p">]</span>
  <span class="n">best_pressure</span> <span class="o">=</span> <span class="n">pressure</span>

  <span class="k">for</span> <span class="n">impt_node_1</span> <span class="ow">in</span> <span class="n">important_nodes</span><span class="p">:</span>
    <span class="n">node_1</span><span class="p">,</span> <span class="p">(</span><span class="n">point_pressure_1</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">impt_node_1</span>
    <span class="k">if</span> <span class="n">node_1</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
      <span class="k">continue</span>

    <span class="n">new_time_1</span> <span class="o">=</span> <span class="n">time_1</span> <span class="o">+</span> <span class="n">distances_1</span><span class="p">[</span><span class="n">node_1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">new_visited</span> <span class="o">=</span> <span class="n">visited</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">new_visited</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">node_1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">time_2</span> <span class="o">&gt;=</span> <span class="mi">26</span><span class="p">:</span>
      <span class="n">new_pressure</span> <span class="o">=</span> <span class="n">pressure</span> <span class="o">+</span> <span class="n">point_pressure_1</span> <span class="o">*</span> <span class="p">(</span><span class="mi">26</span> <span class="o">-</span> <span class="n">new_time_1</span><span class="p">)</span>
      <span class="n">res</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">((</span><span class="n">node_1</span><span class="p">,</span> <span class="n">new_time_1</span><span class="p">),</span> <span class="n">info_source_2</span><span class="p">,</span> <span class="n">new_pressure</span><span class="p">,</span> <span class="n">new_visited</span><span class="p">,</span> <span class="n">important_nodes</span><span class="p">,</span> <span class="n">distances_map</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">res</span> <span class="o">&gt;</span> <span class="n">best_pressure</span><span class="p">:</span>
        <span class="n">best_pressure</span> <span class="o">=</span> <span class="n">res</span>
      <span class="k">continue</span>

    <span class="k">for</span> <span class="n">impt_node_2</span> <span class="ow">in</span> <span class="n">important_nodes</span><span class="p">:</span>
      <span class="n">node_2</span><span class="p">,</span> <span class="p">(</span><span class="n">point_pressure_2</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">impt_node_2</span>
      <span class="k">if</span> <span class="n">node_2</span> <span class="ow">in</span> <span class="n">visited</span> <span class="ow">or</span> <span class="n">node_1</span> <span class="ow">is</span> <span class="n">node_2</span><span class="p">:</span>
        <span class="k">continue</span>

      <span class="n">new_time_2</span> <span class="o">=</span> <span class="n">time_2</span> <span class="o">+</span> <span class="n">distances_2</span><span class="p">[</span><span class="n">node_2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="n">new_pressure</span> <span class="o">=</span> <span class="n">pressure</span> <span class="o">+</span> <span class="n">point_pressure_1</span> <span class="o">*</span> <span class="p">(</span><span class="mi">26</span> <span class="o">-</span> <span class="n">new_time_1</span><span class="p">)</span> <span class="o">+</span> <span class="n">point_pressure_2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">26</span> <span class="o">-</span> <span class="n">new_time_2</span><span class="p">)</span>
      <span class="n">new_visited_inner</span> <span class="o">=</span> <span class="n">new_visited</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>
      <span class="n">new_visited_inner</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">node_2</span><span class="p">)</span>
      <span class="n">res</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">((</span><span class="n">node_1</span><span class="p">,</span> <span class="n">new_time_1</span><span class="p">),</span> <span class="p">(</span><span class="n">node_2</span><span class="p">,</span> <span class="n">new_time_2</span><span class="p">),</span> <span class="n">new_pressure</span><span class="p">,</span> <span class="n">new_visited_inner</span><span class="p">,</span> <span class="n">important_nodes</span><span class="p">,</span> <span class="n">distances_map</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">res</span> <span class="o">&gt;</span> <span class="n">best_pressure</span><span class="p">:</span>
        <span class="n">best_pressure</span> <span class="o">=</span> <span class="n">res</span>

  <span class="k">return</span> <span class="n">best_pressure</span>
</code></pre></div>    </div>

    <p>While it worked for the example input, it doesn’t work (i.e. doesn’t finish within acceptable time) for the real input. This is because there are <code class="language-plaintext highlighter-rouge">15! * 14! = 114,000,816,848,279,961,600,000</code> possible combinations for the algorithm to run through.</p>

    <p>So, what next? I tried BFS as well:</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">bfs</span><span class="p">(</span><span class="n">info_source_1</span><span class="p">,</span> <span class="n">info_source_2</span><span class="p">,</span> <span class="n">important_nodes</span><span class="p">,</span> <span class="n">distances_map</span><span class="p">):</span>
  <span class="n">q</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
  <span class="n">p</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>

  <span class="n">q</span><span class="p">.</span><span class="n">put</span><span class="p">((</span><span class="n">info_source_1</span><span class="p">,</span> <span class="n">info_source_2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">set</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[]))</span>
  <span class="n">set_of_all_important_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">important_nodes</span><span class="p">])</span>
  <span class="n">found_pressure</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">found_depth</span> <span class="o">=</span> <span class="mi">999999</span>

  <span class="k">while</span> <span class="ow">not</span> <span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">():</span>
    <span class="n">info_source_1</span><span class="p">,</span> <span class="n">info_source_2</span><span class="p">,</span> <span class="n">pressure</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">path</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">get</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">depth</span> <span class="o">&gt;</span> <span class="n">found_depth</span><span class="p">:</span>
      <span class="k">break</span>

    <span class="n">source_1</span><span class="p">,</span> <span class="n">time_1</span> <span class="o">=</span> <span class="n">info_source_1</span>
    <span class="n">source_2</span><span class="p">,</span> <span class="n">time_2</span> <span class="o">=</span> <span class="n">info_source_2</span>

    <span class="k">if</span> <span class="n">time_2</span> <span class="o">&gt;=</span> <span class="mi">26</span> <span class="ow">and</span> <span class="n">time_1</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">:</span>
      <span class="n">source_1</span><span class="p">,</span> <span class="n">source_2</span> <span class="o">=</span> <span class="n">source_2</span><span class="p">,</span> <span class="n">source_1</span>
      <span class="n">time_1</span><span class="p">,</span> <span class="n">time_2</span> <span class="o">=</span> <span class="n">time_2</span><span class="p">,</span> <span class="n">time_1</span>
    <span class="k">elif</span> <span class="n">time_1</span> <span class="o">&gt;=</span> <span class="mi">26</span> <span class="ow">and</span> <span class="n">time_2</span> <span class="o">&gt;=</span> <span class="mi">26</span><span class="p">:</span>
      <span class="k">continue</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">visited</span> <span class="o">&amp;</span> <span class="n">set_of_all_important_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">important_nodes</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">pressure</span> <span class="o">&gt;</span> <span class="n">found_pressure</span><span class="p">:</span>
        <span class="n">found_pressure</span> <span class="o">=</span> <span class="n">pressure</span>
        <span class="n">found_depth</span> <span class="o">=</span> <span class="n">depth</span>

    <span class="n">distances_1</span> <span class="o">=</span> <span class="n">distances_map</span><span class="p">[</span><span class="n">source_1</span><span class="p">]</span>
    <span class="n">distances_2</span> <span class="o">=</span> <span class="n">distances_map</span><span class="p">[</span><span class="n">source_2</span><span class="p">]</span>
    <span class="n">best_pressure</span> <span class="o">=</span> <span class="n">pressure</span>

    <span class="k">for</span> <span class="n">impt_node_1</span> <span class="ow">in</span> <span class="n">important_nodes</span><span class="p">:</span>
      <span class="n">node_1</span><span class="p">,</span> <span class="p">(</span><span class="n">point_pressure_1</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">impt_node_1</span>
      <span class="k">if</span> <span class="n">node_1</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
        <span class="k">continue</span>

      <span class="n">new_time_1</span> <span class="o">=</span> <span class="n">time_1</span> <span class="o">+</span> <span class="n">distances_1</span><span class="p">[</span><span class="n">node_1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="n">new_visited</span> <span class="o">=</span> <span class="n">visited</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>
      <span class="n">new_visited</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">node_1</span><span class="p">)</span>

      <span class="k">if</span> <span class="n">time_2</span> <span class="o">&gt;=</span> <span class="mi">26</span><span class="p">:</span>
        <span class="n">new_pressure</span> <span class="o">=</span> <span class="n">pressure</span> <span class="o">+</span> <span class="n">point_pressure_1</span> <span class="o">*</span> <span class="p">(</span><span class="mi">26</span> <span class="o">-</span> <span class="n">new_time_1</span><span class="p">)</span>
        <span class="n">q</span><span class="p">.</span><span class="n">put</span><span class="p">(((</span><span class="n">node_1</span><span class="p">,</span> <span class="n">new_time_1</span><span class="p">),</span> <span class="n">info_source_2</span><span class="p">,</span> <span class="n">new_pressure</span><span class="p">,</span> <span class="n">new_visited</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">path</span><span class="p">))</span>

      <span class="k">for</span> <span class="n">impt_node_2</span> <span class="ow">in</span> <span class="n">important_nodes</span><span class="p">:</span>
        <span class="n">node_2</span><span class="p">,</span> <span class="p">(</span><span class="n">point_pressure_2</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">impt_node_2</span>
        <span class="k">if</span> <span class="n">node_2</span> <span class="ow">in</span> <span class="n">visited</span> <span class="ow">or</span> <span class="n">node_1</span> <span class="ow">is</span> <span class="n">node_2</span><span class="p">:</span>
          <span class="k">continue</span>

        <span class="n">new_time_2</span> <span class="o">=</span> <span class="n">time_2</span> <span class="o">+</span> <span class="n">distances_2</span><span class="p">[</span><span class="n">node_2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">new_pressure</span> <span class="o">=</span> <span class="n">pressure</span> <span class="o">+</span> <span class="n">point_pressure_1</span> <span class="o">*</span> <span class="p">(</span><span class="mi">26</span> <span class="o">-</span> <span class="n">new_time_1</span><span class="p">)</span> <span class="o">+</span> <span class="n">point_pressure_2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">26</span> <span class="o">-</span> <span class="n">new_time_2</span><span class="p">)</span>
        <span class="n">new_visited_inner</span> <span class="o">=</span> <span class="n">new_visited</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_visited_inner</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">node_2</span><span class="p">)</span>
        <span class="n">q</span><span class="p">.</span><span class="n">put</span><span class="p">(((</span><span class="n">node_1</span><span class="p">,</span> <span class="n">new_time_1</span><span class="p">),</span> <span class="p">(</span><span class="n">node_2</span><span class="p">,</span> <span class="n">new_time_2</span><span class="p">),</span> <span class="n">new_pressure</span><span class="p">,</span> <span class="n">new_visited_inner</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="p">[(</span><span class="n">node_1</span><span class="p">,</span> <span class="n">node_2</span><span class="p">)]))</span>

  <span class="k">return</span> <span class="n">found_pressure</span>
</code></pre></div>    </div>

    <p>The BFS mechanism uses a gimmick to break out early, because I reasoned that beyond a certain depth, we approach diminishing returns. Needless to say, BFS worked on the example input, but not on the actual input, due to space complexity.</p>

    <p>I went berserk and also implemented Dijkstra’s to find the minimum spanning tree, but in hindsight, I have no idea what I was trying to accomplish with it.</p>

    <p>Eventually, I gave up and went to bed. On and off, I would try my hand again, including attempting to use permutations to shuffle the order of valves to open, but again, due to space complexity, this was infeasible.</p>

    <p>Finally, I decided to look for inspiration. Without looking at the solutions, I looked through the Reddit post, and found a post by <a href="https://www.reddit.com/r/adventofcode/comments/zn6k1l/comment/j0ffso8/?utm_source=share&amp;utm_medium=web2x&amp;context=3" target="_blank" rel="noopener noreferrer">betaveros</a> (at time of writing, the top on the leaderboard), which contained a sentence that gave me the inspiration to settle on the answer: “one person first, then the same DFS for the other over all unopened valves”.</p>

    <p>If I may: “god damn it”! I’ve thought about this at one point, but my implementation was naive: I simply made one explorer explore half the list, and the other explorer explore the other half of the list. However, this failed because obviously, not <em>all</em> possibilities were considered.</p>

    <p>However, let’s think about it another way. Assume I have 6 valves to open. If I were to open the valves alone, I may not be able to finish within the 26 measly minutes given to me. So, the whole point of teamwork is to split up the work. Hence, two explorers should open roughly 3 valves each. However, recall that once a valve has been opened, <strong>it cannot be opened again</strong>. Hence, all I need to do is to perform DFS on 3 valves, then change the actor to the other explorer, and perform DFS on the remaining 3 valves. Hence, instead of searching through <code class="language-plaintext highlighter-rouge">6! * 5!</code> possibilities, I am now at <code class="language-plaintext highlighter-rouge">6!</code> possibilities, which is definitely doable within human time.</p>

    <p>Supersizing to the current problem, we now have an opportunity to restrict the problem to <code class="language-plaintext highlighter-rouge">15!</code> possibilities, which may be a huge number, but definitely much smaller than <code class="language-plaintext highlighter-rouge">15! * 14!</code> possibilities. Hence, the new DFS is implemented as such:</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">info_source_1</span><span class="p">,</span> <span class="n">info_source_2</span><span class="p">,</span> <span class="n">pressure</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">important_nodes</span><span class="p">,</span> <span class="n">distances_map</span><span class="p">):</span>
  <span class="n">source_1</span><span class="p">,</span> <span class="n">time_1</span> <span class="o">=</span> <span class="n">info_source_1</span>
  <span class="n">source_2</span><span class="p">,</span> <span class="n">time_2</span> <span class="o">=</span> <span class="n">info_source_2</span>

  <span class="k">if</span> <span class="n">time_1</span> <span class="o">&gt;=</span> <span class="mi">26</span> <span class="ow">and</span> <span class="n">time_2</span> <span class="o">&gt;=</span> <span class="mi">26</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">pressure</span><span class="p">,</span> <span class="n">path</span>
  <span class="k">elif</span> <span class="n">time_1</span> <span class="o">&gt;=</span> <span class="mi">26</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">important_nodes</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">time_2</span> <span class="o">!=</span> <span class="mi">9999</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">info_source_2</span><span class="p">,</span> <span class="p">(</span><span class="n">source_1</span><span class="p">,</span> <span class="mi">9999</span><span class="p">),</span> <span class="n">pressure</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">important_nodes</span><span class="p">,</span> <span class="n">distances_map</span><span class="p">)</span>

  <span class="n">distances</span> <span class="o">=</span> <span class="n">distances_map</span><span class="p">[</span><span class="n">source_1</span><span class="p">]</span>
  <span class="n">best_pressure</span> <span class="o">=</span> <span class="n">pressure</span>

  <span class="k">for</span> <span class="n">impt_node</span> <span class="ow">in</span> <span class="n">important_nodes</span><span class="p">:</span>
    <span class="n">node</span><span class="p">,</span> <span class="p">(</span><span class="n">point_pressure</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">impt_node</span>
    <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
      <span class="k">continue</span>

    <span class="n">new_time</span> <span class="o">=</span> <span class="n">time_1</span> <span class="o">+</span> <span class="n">distances</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">new_visited</span> <span class="o">=</span> <span class="n">visited</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">new_visited</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="n">new_pressure</span> <span class="o">=</span> <span class="n">pressure</span> <span class="o">+</span> <span class="n">point_pressure</span> <span class="o">*</span> <span class="p">(</span><span class="mi">26</span> <span class="o">-</span> <span class="n">new_time</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">((</span><span class="n">node</span><span class="p">,</span> <span class="n">new_time</span><span class="p">),</span> <span class="n">info_source_2</span><span class="p">,</span> <span class="n">new_pressure</span><span class="p">,</span> <span class="n">new_visited</span><span class="p">,</span> <span class="n">important_nodes</span><span class="p">,</span> <span class="n">distances_map</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">res</span> <span class="o">&gt;</span> <span class="n">best_pressure</span><span class="p">:</span>
      <span class="n">best_pressure</span> <span class="o">=</span> <span class="n">res</span>

  <span class="k">return</span> <span class="n">best_pressure</span>
</code></pre></div>    </div>

    <p>So, applying this diff (<code class="language-plaintext highlighter-rouge">&lt;</code> is part 1, <code class="language-plaintext highlighter-rouge">&gt;</code> part 2) to the part 1 solution, and running the program for roughly 20 minutes will give us the final result.</p>

    <div class="language-diff highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="p">22,24c22,29
</span><span class="gd">&lt; def dfs(source, time, pressure, visited, important_nodes):
&lt;   if time &gt;= 30:
&lt;     return pressure
</span><span class="p">---
</span><span class="gi">&gt; def dfs(info_source_1, info_source_2, pressure, visited, important_nodes, distances_map):
&gt;   source_1, time_1 = info_source_1
&gt;   source_2, time_2 = info_source_2
&gt;
&gt;   if time_1 &gt;= 26 and time_2 &gt;= 26:
&gt;     return pressure, path
&gt;   elif time_1 &gt;= 26 or (len(visited) + 1 &gt; len(important_nodes) // 2 and time_2 != 9999):
&gt;     return dfs(info_source_2, (source_1, 9999), pressure, visited, important_nodes, distances_map)
</span><span class="p">26c31
</span><span class="gd">&lt;   distances = get_distances(source, associations)
</span><span class="p">---
</span><span class="gi">&gt;   distances = distances_map[source_1]
</span><span class="p">34,35c39
</span><span class="gd">&lt;     new_time = time + distances[node] + 1
&lt;     new_pressure = pressure + point_pressure * (30 - new_time)
</span><span class="p">---
</span><span class="gi">&gt;     new_time = time_1 + distances[node] + 1
</span><span class="p">38c42,44
</span><span class="gd">&lt;     res = dfs(node, new_time, new_pressure, new_visited, important_nodes)
</span><span class="p">---
</span><span class="gi">&gt;
&gt;     new_pressure = pressure + point_pressure * (26 - new_time)
&gt;     res = dfs((node, new_time), info_source_2, new_pressure, new_visited, important_nodes, distances_map)
</span><span class="p">52c58,60
</span><span class="gd">&lt; print(dfs('AA', 0, 0, set(), [(k,v) for k, v in associations.items() if v[0] &gt; 0]))
</span><span class="p">---
</span><span class="gi">&gt; important_elements = [(k,v) for k, v in associations.items() if v[0] &gt; 0]
&gt; distances_map = {k: get_distances(k, associations) for k in associations.keys()}
&gt; print(dfs(('AA', 0), ('AA', 0), 0, set(), important_elements, distances_map))
</span></code></pre></div>    </div>

    <hr>

    <h1 id="day-17">Day 17</h1>

    <p>Wha…? Is this Tetris?</p>

    <h2 id="part-1-16">Part 1</h2>

    <p>Yeah, this is almost like tetris. Given a bunch of blocks, which are the horizontal line, cross, L-shape, vertical line and square, we are tasked to get the height of the tetris board after 2022 tetrominos sets on the board. The tetrominos follow a sequence of movements, which is our input; it looks something like this:</p>

    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt;&lt;&lt;&gt;&lt;&gt;&gt;&lt;&lt;&lt;&gt;&gt;&lt;&gt;&gt;&gt;&lt;&lt;&lt;&gt;&gt;&gt;&lt;&lt;&lt;&gt;&lt;&lt;&lt;&gt;&gt;&lt;&gt;&gt;&lt;&lt;&gt;&gt;
</code></pre></div>    </div>

    <p><code class="language-plaintext highlighter-rouge">&gt;</code> stands for right, and <code class="language-plaintext highlighter-rouge">&lt;</code> stands for left. The sequence of movements repeats. The tetrominos themselves follow the standard set of rules, which are:</p>

    <ol>
      <li>The tetrinome cannot hit the boundaries of the board (which is defined as width of 7 and height of infinity)</li>
      <li>If the bottom of the tetrinome collides with any other settled tetrinomes, or the bottom of the board, settle the tetrinomes.</li>
    </ol>

    <p>So, the sub-problems are:</p>

    <ol>
      <li>Represent the tetrinomes, define procedures for movement;
        <ol>
          <li>Moving left &amp; right based on sequence</li>
          <li>Moving down after left &amp; right</li>
        </ol>
      </li>
      <li>Figure out if the tetrinome has landed</li>
      <li>Figure out maximum height of the board at the end of 2022 block landings</li>
    </ol>

    <p>I decided to represent the tetrinome positions as a set of positions, and adjust the positions based on how the block is falling. So, the code is as follows:</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="n">shapes</span> <span class="o">=</span> <span class="p">[[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
  <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span>
  <span class="p">[(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
  <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)],</span>
  <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]]</span>
<span class="n">offset</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s">'&lt;'</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
  <span class="s">'&gt;'</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">shape_offset</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">width</span> <span class="o">=</span> <span class="mi">7</span>

<span class="n">sequence</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">'input.txt'</span><span class="p">,</span> <span class="s">'r'</span><span class="p">).</span><span class="n">read</span><span class="p">().</span><span class="n">strip</span><span class="p">()</span>
<span class="n">positions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

<span class="n">shape_i</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">dropped</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">current_block</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span> <span class="o">+</span> <span class="n">shape_offset</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">shapes</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
<span class="n">board_max_y</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="n">dropped</span> <span class="o">&lt;</span> <span class="mi">2022</span><span class="p">:</span>
  <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sequence</span><span class="p">:</span>
    <span class="n">current_block</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span> <span class="o">+</span> <span class="n">offset</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span> <span class="o">+</span> <span class="n">offset</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">current_block</span><span class="p">]</span>
    <span class="n">xs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">current_block</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">b</span><span class="p">:</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">ys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">current_block</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">b</span><span class="p">:</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">min_x</span><span class="p">,</span> <span class="n">max_x</span> <span class="o">=</span> <span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">xs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">min_y</span><span class="p">,</span> <span class="n">max_y</span> <span class="o">=</span> <span class="n">ys</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">ys</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">min_x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">max_x</span> <span class="o">&gt;=</span> <span class="n">width</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">current_block</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">positions</span><span class="p">):</span>
      <span class="n">current_block</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span> <span class="o">-</span> <span class="n">offset</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span> <span class="o">-</span> <span class="n">offset</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">current_block</span><span class="p">]</span>
    <span class="n">before_down_block</span> <span class="o">=</span> <span class="n">current_block</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">current_block</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">current_block</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">min_y</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">current_block</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">positions</span><span class="p">):</span>
      <span class="n">dropped</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="n">positions</span> <span class="o">|=</span> <span class="nb">set</span><span class="p">(</span><span class="n">before_down_block</span><span class="p">)</span>
      <span class="n">board_max_y</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="mi">1</span><span class="p">]</span>
      <span class="n">current_block</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span> <span class="o">+</span> <span class="n">shape_offset</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">board_max_y</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">shapes</span><span class="p">[</span><span class="n">shape_i</span><span class="p">]]</span>
      <span class="n">shape_i</span> <span class="o">=</span> <span class="n">shape_i</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">shape_i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">dropped</span> <span class="o">&gt;=</span> <span class="mi">2022</span><span class="p">:</span>
      <span class="k">break</span>

<span class="k">print</span><span class="p">(</span><span class="n">board_max_y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div>    </div>

    <h2 id="part-2-16">Part 2</h2>

    <p>Ah yes, following the pattern we’ve seen in Day 16, we experience another expansion of the problem statement beyond what is reasonable to do with our original algorithm. Our goal now is simple: instead of getting the height at 2022 blocks, we want 1000000000000 (that’s 12 zeros, which means this is 1 trillion). Obviously, not feasible.</p>

    <p>Turns out, this problem can be boiled down into a simple sequencing problem. I began by hypothesizing that at <em>some</em> point, there must be a pattern for height increments; there are a limited number of blocks, and a limited number of sequences. In logical hindsight, this is likely due to the pigeonhole principle - I’ll reach a point where I’m going through the exact same blocks for the exact same sequences.</p>

    <p>To confirm this experimentally, I inserted a print statement to figure out if this was true:</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="n">stats</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="p">...</span>
    <span class="k">if</span> <span class="n">board_max_y</span> <span class="o">-</span> <span class="n">new_max_y</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">stats</span><span class="p">:</span>
      <span class="n">stats</span><span class="p">[</span><span class="n">new_max_y</span> <span class="o">-</span> <span class="n">board_max_y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">stats</span><span class="p">[</span><span class="n">new_max_y</span> <span class="o">-</span> <span class="n">board_max_y</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">s_i</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequence</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># on the actual input, this is (s_i + 1) % ...
</span>      <span class="k">print</span><span class="p">(</span><span class="n">stats</span><span class="p">)</span>
<span class="p">...</span>
  <span class="k">print</span><span class="p">(</span><span class="n">stats</span><span class="p">)</span>
</code></pre></div>    </div>

    <p>where <code class="language-plaintext highlighter-rouge">s_i</code> is the index in the sequence.</p>

    <p>I quickly realised that the pattern holds beyond the first statement; this implies that after a certain starting sequence, the sequence <strong>started to repeat</strong>, implying a predictable increase in height for a fixed increase in block drops.</p>

    <p>In the code, I added a cheeky little comment that says the actual input would require me to change the condition to <code class="language-plaintext highlighter-rouge">s_i + 1</code>. Why?</p>

    <p>Let’s use the actual numbers: the sequence given in the example has 40 tokens, while the sequence given in the actual input has 10091 tokens. <code class="language-plaintext highlighter-rouge">s_i</code> is bounded from 0 to 39 in the example, while <code class="language-plaintext highlighter-rouge">s_i</code> is bounded from 0 to 10090 in the actual input. Hence, <code class="language-plaintext highlighter-rouge">s_i % len(sequence) == 0</code> is only true when <code class="language-plaintext highlighter-rouge">s_i</code> is any multiple of 40 in the example, while <code class="language-plaintext highlighter-rouge">(s_i + 1) % len(sequence) == 0</code> is true when <code class="language-plaintext highlighter-rouge">s_i</code> is only true when <code class="language-plaintext highlighter-rouge">s_i</code> is a multiple of 10090. This is not a co-incidence, because 40 and 10090 are divisible by the number of possible blocks in the context, 5 (also each number’s greatest common factor).</p>

    <p>Intuitively, this means that at <code class="language-plaintext highlighter-rouge">40</code> and <code class="language-plaintext highlighter-rouge">10090</code> sequences respectively, it encapsulates a multiple of block drops for all 5 bocks perfectly. Remember the pigeonhole principle? Let’s say I have 20 pigeons and 10 holes. If we dictate each pigeon to always fly into adjacent holes, then necessarily, each hole must have 2 pigeons (without dictating the behaviour of the pigeon, we could have 1 hole with 19 pigeons). The same applies for this context; 40 sequences and 5 blocks, where each sequence will always apply to the next block in order, then necessarily, each block must have 8 sequences associated to it, always.</p>

    <p>So, with sequences repeating every <code class="language-plaintext highlighter-rouge">40</code> or <code class="language-plaintext highlighter-rouge">10090</code> sequences, we can <strong>bypass the need to simulate falling tetromines</strong>, and just simulate height differences instead.</p>

    <p>Okay, so we now have the theory. How do we translate this to practice?</p>

    <p>Turns out, we are able to “shortcut” most of 1000000000000 block drops, by estimating as much as we can with just pure mathematics.</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="n">estimated_height</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="mi">1000000000000</span> <span class="o">-</span> <span class="n">blocks_1</span><span class="p">)</span> <span class="o">/</span> <span class="n">blocks_difference</span><span class="p">)</span> <span class="o">*</span> <span class="n">repeat_height_difference</span>
</code></pre></div>    </div>

    <p>Where <code class="language-plaintext highlighter-rouge">blocks_difference</code> is the number of blocks dropped from a sequence of <code class="language-plaintext highlighter-rouge">40</code> to <code class="language-plaintext highlighter-rouge">80</code>, or <code class="language-plaintext highlighter-rouge">10090</code> to <code class="language-plaintext highlighter-rouge">20181</code>, and <code class="language-plaintext highlighter-rouge">repeat_height_difference</code> is the height difference between two repeating sequences. I will discuss how to get this later.</p>

    <p>Then, we process the rest of the blocks using the sequences we derived:</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="n">remaining_blocks</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1000000000000</span> <span class="o">-</span> <span class="n">blocks_1</span><span class="p">)</span> <span class="o">%</span> <span class="n">blocks_difference</span>

<span class="n">remaining_height</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">height_epoch_x_i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="n">remaining_blocks</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
  <span class="n">remaining_height</span> <span class="o">+=</span> <span class="n">height_epoch_x</span><span class="p">[</span><span class="n">height_epoch_x_i</span><span class="p">]</span>
  <span class="n">remaining_blocks</span> <span class="o">-=</span> <span class="mi">1</span>
  <span class="k">if</span> <span class="n">height_epoch_x_i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">height_epoch_x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">height_epoch_x_i</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">height_epoch_x_i</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></div>    </div>

    <p>where <code class="language-plaintext highlighter-rouge">height_epoch_x</code> is the height difference per sequence.</p>

    <p>Now, how do we get <code class="language-plaintext highlighter-rouge">blocks_difference</code>, <code class="language-plaintext highlighter-rouge">height_epoch_x</code>, and <code class="language-plaintext highlighter-rouge">repeat_height_difference</code>? We know from experimental data that starting from a <em>certain number of blocks</em>, the sequence holds. Hence, we need to acquire this <em>certain number of blocks</em>, which is tied to the number of sequences processed (they need to be multiples of <code class="language-plaintext highlighter-rouge">40</code> or <code class="language-plaintext highlighter-rouge">10090</code>) and then continue simulating metronomes until we get the sequences from one multiple of <code class="language-plaintext highlighter-rouge">40</code> / <code class="language-plaintext highlighter-rouge">10090</code> to the next.</p>

    <p>Hence, the code diff to get the final answer is as follows:</p>

    <div class="language-diff highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="p">15a16
</span><span class="gi">&gt; # Figuring out the pattern
</span><span class="p">16a18
</span><span class="gi">&gt; s_i = 0
</span><span class="p">20,38c22,35
</span><span class="gd">&lt; while dropped &lt; 2022:
&lt;   for s in sequence:
&lt;     current_block = [(x + offset[s][0], y + offset[s][1]) for x, y in current_block]
&lt;     xs = sorted(current_block, key=lambda b: b[0])
&lt;     ys = sorted(current_block, key=lambda b: b[1])
&lt;     min_x, max_x = xs[0][0], xs[-1][0]
&lt;     min_y, max_y = ys[0][1], ys[-1][1]
&lt;
&lt;     if min_x &lt; 0 or max_x &gt;= width or len(set(current_block) &amp; positions):
&lt;       current_block = [(x - offset[s][0], y - offset[s][1]) for x, y in current_block]
&lt;     before_down_block = current_block.copy()
&lt;     current_block = [(x, y - 1) for x, y in current_block]
&lt;
&lt;     if min_y &lt;= 0 or len(set(current_block) &amp; positions):
&lt;       dropped += 1
&lt;       positions |= set(before_down_block)
&lt;       board_max_y = max(positions, key=lambda x: x[1])[1]
&lt;       current_block = [(x + shape_offset, y + board_max_y + 4) for x, y in shapes[shape_i]]
&lt;       shape_i = shape_i + 1 if shape_i &lt; len(shapes) - 1 else 0
</span><span class="p">---
</span><span class="gi">&gt; runs = 2
&gt; height_epoch_1 = []
&gt; height_epoch_x = []
&gt; si_1 = 0
&gt; si_difference = 0
&gt; blocks_1 = 0
&gt; blocks_difference = 0
&gt; while runs &gt; 0:
&gt;   s = sequence[s_i % len(sequence)]
&gt;   current_block = [(x + offset[s][0], y + offset[s][1]) for x, y in current_block]
&gt;   xs = sorted(current_block, key=lambda b: b[0])
&gt;   ys = sorted(current_block, key=lambda b: b[1])
&gt;   min_x, max_x = xs[0][0], xs[-1][0]
&gt;   min_y, max_y = ys[0][1], ys[-1][1]
</span><span class="p">40,41c37,45
</span><span class="gd">&lt;     if dropped &gt;= 2022:
&lt;       break
</span><span class="p">---
</span><span class="gi">&gt;   if min_x &lt; 0 or max_x &gt;= width or len(set(current_block) &amp; positions):
&gt;     current_block = [(x - offset[s][0], y - offset[s][1]) for x, y in current_block]
&gt;   before_down_block = current_block.copy()
&gt;   current_block = [(x, y - 1) for x, y in current_block]
&gt;
&gt;   if min_y &lt;= 0 or len(set(current_block) &amp; positions):
&gt;     dropped += 1
&gt;     positions |= set(before_down_block)
&gt;     new_max_y = max(positions, key=lambda x: x[1])[1]
</span><span class="p">43c47,86
</span><span class="gd">&lt; print(board_max_y + 1)
</span><span class="p">---
</span><span class="gi">&gt;     if runs == 2:
&gt;       height_epoch_1.append(new_max_y - board_max_y)
&gt;     else:
&gt;       height_epoch_x.append(new_max_y - board_max_y)
&gt;
&gt;     if (s_i + 1) % len(sequence) == 0:
&gt;       if runs == 2:
&gt;         si_1 = s_i
&gt;         blocks_1 = dropped
&gt;       else:
&gt;         si_difference = s_i - si_1
&gt;         blocks_difference = dropped - blocks_1
&gt;       runs -= 1
&gt;     board_max_y = max(positions, key=lambda x: x[1])[1]
&gt;     current_block = [(x + shape_offset, y + board_max_y + 4) for x, y in shapes[shape_i]]
&gt;     shape_i = shape_i + 1 if shape_i &lt; len(shapes) - 1 else 0
&gt;
&gt;   s_i += 1
&gt;   if runs &lt;= 0:
&gt;     break
&gt;
&gt; # Use the pattern to engineer the simulation
&gt; repeat_start_height = len(height_epoch_1)
&gt; repeat_height_difference = sum(height_epoch_x)
&gt;
&gt; estimated_height = int((1000000000000 - blocks_1) / blocks_difference) * repeat_height_difference
&gt; remaining_blocks = (1000000000000 - blocks_1) % blocks_difference
&gt;
&gt; remaining_height = 0
&gt; height_epoch_x_i = 0
&gt; while remaining_blocks &gt;= 0:
&gt;   remaining_height += height_epoch_x[height_epoch_x_i]
&gt;   remaining_blocks -= 1
&gt;   if height_epoch_x_i &gt;= len(height_epoch_x) - 1:
&gt;     height_epoch_x_i = 0
&gt;   else:
&gt;     height_epoch_x_i += 1
&gt;
&gt; height = int(estimated_height) + remaining_height + sum(height_epoch_1)
&gt; print(height)
</span></code></pre></div>    </div>

    <hr>

    <h1 id="day-18">Day 18</h1>

    <p>Lava and whatnot, oh my!</p>

    <h2 id="part-1-17">Part 1</h2>

    <p>So, we have a bunch of positions that represent whether it contains lava particles. We want to find the surface area of the lava particles that make up the water droplets.</p>

    <p>The problem, in programmer terms, is to accumulate (6 - number of edges) in all possible vertices of a graph.</p>

    <p>This straight-forward problem is broken down into a graph problem, which can be traversed using any of the graph traversal algorithms. Each missing edge (i.e. 6 - number of edges) count towards a global variable, which represents the solution.</p>

    <p>So, the solution is as follows:</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">queue</span> <span class="kn">import</span> <span class="n">Queue</span>
<span class="n">positions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">line</span><span class="p">.</span><span class="n">strip</span><span class="p">().</span><span class="n">split</span><span class="p">(</span><span class="s">','</span><span class="p">)))</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="s">'input.txt'</span><span class="p">,</span> <span class="s">'r'</span><span class="p">).</span><span class="n">readlines</span><span class="p">()])</span>

<span class="n">possibilities</span> <span class="o">=</span> <span class="p">[</span>
  <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
  <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="p">]</span>
<span class="n">area</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>

<span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">visited</span> <span class="o">&amp;</span> <span class="n">positions</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">):</span>
  <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">positions</span> <span class="o">-</span> <span class="n">visited</span><span class="p">).</span><span class="n">pop</span><span class="p">()</span>
  <span class="n">visited</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
  <span class="n">q</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

  <span class="k">while</span> <span class="ow">not</span> <span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">():</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">get</span><span class="p">()</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">dz</span><span class="p">)</span> <span class="ow">in</span> <span class="n">possibilities</span><span class="p">:</span>
      <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dx</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">dy</span><span class="p">,</span> <span class="n">z</span> <span class="o">+</span> <span class="n">dz</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">positions</span><span class="p">:</span>
        <span class="n">area</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="k">elif</span> <span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
        <span class="n">visited</span><span class="p">.</span><span class="n">add</span><span class="p">((</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">))</span>
        <span class="n">q</span><span class="p">.</span><span class="n">put</span><span class="p">((</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">))</span>

<span class="k">print</span><span class="p">(</span><span class="n">area</span><span class="p">)</span>
</code></pre></div>    </div>

    <h2 id="part-2-17">Part 2</h2>

    <p>Now, we want to only find the external surface area; meaning, any surface area that is surrounded by lava should not be considered. There were two main ways I could approach this:</p>

    <ol>
      <li>From each of the positions of the nodes, if the node can reach <code class="language-plaintext highlighter-rouge">0</code> in any dimension, or the maximum of any dimension, then accumulate the area. Otherwise, don’t accumulate the area.</li>
      <li>I perform BFS on everything outside the positions of the nodes instead. If the node is touching a position, then count that into our area. As BFS can only explore connected nodes, this means that each time <code class="language-plaintext highlighter-rouge">q</code> is empty, we have explored one connected body. A connected body that touches <code class="language-plaintext highlighter-rouge">0</code> in any dimension or maximum in any dimension must be a liquid / water vapour. Otherwise, it is trapped gas between all the positions.</li>
    </ol>

    <p>I decided to do step 2. So, I broke down the problem as:</p>

    <ol>
      <li>Get complement of the set of lava-filled positions</li>
      <li>Add padding of at least 1 in all dimensions</li>
      <li>Run through DFS, add extra condition that if the node is touching a position, count into area.</li>
    </ol>

    <p>So the diff to implement part 2 is:</p>

    <div class="language-diff highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="p">2c2,16
</span><span class="gd">&lt; positions = set([tuple(map(lambda x: int(x), line.strip().split(','))) for line in open('input.txt', 'r').readlines()])
</span><span class="p">---
</span><span class="gi">&gt; from itertools import product
&gt; positions = set()
&gt; max_x, max_y, max_z = 0, 0, 0
&gt; with open('input.txt', 'r') as f:
&gt;   line = f.readline().strip()
&gt;   while line:
&gt;     pos = tuple(map(lambda x: int(x), line.split(',')))
&gt;     max_x = max(max_x, pos[0])
&gt;     max_y = max(max_y, pos[1])
&gt;     max_z = max(max_z, pos[2])
&gt;
&gt;     positions.add(pos)
&gt;     line = f.readline().strip()
&gt;
&gt; positions_prime = {(x, y, z) for x, y, z in product(range(-1, max_x + 2), range(-1, max_y + 2), range(-1, max_z + 2)) if (x, y, z) not in positions}
</span><span class="p">12,13c26,27
</span><span class="gd">&lt; while len(visited &amp; positions) != len(positions):
&lt;   d = (positions - visited).pop()
</span><span class="p">---
</span><span class="gi">&gt; while len(visited &amp; positions_prime) != len(positions_prime):
&gt;   d = (positions_prime - visited).pop()
</span><span class="p">16a31,32
</span><span class="gi">&gt;   isOutside = False
&gt;   areaInContact = 0
</span><span class="p">19a36,38
</span><span class="gi">&gt;     if not (0 &lt; x &lt; max_x and 0 &lt; y &lt; max_y and 0 &lt; z &lt; max_z):
&gt;       isOutside = True
&gt;
</span><span class="p">22,24c41,44
</span><span class="gd">&lt;       if (nx, ny, nz) not in positions:
&lt;         area += 1
&lt;       elif (nx, ny, nz) not in visited:
</span><span class="p">---
</span><span class="gi">&gt;       if (nx, ny, nz) in positions:
&gt;         areaInContact += 1
&gt;
&gt;       if (nx, ny, nz) not in visited and (nx, ny, nz) in positions_prime:
</span><span class="p">26a47,49
</span><span class="gi">&gt;
&gt;   if isOutside:
&gt;     area += areaInContact
</span></code></pre></div>    </div>

    <hr>

    <h1 id="day-19">Day 19</h1>

    <p>Right, another entry down for the count. This day was quite similar to Day 16, because it involves doing a search on a space that is too large for comfort.</p>

    <h2 id="part-1-18">Part 1</h2>

    <p>So, we have a blueprint, which are defined like so:</p>

    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>Blueprint 1:
  Each ore robot costs 4 ore.
  Each clay robot costs 2 ore.
  Each obsidian robot costs 3 ore and 14 clay.
  Each geode robot costs 2 ore and 7 obsidian.

Blueprint 2:
  Each ore robot costs 2 ore.
  Each clay robot costs 3 ore.
  Each obsidian robot costs 3 ore and 8 clay.
  Each geode robot costs 3 ore and 12 obsidian.
</code></pre></div>    </div>

    <p>That allows us to build robots that gather resources to build even more robots to gather even more resources and so on. We start with 1 ore robot, and each robot will take 1 time unit to build, before it can contribute to our resource pool. Our goal is to calculate a score for each of the blueprint, and print out a linear combination of the score. The score is defined as the number of geodes the blueprint can possibly generate within 24 units of time.</p>

    <p>Following the pattern I saw in Day 16, I quickly eliminated the typical graph search algorithms, and decided that DFS was the way to go. So, let’s think about <em>when</em> we want to call DFS.</p>

    <p>A direct approach would be to, for every time unit, call DFS in an attempt to expend resources build every type of robot. Instinctively, I knew that this search space was too huge to consider.</p>

    <p>Instead, we have to do a <em>good enough</em> approximation of what <em>may</em> happen. Here are some considerations:</p>

    <ul>
      <li>If I’m being optimal about my robot-building, which I must be due to time unit limitation, I <em>should</em> only have enough resources to build a maximum of one robot per time unit. This eliminates the assumption that I could potentially concurrently build multiple robots in one go, as doing so would imply saving up for resources, which reduces contributions from the robots that could already have been built over the 24 time units.</li>
      <li>If, at any point of time, I am able to build a geode robot, I <strong>must</strong> do so, since I’m trying to maximize the number of geodes. I don’t even have to consider building any other robot in that minute.</li>
      <li>If, at any point of time, I am able to build a obsidian robot, I <em>should</em> do so, and ignore every other possibility. This assumption very rarely is false, as it is possible to save the resources for a greater benefit down the road. For this part, I assume the latter.</li>
      <li>If I am able to build a clay or ore robot, I should also consider saving resources for a greater benefit down the road.</li>
      <li>If, at any point of time, I have too much ore (which happens because DFS may keep choosing to save resources / build ore robots), I can completely prune the branch, because I am definitely getting further away from the objective.</li>
    </ul>

    <p>The considerations help to reduce the search space into something that is completes within reasonable time (~10 minutes), and doesn’t waste the CPU cycle looking at graphs that don’t matter in the grand scheme of things. Putting together all the considerations, and some trial and error later, I end up with the following implementation:</p>
    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="n">blueprints</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'input.txt'</span><span class="p">,</span> <span class="s">'r'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
  <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">strip</span><span class="p">()</span>
  <span class="k">while</span> <span class="n">line</span><span class="p">:</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">line</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)</span>
    <span class="n">blueprints</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">6</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">12</span><span class="p">]),</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">18</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">21</span><span class="p">])),</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">27</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">30</span><span class="p">]))))</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">strip</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">blueprint</span><span class="p">,</span> <span class="n">resources</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">bot_count</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">new_bot_count</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">minutes</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
  <span class="n">best_quality</span> <span class="o">=</span> <span class="p">(</span><span class="n">resources</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">resources</span><span class="p">,</span> <span class="n">bot_count</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">minutes</span> <span class="o">&gt;</span> <span class="mi">24</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">best_quality</span>

  <span class="n">ores</span><span class="p">,</span> <span class="n">clays</span><span class="p">,</span> <span class="n">obsidians</span><span class="p">,</span> <span class="n">geodes</span> <span class="o">=</span> <span class="n">resources</span>
  <span class="n">ore_bots</span><span class="p">,</span> <span class="n">clay_bots</span><span class="p">,</span> <span class="n">obsidian_bots</span><span class="p">,</span> <span class="n">geode_bots</span> <span class="o">=</span> <span class="n">bot_count</span>

  <span class="n">ores</span> <span class="o">+=</span> <span class="n">ore_bots</span>
  <span class="n">clays</span> <span class="o">+=</span> <span class="n">clay_bots</span>
  <span class="n">obsidians</span> <span class="o">+=</span> <span class="n">obsidian_bots</span>
  <span class="n">geodes</span> <span class="o">+=</span> <span class="n">geode_bots</span>

  <span class="n">bot_count</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bot_count</span><span class="p">,</span> <span class="n">new_bot_count</span><span class="p">)))</span>

  <span class="n">minutes</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="k">if</span> <span class="n">minutes</span> <span class="o">==</span> <span class="mi">24</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">geodes</span><span class="p">,</span> <span class="p">(</span><span class="n">ores</span><span class="p">,</span> <span class="n">clays</span><span class="p">,</span> <span class="n">obsidians</span><span class="p">,</span> <span class="n">geodes</span><span class="p">),</span> <span class="n">bot_count</span><span class="p">)</span>

  <span class="n">maximum_ores_required</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">blueprint</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">blueprint</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">blueprint</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">blueprint</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
  <span class="k">if</span> <span class="n">ores</span> <span class="o">&gt;=</span> <span class="n">blueprint</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">obsidians</span> <span class="o">&gt;=</span> <span class="n">blueprint</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
    <span class="n">quality</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">blueprint</span><span class="p">,</span> <span class="p">(</span><span class="n">ores</span> <span class="o">-</span> <span class="n">blueprint</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">clays</span><span class="p">,</span> <span class="n">obsidians</span> <span class="o">-</span> <span class="n">blueprint</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">geodes</span><span class="p">),</span>
      <span class="n">bot_count</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">minutes</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">quality</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">best_quality</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
      <span class="n">best_quality</span> <span class="o">=</span> <span class="n">quality</span>
  <span class="k">elif</span> <span class="n">ores</span> <span class="o">&gt;=</span> <span class="n">blueprint</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">clays</span> <span class="o">&gt;=</span> <span class="n">blueprint</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
    <span class="n">quality</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">blueprint</span><span class="p">,</span> <span class="p">(</span><span class="n">ores</span> <span class="o">-</span> <span class="n">blueprint</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">clays</span> <span class="o">-</span> <span class="n">blueprint</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">obsidians</span><span class="p">,</span> <span class="n">geodes</span><span class="p">),</span>
      <span class="n">bot_count</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">minutes</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">quality</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">best_quality</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
      <span class="n">best_quality</span> <span class="o">=</span> <span class="n">quality</span>

    <span class="n">quality</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">blueprint</span><span class="p">,</span> <span class="p">(</span><span class="n">ores</span><span class="p">,</span> <span class="n">clays</span><span class="p">,</span> <span class="n">obsidians</span><span class="p">,</span> <span class="n">geodes</span><span class="p">),</span> <span class="n">bot_count</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">minutes</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">quality</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">best_quality</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
      <span class="n">best_quality</span> <span class="o">=</span> <span class="n">quality</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">ores</span> <span class="o">&gt;=</span> <span class="n">blueprint</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
      <span class="n">quality</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">blueprint</span><span class="p">,</span> <span class="p">(</span><span class="n">ores</span> <span class="o">-</span> <span class="n">blueprint</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">clays</span><span class="p">,</span> <span class="n">obsidians</span><span class="p">,</span> <span class="n">geodes</span><span class="p">),</span>
        <span class="n">bot_count</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">minutes</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">quality</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">best_quality</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">best_quality</span> <span class="o">=</span> <span class="n">quality</span>

    <span class="c1"># snapback pruning: don't accumulate just ores
</span>    <span class="k">if</span> <span class="n">ores</span> <span class="o">&gt;=</span> <span class="n">blueprint</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">ores</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">maximum_ores_required</span><span class="p">:</span>
      <span class="n">quality</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">blueprint</span><span class="p">,</span> <span class="p">(</span><span class="n">ores</span> <span class="o">-</span> <span class="n">blueprint</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">clays</span><span class="p">,</span> <span class="n">obsidians</span><span class="p">,</span> <span class="n">geodes</span><span class="p">),</span>
        <span class="n">bot_count</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">minutes</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">quality</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">best_quality</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">best_quality</span> <span class="o">=</span> <span class="n">quality</span>

    <span class="n">quality</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">blueprint</span><span class="p">,</span> <span class="p">(</span><span class="n">ores</span><span class="p">,</span> <span class="n">clays</span><span class="p">,</span> <span class="n">obsidians</span><span class="p">,</span> <span class="n">geodes</span><span class="p">),</span> <span class="n">bot_count</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">minutes</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">quality</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">best_quality</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
      <span class="n">best_quality</span> <span class="o">=</span> <span class="n">quality</span>

  <span class="k">return</span> <span class="n">best_quality</span>

<span class="n">accum_quality</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">blueprint</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">blueprints</span><span class="p">):</span>
  <span class="n">quality</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">blueprint</span><span class="p">)</span>
  <span class="k">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">quality</span><span class="p">)</span>
  <span class="n">accum_quality</span> <span class="o">+=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">quality</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">print</span><span class="p">(</span><span class="n">accum_quality</span><span class="p">)</span>
</code></pre></div>    </div>

    <h2 id="part-2-18">Part 2</h2>

    <p>The question increased the depth of the tree by adjusting the time unit from 24 to 32, and cutting down the number of blueprints to search to 3. This is a significant adjustment, as increasing tree depth exponentially increases the number of nodes to traverse. Hence, to create an algorithm that completes within reasonable time, we need to make even more assumptions of what <em>may</em> happen.</p>

    <p>Based on observations, there are only a <em>few</em> blueprints with its highest number of geodes actually depending on saving resources whenever it could build an obsidian robot instead. Furthermore, by adjusting the time unit to 32, time can be wisely spent to build an obsidian robot, then providing resources to build a geode robot. Hence, the probability to save for resources when it could build an obsidian robot is decreased drastically.</p>

    <p>As it turns out, the assumptions are true in our particular case, and removing just that one possibility from the previous algorithm allowed my solution to complete within human time (also, the scoring function changed as required by the question):</p>

    <div class="language-diff highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="p">11c11
</span><span class="gd">&lt;   if minutes &gt; 24:
</span><span class="p">---
</span><span class="gi">&gt;   if minutes &gt; 32:
</span><span class="p">25c25
</span><span class="gd">&lt;   if minutes == 24:
</span><span class="p">---
</span><span class="gi">&gt;   if minutes == 32:
</span><span class="p">39,42d38
</span><span class="gd">&lt;
&lt;     quality = dfs(blueprint, (ores, clays, obsidians, geodes), bot_count, (0, 0, 0, 0), minutes)
&lt;     if quality[0] &gt; best_quality[0]:
&lt;       best_quality = quality
</span><span class="p">63c59
</span><span class="gd">&lt; accum_quality = 0
</span><span class="p">---
</span><span class="gi">&gt; accum_quality = 1
</span><span class="p">67c63
</span><span class="gd">&lt;   accum_quality += (i + 1) * quality[0]
</span><span class="p">---
</span><span class="gi">&gt;   accum_quality *= quality[0]
</span></code></pre></div>    </div>

    <p>Is there a faster way? Probably, using heuristics and the other search algorithms. Do I want to implement it? Not this year!</p>

    <hr>

    <h1 id="day-20">Day 20</h1>

    <p>This puzzle highlights the power of Python, because I don’t have to think about huge numbers at all. Having done Days 17, 18and 20 in a row, I didn’t bother trying to make the code run faster in Day 20; it’s plenty fast compared to all the graph traversal I’ve done!</p>

    <h2 id="part-1-19">Part 1</h2>

    <p>This problem is one of the easier ones among all of the challenges in AOC 2022 so far. Essentially, given a list of numbers, we need to rearrange the numbers such that each of the numbers are moved according to the value they represent. So, I solved it by:</p>

    <ol>
      <li>Adding an identifier to every number (since the numbers provided are not unique)</li>
      <li>Duplicating that list, calling it <code class="language-plaintext highlighter-rouge">mutable</code>
</li>
      <li>Referencing the original list, remove and insert the numbers in <code class="language-plaintext highlighter-rouge">mutable</code> based on the value of the int</li>
      <li>Access the elements in the array based on procedure described by the solution as required, and calculate the answer</li>
    </ol>

    <p>Here is code:</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="n">movements</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">line</span><span class="p">.</span><span class="n">strip</span><span class="p">()))</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s">'input.txt'</span><span class="p">,</span> <span class="s">'r'</span><span class="p">).</span><span class="n">readlines</span><span class="p">())]</span>
<span class="n">mutable</span> <span class="o">=</span> <span class="n">movements</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">zero_tuple</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">movements</span><span class="p">:</span>
  <span class="n">ind</span> <span class="o">=</span> <span class="n">mutable</span><span class="p">.</span><span class="n">index</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">m</span><span class="p">))</span>
  <span class="n">mutable</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>

  <span class="n">new_ind</span> <span class="o">=</span> <span class="n">ind</span> <span class="o">+</span> <span class="n">m</span>
  <span class="k">if</span> <span class="n">new_ind</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">movements</span><span class="p">):</span>
    <span class="n">new_ind</span> <span class="o">%=</span> <span class="nb">len</span><span class="p">(</span><span class="n">movements</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
  <span class="k">elif</span> <span class="n">new_ind</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">new_ind</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">movements</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
  <span class="n">mutable</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">new_ind</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">m</span><span class="p">))</span>

  <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">zero_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
<span class="n">zero_ind</span> <span class="o">=</span> <span class="n">mutable</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">zero_tuple</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">mutable</span><span class="p">[(</span><span class="n">zero_ind</span> <span class="o">+</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">movements</span><span class="p">)][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
  <span class="n">mutable</span><span class="p">[(</span><span class="n">zero_ind</span> <span class="o">+</span> <span class="mi">2000</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">movements</span><span class="p">)][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
  <span class="n">mutable</span><span class="p">[(</span><span class="n">zero_ind</span> <span class="o">+</span> <span class="mi">3000</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">movements</span><span class="p">)][</span><span class="mi">1</span><span class="p">])</span>
</code></pre></div>    </div>

    <h2 id="part-2-19">Part 2</h2>

    <p>The only thing that changed were the input numbers. In Python, integers have no bounds. Then, we just perform the mixing operation 10 times, so the code is almost the same, but indented to fit the new for loop:</p>

    <div class="language-diff highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="p">1c1
</span><span class="gd">&lt; movements = [(i, int(line.strip())) for i, line in enumerate(open('input.txt', 'r').readlines())]
</span><span class="p">---
</span><span class="gi">&gt; movements = [(i, 811589153 * int(line.strip())) for i, line in enumerate(open('input.txt', 'r').readlines())]
</span><span class="p">4,6c4,7
</span><span class="gd">&lt; for i, m in movements:
&lt;   ind = mutable.index((i, m))
&lt;   mutable.pop(ind)
</span><span class="p">---
</span><span class="gi">&gt; for _ in range(10):
&gt;   for i, m in movements:
&gt;     ind = mutable.index((i, m))
&gt;     mutable.pop(ind)
</span><span class="p">8,13c9,16
</span><span class="gd">&lt;   new_ind = ind + m
&lt;   if new_ind &gt; len(movements):
&lt;     new_ind %= len(movements) - 1
&lt;   elif new_ind &lt;= 0:
&lt;     new_ind += len(movements) - 1
&lt;   mutable.insert(new_ind, (i, m))
</span><span class="p">---
</span><span class="gi">&gt;     new_ind = ind + m
&gt;     if new_ind &gt; len(movements):
&gt;       new_ind %= len(movements) - 1
&gt;     elif new_ind &lt;= 0:
&gt;       new_ind += len(movements) - 1
&gt;       factor = ((-new_ind) // (len(movements) - 1)) + 1
&gt;       new_ind += (factor * (len(movements) - 1))
&gt;     mutable.insert(new_ind, (i, m))
</span><span class="p">15,16c18,19
</span><span class="gd">&lt;   if m == 0:
&lt;     zero_tuple = (i, m)
</span><span class="p">---
</span><span class="gi">&gt;     if m == 0:
&gt;       zero_tuple = (i, m)
</span></code></pre></div>    </div>

    <h2 id="note-on-optimization">Note on optimization</h2>

    <p>If I were to optimize this, it’ll probably be similar to Day 17; since finite sequences are involved, repeats are bound to happen. However, the effort-to-result ratio is probably not worth it.</p>

    <hr>

    <h1 id="day-21">Day 21</h1>

    <p>Today we have expression evaluations. It’s quite a simple day, although I spent an embarrassing amount of time trying to figure out why my part 2 solution didn’t work. More below.</p>

    <h2 id="part-1-20">Part 1</h2>

    <p>We have a bunch of expressions that uses a bunch of symbols, like so:</p>

    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>root: pppw + sjmn
dbpl: 5
cczh: sllz + lgvd
zczc: 2
ptdq: humn - dvpt
dvpt: 3
lfqf: 4
humn: 5
ljgn: 2
sjmn: drzm * dbpl
sllz: 4
pppw: cczh / lfqf
lgvd: ljgn * ptdq
drzm: hmdt - zczc
hmdt: 32
</code></pre></div>    </div>

    <p>All we have to do is to evaluate the value at <code class="language-plaintext highlighter-rouge">root</code>. Quite immediately, I got reminded of Prolog, which is a logic programming language that work on constraints. From what I know, Prolog does a depth-first search to obtain the results based on the constraints defined just like our input.</p>

    <p>So, I thought about using trees to express the expression. However, I quickly realised that it would take too much effort; instead, a much faster way is probably to use a hash table, where the key is the symbol to be evaluated, and the value is the expression to evaluate.</p>

    <p>Then, I jump to the root symbol, and recursively evaluate the constituent symbols until I figure out the final answer. Seems simple enough!</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="n">operation_map</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s">'+'</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span>
  <span class="s">'-'</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">,</span>
  <span class="s">'/'</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span><span class="p">,</span>
  <span class="s">'*'</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
<span class="p">}</span>

<span class="n">expressions</span> <span class="o">=</span> <span class="p">{</span><span class="n">expr</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">rstrip</span><span class="p">(</span><span class="s">':'</span><span class="p">):</span> <span class="n">expr</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="p">[</span><span class="n">line</span><span class="p">.</span><span class="n">strip</span><span class="p">().</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="s">'input.txt'</span><span class="p">).</span><span class="n">readlines</span><span class="p">()]}</span>
<span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">expr</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">isdigit</span><span class="p">():</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">expr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">operation_map</span><span class="p">[</span><span class="n">expr</span><span class="p">[</span><span class="mi">1</span><span class="p">]](</span><span class="n">evaluate</span><span class="p">(</span><span class="n">expressions</span><span class="p">[</span><span class="n">expr</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span>
      <span class="n">evaluate</span><span class="p">(</span><span class="n">expressions</span><span class="p">[</span><span class="n">expr</span><span class="p">[</span><span class="mi">2</span><span class="p">]]))</span>

<span class="k">print</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">evaluate</span><span class="p">(</span><span class="n">expressions</span><span class="p">[</span><span class="s">'root'</span><span class="p">])))</span>
</code></pre></div>    </div>

    <h2 id="part-2-20">Part 2</h2>

    <p>Part 2 redefines the problem:</p>

    <ul>
      <li>We now have an unknown within the symbols, which is <code class="language-plaintext highlighter-rouge">humn</code> (the original value of <code class="language-plaintext highlighter-rouge">humn</code> is now discarded)</li>
      <li>
<code class="language-plaintext highlighter-rouge">root</code> is now <code class="language-plaintext highlighter-rouge">a = b</code>.</li>
    </ul>

    <p>I decided to approach the problem mathematically, by performing inverse operations. Suppose we have an equation, <code class="language-plaintext highlighter-rouge">a = b op c</code>, where <code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code>, and <code class="language-plaintext highlighter-rouge">c</code> are unknowns. If we want to find the value of <code class="language-plaintext highlighter-rouge">b</code>, then we can rearrange the equation as: <code class="language-plaintext highlighter-rouge">b = a 'op c</code>. Then, we see how the new <code class="language-plaintext highlighter-rouge">root</code> fits into the picture; since <code class="language-plaintext highlighter-rouge">root</code> is essentially <code class="language-plaintext highlighter-rouge">lhs = rhs</code>, this implies that if:</p>

    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>root: a = c
a: x + y
c: b + z
</code></pre></div>    </div>

    <p>If, again, we want to find <code class="language-plaintext highlighter-rouge">b</code>, then <code class="language-plaintext highlighter-rouge">b = c - z</code>, and since <code class="language-plaintext highlighter-rouge">root: a = c</code>, so <code class="language-plaintext highlighter-rouge">b = a - z</code>, therefore <code class="language-plaintext highlighter-rouge">b = x + y - z</code>. So this means we need to consider the following to change our equation:</p>

    <ol>
      <li>Store associations in three different variants: <code class="language-plaintext highlighter-rouge">symbol = left op right</code>, <code class="language-plaintext highlighter-rouge">left = symbol op' right</code> and <code class="language-plaintext highlighter-rouge">right = symbol op' left</code>;</li>
      <li>Figure out the rules for how to get <code class="language-plaintext highlighter-rouge">op'</code>;</li>
      <li>For a target node, i.e. the variable <code class="language-plaintext highlighter-rouge">humn</code> in our case, find it within the associations <code class="language-plaintext highlighter-rouge">left = ...</code> or <code class="language-plaintext highlighter-rouge">right = ...</code>
</li>
      <li>Then, recursively evaluate <code class="language-plaintext highlighter-rouge">symbol</code> within the associations <code class="language-plaintext highlighter-rouge">left = ...</code> and <code class="language-plaintext highlighter-rouge">right = ...</code>. This will inverse our operators. For <code class="language-plaintext highlighter-rouge">right</code>, use the normal association <code class="language-plaintext highlighter-rouge">symbol = ...</code> to evaluate it.</li>
      <li>If we find that <code class="language-plaintext highlighter-rouge">symbol</code> is root, we evaluate the other operand with the normal association <code class="language-plaintext highlighter-rouge">symbol = ...</code>. This essentially does the operation <code class="language-plaintext highlighter-rouge">left = right</code> within our evaluation.</li>
      <li>Finally, once all the functions return, we end up with what <code class="language-plaintext highlighter-rouge">humn</code> must be.</li>
    </ol>

    <p>The main assumption being made here is that the input cannot repeat a symbol twice (specifically, not the target symbol we are finding). Otherwise, the inverse operation approach here probably wouldn’t work.</p>

    <p>Next, let’s figure out the rules to get <code class="language-plaintext highlighter-rouge">op</code>:</p>

    <ul>
      <li>If it’s <code class="language-plaintext highlighter-rouge">+</code>, then transmute it to <code class="language-plaintext highlighter-rouge">symbol - operand</code>
</li>
      <li>If it’s <code class="language-plaintext highlighter-rouge">*</code>, then transmute it to <code class="language-plaintext highlighter-rouge">symbol / operand</code>
</li>
      <li>If it’s <code class="language-plaintext highlighter-rouge">-</code>, then transmute it to <code class="language-plaintext highlighter-rouge">symbol + right_operand</code> and <code class="language-plaintext highlighter-rouge">symbol _ left_operand</code>, where <code class="language-plaintext highlighter-rouge">_</code> effectively performs <code class="language-plaintext highlighter-rouge">left_operand - symbol</code>. I forgot to this, which caused me an hour or so to discover, as this does not affect the example input <img class="emoji" title=":sweat_smile:" alt=":sweat_smile:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f605.png" height="20" width="20">
</li>
      <li>If it’s <code class="language-plaintext highlighter-rouge">/</code>, then transmute it to <code class="language-plaintext highlighter-rouge">symbol * right_operand</code> and <code class="language-plaintext highlighter-rouge">symbol \ left_operand</code> where <code class="language-plaintext highlighter-rouge">\</code> effectively performs <code class="language-plaintext highlighter-rouge">left_operand / symbol</code>. I remembered this, but unluckily for me it wasn’t used at all</li>
    </ul>

    <p>With that out of the way, we can finally implement it:</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="n">operation_map</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s">'+'</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span>
  <span class="s">'-'</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">,</span>
  <span class="s">'_'</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span> <span class="o">-</span> <span class="n">x</span><span class="p">,</span>
  <span class="s">'/'</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span><span class="p">,</span>
  <span class="s">'*'</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span>
  <span class="s">'</span><span class="se">\\</span><span class="s">'</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span> <span class="o">/</span> <span class="n">x</span>
<span class="p">}</span>

<span class="n">expressions</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">left_expressions</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">right_expressions</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'input.txt'</span><span class="p">,</span> <span class="s">'r'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
  <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">readline</span><span class="p">()</span>
  <span class="k">while</span> <span class="n">line</span><span class="p">:</span>
    <span class="n">tokens</span> <span class="o">=</span> <span class="n">line</span><span class="p">.</span><span class="n">strip</span><span class="p">().</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)</span>
    <span class="n">symbol</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">rstrip</span><span class="p">(</span><span class="s">':'</span><span class="p">)</span>
    <span class="n">expressions</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">isdigit</span><span class="p">():</span>
      <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
      <span class="n">op</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

      <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s">'+'</span><span class="p">:</span>
        <span class="n">left_expressions</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">symbol</span><span class="p">,</span> <span class="s">'-'</span><span class="p">,</span> <span class="n">right</span><span class="p">]</span>
        <span class="n">right_expressions</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">symbol</span><span class="p">,</span> <span class="s">'-'</span><span class="p">,</span> <span class="n">left</span><span class="p">]</span>
      <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s">'-'</span><span class="p">:</span>
        <span class="n">left_expressions</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">symbol</span><span class="p">,</span> <span class="s">'+'</span><span class="p">,</span> <span class="n">right</span><span class="p">]</span>
        <span class="n">right_expressions</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">symbol</span><span class="p">,</span> <span class="s">'_'</span><span class="p">,</span> <span class="n">left</span><span class="p">]</span>
      <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s">'/'</span><span class="p">:</span>
        <span class="n">left_expressions</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">symbol</span><span class="p">,</span> <span class="s">'*'</span><span class="p">,</span> <span class="n">right</span><span class="p">]</span>
        <span class="n">right_expressions</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">symbol</span><span class="p">,</span> <span class="s">'</span><span class="se">\\</span><span class="s">'</span><span class="p">,</span> <span class="n">left</span><span class="p">]</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">left_expressions</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">symbol</span><span class="p">,</span> <span class="s">'/'</span><span class="p">,</span> <span class="n">right</span><span class="p">]</span>
        <span class="n">right_expressions</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">symbol</span><span class="p">,</span> <span class="s">'/'</span><span class="p">,</span> <span class="n">left</span><span class="p">]</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">readline</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">expr</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">isdigit</span><span class="p">():</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">expr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">operation_map</span><span class="p">[</span><span class="n">expr</span><span class="p">[</span><span class="mi">1</span><span class="p">]](</span><span class="n">evaluate</span><span class="p">(</span><span class="n">expressions</span><span class="p">[</span><span class="n">expr</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span>
      <span class="n">evaluate</span><span class="p">(</span><span class="n">expressions</span><span class="p">[</span><span class="n">expr</span><span class="p">[</span><span class="mi">2</span><span class="p">]]))</span>

<span class="k">def</span> <span class="nf">evaluate_unknown</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">left_expressions</span><span class="p">:</span>
    <span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">operand</span><span class="p">)</span> <span class="o">=</span> <span class="n">left_expressions</span><span class="p">[</span><span class="n">expr</span><span class="p">]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">operand</span><span class="p">)</span> <span class="o">=</span> <span class="n">right_expressions</span><span class="p">[</span><span class="n">expr</span><span class="p">]</span>
  <span class="k">if</span> <span class="n">symbol</span> <span class="o">==</span> <span class="s">'root'</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">evaluate</span><span class="p">(</span><span class="n">expressions</span><span class="p">[</span><span class="n">operand</span><span class="p">])</span>
  <span class="k">return</span> <span class="n">operation_map</span><span class="p">[</span><span class="n">op</span><span class="p">](</span><span class="n">evaluate_unknown</span><span class="p">(</span><span class="n">symbol</span><span class="p">),</span> <span class="n">evaluate</span><span class="p">(</span><span class="n">expressions</span><span class="p">[</span><span class="n">operand</span><span class="p">]))</span>

<span class="k">print</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">evaluate_unknown</span><span class="p">(</span><span class="s">'humn'</span><span class="p">)))</span>
</code></pre></div>    </div>

    <hr>

    <h1 id="day-22">Day 22</h1>

    <p>I’m embarrassed to say this, but I spent <em>way</em> too long on this day, even though it should be fundamentally simple.</p>

    <h2 id="part-1-21">Part 1</h2>

    <p>Part 1’s context is actually quite simple; given a maze-like structure, navigate it with the instructions given in the input. If, during any point of navigation, the navigator falls off, then we warp the navigator to the other side of the map.</p>

    <p>So, we just need to consider the min x, max x, min y and max y to do the problem. Here is a helpful snippet to print the boards being traversed:</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">print_board</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">instruction</span><span class="p">):</span>
  <span class="k">print</span><span class="p">(</span><span class="s">'</span><span class="se">\033</span><span class="s">[2J'</span><span class="p">)</span>
  <span class="k">print</span><span class="p">(</span><span class="s">'</span><span class="se">\033</span><span class="s">[H'</span><span class="p">)</span>
  <span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">instruction</span><span class="p">)</span>
  <span class="n">y_output</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span> <span class="o">//</span> <span class="mi">50</span><span class="p">)</span> <span class="o">*</span> <span class="mi">50</span>
  <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">y_output</span><span class="p">,</span> <span class="n">y_output</span> <span class="o">+</span> <span class="mi">50</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">boundary_xs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
          <span class="k">print</span><span class="p">(</span><span class="s">'&gt;'</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">''</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
          <span class="k">print</span><span class="p">(</span><span class="s">'v'</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">''</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
          <span class="k">print</span><span class="p">(</span><span class="s">'&lt;'</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">''</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
          <span class="k">print</span><span class="p">(</span><span class="s">'^'</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">''</span><span class="p">)</span>
      <span class="k">elif</span> <span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span> <span class="ow">in</span> <span class="n">tiles</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">tiles</span><span class="p">[(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">)],</span> <span class="n">end</span><span class="o">=</span><span class="s">''</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">' '</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">''</span><span class="p">)</span>
    <span class="k">print</span><span class="p">()</span>
  <span class="k">print</span><span class="p">()</span>
  <span class="k">print</span><span class="p">()</span>
  <span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
</code></pre></div>    </div>

    <p>With some level of consideration to speed, I’ve decided to sacrifice my otherwise very free RAM to store way more dictionaries and lists than I really needed to. Here is how I solved it in the end:</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="nb">reduce</span>

<span class="n">tiles</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">boundary_xs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="n">boundary_ys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="n">instructions</span> <span class="o">=</span> <span class="s">''</span>
<span class="n">start_pos</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">movement_map</span> <span class="o">=</span> <span class="p">[</span>
  <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
  <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
  <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
  <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="p">]</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'input.txt'</span><span class="p">,</span> <span class="s">'r'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
  <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">rstrip</span><span class="p">()</span>
  <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">while</span> <span class="n">line</span><span class="p">:</span>
    <span class="n">min_x</span><span class="p">,</span> <span class="n">max_x</span> <span class="o">=</span> <span class="mi">999</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="s">' '</span><span class="p">:</span>
        <span class="n">tiles</span><span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span> <span class="o">=</span> <span class="n">c</span>
        <span class="n">min_x</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">min_x</span><span class="p">)</span>
        <span class="n">max_x</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">max_x</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">boundary_ys</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
          <span class="n">boundary_ys</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">boundary_ys</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">[(</span><span class="mi">999</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
        <span class="n">boundary_ys</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">boundary_ys</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span><span class="p">),</span>
          <span class="nb">max</span><span class="p">(</span><span class="n">boundary_ys</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">start_pos</span> <span class="o">==</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
          <span class="n">start_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

    <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">rstrip</span><span class="p">()</span>
    <span class="n">boundary_xs</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">min_x</span><span class="p">,</span> <span class="n">max_x</span><span class="p">))</span>
    <span class="n">y</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="n">instructions</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">a</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">]</span> <span class="k">if</span> <span class="n">y</span> <span class="o">!=</span> <span class="s">'L'</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">!=</span> <span class="s">'R'</span> <span class="k">else</span>  <span class="n">a</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="s">''</span><span class="p">],</span> <span class="n">f</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">strip</span><span class="p">(),</span> <span class="p">[</span><span class="s">''</span><span class="p">])</span>

<span class="n">direction</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">start_pos</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">instruction</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">instructions</span><span class="p">):</span>
  <span class="n">steps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">instruction</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instructions</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">instruction</span><span class="p">)</span>
  <span class="n">min_x</span><span class="p">,</span> <span class="n">max_x</span> <span class="o">=</span> <span class="n">boundary_xs</span><span class="p">[</span><span class="n">y</span><span class="p">]</span>
  <span class="n">min_y</span><span class="p">,</span> <span class="n">max_y</span> <span class="o">=</span> <span class="n">boundary_ys</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
  <span class="k">while</span> <span class="n">steps</span><span class="p">:</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">movement_map</span><span class="p">[</span><span class="n">direction</span><span class="p">]</span>
    <span class="n">new_x</span><span class="p">,</span> <span class="n">new_y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">diff</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span> <span class="o">+</span> <span class="n">diff</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">tiles</span> <span class="ow">and</span> <span class="p">(</span><span class="n">new_x</span><span class="p">,</span> <span class="n">new_y</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tiles</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">new_x</span> <span class="o">&gt;</span> <span class="n">max_x</span><span class="p">:</span>
        <span class="n">new_x</span> <span class="o">=</span> <span class="n">min_x</span>
        <span class="k">continue</span>
      <span class="k">elif</span> <span class="n">new_x</span> <span class="o">&gt;</span> <span class="n">min_x</span><span class="p">:</span>
        <span class="n">new_x</span> <span class="o">=</span> <span class="n">new_x</span> <span class="o">+</span> <span class="n">diff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
      <span class="k">elif</span> <span class="n">new_x</span> <span class="o">&lt;</span> <span class="n">min_x</span><span class="p">:</span>
        <span class="n">new_x</span> <span class="o">=</span> <span class="n">max_x</span>
        <span class="k">continue</span>

      <span class="k">if</span> <span class="n">new_y</span> <span class="o">&gt;</span> <span class="n">max_y</span><span class="p">:</span>
        <span class="n">new_y</span> <span class="o">=</span> <span class="n">min_y</span>
        <span class="k">continue</span>
      <span class="k">elif</span> <span class="n">new_y</span> <span class="o">&gt;</span> <span class="n">min_y</span><span class="p">:</span>
        <span class="n">new_y</span> <span class="o">=</span> <span class="n">new_y</span> <span class="o">+</span> <span class="n">diff</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
      <span class="k">elif</span> <span class="n">new_y</span> <span class="o">&lt;</span> <span class="n">min_y</span><span class="p">:</span>
        <span class="n">new_y</span> <span class="o">=</span> <span class="n">max_y</span>
        <span class="k">continue</span>

    <span class="k">if</span> <span class="n">tiles</span><span class="p">[(</span><span class="n">new_x</span><span class="p">,</span> <span class="n">new_y</span><span class="p">)]</span> <span class="o">==</span> <span class="s">'#'</span><span class="p">:</span>
      <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">new_x</span><span class="p">,</span> <span class="n">new_y</span>
      <span class="n">steps</span> <span class="o">-=</span> <span class="mi">1</span>

  <span class="n">dirchange</span> <span class="o">=</span> <span class="n">instruction</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instructions</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">else</span> <span class="bp">None</span>
  <span class="k">if</span> <span class="n">dirchange</span> <span class="o">==</span> <span class="s">'L'</span><span class="p">:</span>
    <span class="n">direction</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">direction</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">direction</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">movement_map</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">dirchange</span> <span class="o">==</span> <span class="s">'R'</span><span class="p">:</span>
    <span class="n">direction</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">direction</span> <span class="o">%=</span> <span class="nb">len</span><span class="p">(</span><span class="n">movement_map</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="mi">1000</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">direction</span><span class="p">)</span>
</code></pre></div>    </div>

    <h2 id="part-2-21">Part 2</h2>

    <p>Now the maze becomes a cube. I first tried to map the co-ordinates to 3D, which was fine, until I realised I needed to find a way to fold the cube. After hours of thinking, drawing stuff till I went insane, I decided it was not worth the hassle.</p>

    <p>So I decided to hard-code the relationship between each side in the cube. However, because there is no generalization, debugging exactly <em>what</em> went wrong was ungodly. Thankfully, someone who has solved this beforehand provided a great cube visualizer that I used to debug my script, written by <a href="https://nanot1m.github.io/adventofcode2022/day22/index.html" target="_blank" rel="noopener noreferrer">nanot1m</a>. I also ran my script against another solution to check the output per instruction, only to find out that one of my functions that mapped the sides have the wrong offset.</p>

    <p>So after roughly 5 hours, here is the final code:</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="nb">reduce</span>
<span class="n">face_width</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">tiles</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">boundary_xs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="n">boundary_ys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="n">instructions</span> <span class="o">=</span> <span class="s">''</span>
<span class="n">start_pos</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">movement_map</span> <span class="o">=</span> <span class="p">[</span>
  <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
  <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
  <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
  <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="p">]</span>

<span class="n">cube_connection_operations</span> <span class="o">=</span> <span class="p">{</span>
  <span class="mi">1</span><span class="p">:</span> <span class="p">[</span>
    <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="c1"># 2
</span>    <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="c1"># 3
</span>    <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">50</span> <span class="o">+</span> <span class="p">(</span><span class="mi">49</span> <span class="o">-</span> <span class="n">y</span><span class="p">),</span> <span class="mi">0</span><span class="p">),</span> <span class="c1"># 4
</span>    <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span> <span class="o">%</span> <span class="mi">50</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># 6
</span>  <span class="p">],</span>
  <span class="mi">2</span><span class="p">:</span> <span class="p">[</span>
    <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">50</span> <span class="o">+</span> <span class="p">(</span><span class="mi">49</span> <span class="o">-</span> <span class="n">y</span><span class="p">),</span> <span class="mi">2</span><span class="p">),</span> <span class="c1"># 5
</span>    <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="mi">99</span><span class="p">,</span> <span class="mi">50</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span> <span class="o">%</span> <span class="mi">50</span><span class="p">),</span> <span class="mi">2</span><span class="p">),</span> <span class="c1"># 3
</span>    <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="c1"># 1
</span>    <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span> <span class="o">%</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">50</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="c1"># 6
</span>  <span class="p">],</span>
  <span class="mi">3</span><span class="p">:</span> <span class="p">[</span>
    <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">50</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">%</span> <span class="mi">50</span><span class="p">),</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="c1"># 2
</span>    <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="c1"># 5
</span>    <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="n">y</span> <span class="o">%</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="c1"># 4
</span>    <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="c1"># 1
</span>  <span class="p">],</span>
  <span class="mi">4</span><span class="p">:</span> <span class="p">[</span>
    <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="c1"># 5
</span>    <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="c1"># 6
</span>    <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="p">(</span><span class="mi">49</span> <span class="o">-</span> <span class="p">(</span><span class="n">y</span> <span class="o">%</span> <span class="mi">50</span><span class="p">)),</span> <span class="mi">0</span><span class="p">),</span> <span class="c1"># 1
</span>    <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="c1"># 3
</span>  <span class="p">],</span>
  <span class="mi">5</span><span class="p">:</span> <span class="p">[</span>
    <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="mi">149</span><span class="p">,</span> <span class="p">(</span><span class="mi">49</span> <span class="o">-</span> <span class="p">(</span><span class="n">y</span> <span class="o">%</span> <span class="mi">50</span><span class="p">)),</span> <span class="mi">2</span><span class="p">),</span> <span class="c1"># 2
</span>    <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="mi">49</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">50</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span> <span class="o">%</span> <span class="mi">50</span><span class="p">),</span> <span class="mi">2</span><span class="p">),</span> <span class="c1"># 6
</span>    <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="c1"># 4
</span>    <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="c1"># 3
</span>  <span class="p">],</span>
  <span class="mi">6</span><span class="p">:</span> <span class="p">[</span>
    <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="mi">50</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">%</span> <span class="mi">50</span><span class="p">),</span> <span class="mi">149</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="c1"># 5
</span>    <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="c1"># 2
</span>    <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="mi">50</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">%</span> <span class="mi">50</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="c1"># 1
</span>    <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1"># 4
</span>  <span class="p">]</span>
<span class="p">}</span>

<span class="n">cube_toplefts</span> <span class="o">=</span> <span class="mi">6</span> <span class="o">*</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'input.txt'</span><span class="p">,</span> <span class="s">'r'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
  <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">rstrip</span><span class="p">()</span>
  <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">while</span> <span class="n">line</span><span class="p">:</span>
    <span class="n">min_x</span><span class="p">,</span> <span class="n">max_x</span> <span class="o">=</span> <span class="mi">999</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="s">' '</span><span class="p">:</span>
        <span class="n">tiles</span><span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span> <span class="o">=</span> <span class="n">c</span>
        <span class="n">min_x</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">min_x</span><span class="p">)</span>
        <span class="n">max_x</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">max_x</span><span class="p">)</span>

        <span class="n">side_exist</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">topleft</span> <span class="ow">in</span> <span class="n">cube_toplefts</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">topleft</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">tx</span><span class="p">,</span> <span class="n">ty</span> <span class="o">=</span> <span class="n">topleft</span>
            <span class="k">if</span> <span class="n">tx</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">tx</span> <span class="o">+</span> <span class="n">face_width</span> <span class="ow">and</span> <span class="n">ty</span> <span class="o">&lt;=</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">ty</span> <span class="o">+</span> <span class="n">face_width</span><span class="p">:</span>
              <span class="n">side_exist</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">side_exist</span><span class="p">:</span>
          <span class="n">cube_toplefts</span><span class="p">[</span><span class="n">cube_toplefts</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="bp">None</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">boundary_ys</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
          <span class="n">boundary_ys</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">boundary_ys</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">[(</span><span class="mi">999</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
        <span class="n">boundary_ys</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">boundary_ys</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span><span class="p">),</span>
          <span class="nb">max</span><span class="p">(</span><span class="n">boundary_ys</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">start_pos</span> <span class="o">==</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
          <span class="n">start_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

    <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">rstrip</span><span class="p">()</span>
    <span class="n">boundary_xs</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">min_x</span><span class="p">,</span> <span class="n">max_x</span><span class="p">))</span>
    <span class="n">y</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="n">instructions</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">a</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">]</span> <span class="k">if</span> <span class="n">y</span> <span class="o">!=</span> <span class="s">'L'</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">!=</span> <span class="s">'R'</span> <span class="k">else</span>  <span class="n">a</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="s">''</span><span class="p">],</span> <span class="n">f</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">strip</span><span class="p">(),</span> <span class="p">[</span><span class="s">''</span><span class="p">])</span>

<span class="n">direction</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">start_pos</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">instruction</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">instructions</span><span class="p">):</span>
  <span class="n">steps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">instruction</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instructions</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">instruction</span><span class="p">)</span>
  <span class="n">min_x</span><span class="p">,</span> <span class="n">max_x</span> <span class="o">=</span> <span class="n">boundary_xs</span><span class="p">[</span><span class="n">y</span><span class="p">]</span>
  <span class="n">min_y</span><span class="p">,</span> <span class="n">max_y</span> <span class="o">=</span> <span class="n">boundary_ys</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>

  <span class="n">cube_side</span> <span class="o">=</span> <span class="n">cube_toplefts</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">topleft</span><span class="p">:</span> <span class="n">topleft</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">topleft</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">face_width</span> <span class="ow">and</span> <span class="n">topleft</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">topleft</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">face_width</span><span class="p">,</span> <span class="n">cube_toplefts</span><span class="p">)))</span>

  <span class="k">while</span> <span class="n">steps</span><span class="p">:</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">movement_map</span><span class="p">[</span><span class="n">direction</span><span class="p">]</span>
    <span class="n">new_x</span><span class="p">,</span> <span class="n">new_y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">diff</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span> <span class="o">+</span> <span class="n">diff</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">new_direction</span> <span class="o">=</span> <span class="n">direction</span>
    <span class="n">topleft</span> <span class="o">=</span> <span class="n">cube_toplefts</span><span class="p">[</span><span class="n">cube_side</span><span class="p">]</span>
    <span class="n">fell_out</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">(</span><span class="n">topleft</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">new_x</span> <span class="o">&lt;</span> <span class="n">topleft</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">face_width</span> <span class="ow">and</span> <span class="n">topleft</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">new_y</span> <span class="o">&lt;</span> <span class="n">topleft</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">face_width</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fell_out</span><span class="p">:</span>
      <span class="n">new_x</span><span class="p">,</span> <span class="n">new_y</span><span class="p">,</span> <span class="n">new_direction</span> <span class="o">=</span> <span class="n">cube_connection_operations</span><span class="p">[</span><span class="n">cube_side</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">direction</span><span class="p">](</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">tiles</span><span class="p">[(</span><span class="n">new_x</span><span class="p">,</span> <span class="n">new_y</span><span class="p">)]</span> <span class="o">==</span> <span class="s">'#'</span><span class="p">:</span>
      <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">direction</span> <span class="o">=</span> <span class="n">new_x</span><span class="p">,</span> <span class="n">new_y</span><span class="p">,</span> <span class="n">new_direction</span>
      <span class="n">cube_side</span> <span class="o">=</span> <span class="n">cube_toplefts</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">topleft</span><span class="p">:</span> <span class="n">topleft</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">topleft</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">face_width</span> <span class="ow">and</span> <span class="n">topleft</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">topleft</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">face_width</span><span class="p">,</span> <span class="n">cube_toplefts</span><span class="p">)))</span>
      <span class="n">steps</span> <span class="o">-=</span> <span class="mi">1</span>

  <span class="n">dirchange</span> <span class="o">=</span> <span class="n">instruction</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instructions</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">else</span> <span class="bp">None</span>
  <span class="k">if</span> <span class="n">dirchange</span> <span class="o">==</span> <span class="s">'L'</span><span class="p">:</span>
    <span class="n">direction</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">direction</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">direction</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">movement_map</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">dirchange</span> <span class="o">==</span> <span class="s">'R'</span><span class="p">:</span>
    <span class="n">direction</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">direction</span> <span class="o">%=</span> <span class="nb">len</span><span class="p">(</span><span class="n">movement_map</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="mi">1000</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">direction</span><span class="p">)</span>
</code></pre></div>    </div>

    <p>It’s ugly, the process is error-prone, I’m tired, this’ll do. I’ve put off plans for this man!</p>

    <hr>

    <h1 id="day-23">Day 23</h1>

    <p>Today’s puzzle was much more manageable than the previous days! TGIF &amp; Merry Christmas, amirite?</p>

    <h2 id="part-1-22">Part 1</h2>

    <p>We follow our hero’s journey as we now have to scatter elves in a fixed way. I spent roughly 30 minutes debugging why my code didn’t work, only to realise that I haven’t fully digested the specifications. Lesson learnt!</p>

    <p>Okay so, we have an input like this:</p>

    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>....#..
..###.#
#...#.#
.#...##
#.###..
##.#.##
.#..#..
</code></pre></div>    </div>

    <p>Each little hashtag moves according to a certain set of rules, which varies by the round number. The rules are:</p>

    <ol>
      <li>Check all 8 positions to the side of hashtag. If no hashtag, do not move.</li>
      <li>Check north, north-east, north-west. If there is another hashtag there, move on. Otherwise, attempt to move north.</li>
      <li>Check south, south-east, south-west. Attempt to move south if no hashtag.</li>
      <li>Check west, north-west, south-west. Attempt to move west if no hashtag.</li>
      <li>Check east, north-east, south-east. Attempt to move east if no hashtag.</li>
      <li>Otherwise, do not move.</li>
    </ol>

    <p>“Attempt” to move can become “actually” moved if all hashtags end up having unique positions.</p>

    <p>After every round of movement, steps 2 to 5 are rearranged to 3, 4, 5, 2. Essentially the first considered position is now the last considered position, and the second becomes the first, and so on.</p>

    <p>With that, here’s a helpful little function to print the board:</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">print_board</span><span class="p">():</span>
  <span class="k">print</span><span class="p">(</span><span class="s">'</span><span class="se">\033</span><span class="s">[0J'</span><span class="p">)</span>
  <span class="k">print</span><span class="p">(</span><span class="s">'</span><span class="se">\033</span><span class="s">[H'</span><span class="p">)</span>
  <span class="n">pos_sorted_x</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">positions</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
  <span class="n">pos_sorted_y</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">positions</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

  <span class="n">min_x</span><span class="p">,</span> <span class="n">max_x</span> <span class="o">=</span> <span class="n">pos_sorted_x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">pos_sorted_x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">min_y</span><span class="p">,</span> <span class="n">max_y</span> <span class="o">=</span> <span class="n">pos_sorted_y</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">pos_sorted_y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
  <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">min_y</span><span class="p">,</span> <span class="n">max_y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">min_x</span><span class="p">,</span> <span class="n">max_x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">positions</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'#'</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">''</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'.'</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">''</span><span class="p">)</span>
    <span class="k">print</span><span class="p">()</span>
</code></pre></div>    </div>

    <p>And here is the solution:</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="n">positions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'input.txt'</span><span class="p">,</span> <span class="s">'r'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
  <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">strip</span><span class="p">()</span>
  <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span>

  <span class="k">while</span> <span class="n">line</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="s">'#'</span><span class="p">:</span>
        <span class="n">positions</span><span class="p">.</span><span class="n">add</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
    <span class="n">y</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">strip</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">generate_decisions</span><span class="p">(</span><span class="n">rounds</span><span class="p">):</span>
  <span class="n">decisions</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">positions</span><span class="p">:</span>
    <span class="n">intersect_results</span> <span class="o">=</span> <span class="p">[</span>
      <span class="nb">len</span><span class="p">({(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)}</span> <span class="o">&amp;</span> <span class="n">positions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span>
      <span class="nb">len</span><span class="p">({(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)}</span> <span class="o">&amp;</span> <span class="n">positions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span>
      <span class="nb">len</span><span class="p">({(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)}</span> <span class="o">&amp;</span> <span class="n">positions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span>
      <span class="nb">len</span><span class="p">({(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)}</span> <span class="o">&amp;</span> <span class="n">positions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">intersect_results</span><span class="p">):</span>
      <span class="n">decisions</span><span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
      <span class="k">continue</span>

    <span class="k">for</span> <span class="n">iterator</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">intersect_results</span><span class="p">)):</span>
      <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">rounds</span> <span class="o">+</span> <span class="n">iterator</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">intersect_results</span><span class="p">)</span>

      <span class="n">match</span> <span class="n">i</span><span class="p">:</span>
        <span class="n">case</span> <span class="mi">0</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">intersect_results</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">decisions</span><span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">break</span>
        <span class="n">case</span> <span class="mi">1</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">intersect_results</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">decisions</span><span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">break</span>
        <span class="n">case</span> <span class="mi">2</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">intersect_results</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
            <span class="n">decisions</span><span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="k">break</span>
        <span class="n">case</span> <span class="mi">3</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">intersect_results</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
            <span class="n">decisions</span><span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="k">break</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">decisions</span><span class="p">:</span>
      <span class="n">decisions</span><span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">decisions</span>

<span class="k">def</span> <span class="nf">count_empty</span><span class="p">():</span>
  <span class="n">pos_sorted_x</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">positions</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
  <span class="n">pos_sorted_y</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">positions</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

  <span class="n">min_x</span><span class="p">,</span> <span class="n">max_x</span> <span class="o">=</span> <span class="n">pos_sorted_x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">pos_sorted_x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">min_y</span><span class="p">,</span> <span class="n">max_y</span> <span class="o">=</span> <span class="n">pos_sorted_y</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">pos_sorted_y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

  <span class="k">return</span> <span class="p">((</span><span class="n">max_x</span> <span class="o">-</span> <span class="n">min_x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_y</span> <span class="o">-</span> <span class="n">min_y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>

<span class="n">rounds</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="n">rounds</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
  <span class="n">decisions</span> <span class="o">=</span> <span class="n">generate_decisions</span><span class="p">(</span><span class="n">rounds</span><span class="p">)</span>
  <span class="n">hits</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
  <span class="n">new_positions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

  <span class="k">for</span> <span class="n">result_pos</span> <span class="ow">in</span> <span class="n">decisions</span><span class="p">.</span><span class="n">values</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">result_pos</span> <span class="ow">in</span> <span class="n">hits</span><span class="p">:</span>
      <span class="n">hits</span><span class="p">[</span><span class="n">result_pos</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">hits</span><span class="p">[</span><span class="n">result_pos</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

  <span class="k">for</span> <span class="n">original_pos</span><span class="p">,</span> <span class="n">result_pos</span> <span class="ow">in</span> <span class="n">decisions</span><span class="p">.</span><span class="n">items</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">hits</span><span class="p">[</span><span class="n">result_pos</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">new_positions</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">original_pos</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">new_positions</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">result_pos</span><span class="p">)</span>
  
  <span class="n">positions</span> <span class="o">=</span> <span class="n">new_positions</span>
  <span class="n">rounds</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="k">print</span><span class="p">(</span><span class="n">count_empty</span><span class="p">())</span>
</code></pre></div>    </div>

    <h2 id="part-2-22">Part 2</h2>

    <p>Today’s part two is the most natural out of all the part twos I have attempted in this year’s AOC. Simply, we remove the boundaries of rounds, and figure out when all the hashtags run out of moves. So, basically, we just keep running until <code class="language-plaintext highlighter-rouge">positions == new_positions</code>. Hence, our diff would be:</p>

    <div class="language-diff highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="p">61c61
</span><span class="gd">&lt; while rounds &lt; 10:
</span><span class="p">---
</span><span class="gi">&gt; while True:
</span><span class="p">78d77
</span><span class="gd">&lt;   positions = new_positions
</span><span class="p">79a79,81
</span><span class="gi">&gt;   if positions == new_positions:
&gt;     break
&gt;   positions = new_positions
</span><span class="p">81c83
</span><span class="gd">&lt; print(count_empty())
</span><span class="p">---
</span><span class="gi">&gt; print(rounds)
</span></code></pre></div>    </div>

    <p>It’s not the fastest piece of code ever, but for the amount of effort I put in, being able to get the answer in five seconds is reasonable enough.</p>

    <hr>

    <h1 id="day-24">Day 24</h1>

    <p>Today’s puzzle is about path-finding, but on crack.</p>

    <h2 id="part-1-23">Part 1</h2>

    <p>Let’s examine an example:</p>

    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>#.######
#&gt;&gt;.&lt;^&lt;#
#.&lt;..&lt;&lt;#
#&gt;v.&gt;&lt;&gt;#
#&lt;^v^^&gt;#
######.#
</code></pre></div>    </div>

    <p>The arrows, which are <code class="language-plaintext highlighter-rouge">&gt;v&lt;^</code> are moving obstacles in the board, moving towards the direction suggested by the arrows. These arrows can overlap, and warp around the board. Our goal is to perform path-finding through this board, and output the <strong>shortest possible path</strong>.</p>

    <p>Okay, what’s the best method? The first method I immediately thought of is to implement a path searching algorithm, and find the shortest path at every step. <em>However</em>, this is largely inefficient, because when there are as many obstacles as shown in the board above, then too much effort is put into re-calculating the path at every step due to obstacles to the path.</p>

    <p>Instead, let’s include the moving obstacles into our path search algorithm; at every step, we clone the board, move the obstacles, figure out the best next step, and repeat the process ad-infinitum until we reach the target position. To effectively do this, we must invent an algorithm that quickly converges to the target position, without searching unnecessary paths.</p>

    <p>For this, I chose to use A* search.</p>

    <p>As usual, here is a useful function to print the board:</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">print_board</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">hs</span><span class="p">,</span> <span class="n">steps</span><span class="p">):</span>
  <span class="k">print</span><span class="p">(</span><span class="s">'</span><span class="se">\033</span><span class="s">[2J'</span><span class="p">)</span>
  <span class="k">print</span><span class="p">(</span><span class="s">'</span><span class="se">\033</span><span class="s">[H'</span><span class="p">)</span>
  <span class="k">print</span><span class="p">(</span><span class="s">'Steps:'</span><span class="p">,</span> <span class="n">steps</span><span class="p">)</span>
  <span class="n">px</span><span class="p">,</span> <span class="n">py</span> <span class="o">=</span> <span class="n">p</span>
  <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">height</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">):</span>
      <span class="k">if</span> <span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="n">start_position</span><span class="p">)</span> <span class="ow">or</span> <span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="n">end_position</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">px</span><span class="p">,</span> <span class="n">py</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
          <span class="k">print</span><span class="p">(</span><span class="s">'E'</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">''</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="k">print</span><span class="p">(</span><span class="s">' '</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">''</span><span class="p">)</span>
        <span class="k">continue</span>

      <span class="k">if</span> <span class="n">x</span> <span class="o">%</span> <span class="p">(</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'#'</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">''</span><span class="p">)</span>
      <span class="k">elif</span> <span class="n">y</span> <span class="o">%</span> <span class="p">(</span><span class="n">height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'#'</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">''</span><span class="p">)</span>
      <span class="k">elif</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="n">p</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'E'</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">''</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">hasDir</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">lastDir</span> <span class="o">=</span> <span class="s">'^'</span>
        <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">directions</span><span class="p">):</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="n">hs</span><span class="p">:</span>
            <span class="n">lastDir</span> <span class="o">=</span> <span class="n">directions</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
            <span class="n">hasDir</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">hasDir</span><span class="p">:</span>
          <span class="k">print</span><span class="p">(</span><span class="s">'.'</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">''</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">hasDir</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
          <span class="k">print</span><span class="p">(</span><span class="n">hasDir</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">''</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="k">print</span><span class="p">(</span><span class="n">lastDir</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">''</span><span class="p">)</span>
    <span class="k">print</span><span class="p">()</span>
  <span class="k">print</span><span class="p">()</span>
  <span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
</code></pre></div>    </div>

    <p>And here is the search implemented:</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">queue</span> <span class="kn">import</span> <span class="n">PriorityQueue</span>

<span class="n">directions</span> <span class="o">=</span> <span class="s">'&gt;v&lt;^'</span>
<span class="n">directions_movement</span> <span class="o">=</span> <span class="p">[</span>
  <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
  <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
  <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
  <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
  <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">]</span>
<span class="n">hurricanes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="n">width</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'input.txt'</span><span class="p">,</span> <span class="s">'r'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
  <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">strip</span><span class="p">()</span>
  <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">width</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
  <span class="k">while</span> <span class="n">line</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">directions</span><span class="p">:</span>
         <span class="n">hurricanes</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">directions</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">c</span><span class="p">)))</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">readline</span><span class="p">().</span><span class="n">strip</span><span class="p">()</span>
    <span class="n">y</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="n">height</span> <span class="o">=</span> <span class="n">y</span>

<span class="k">def</span> <span class="nf">move</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">isPlayer</span><span class="p">):</span>
  <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">c</span>  <span class="o">=</span> <span class="n">pos</span>
  <span class="n">diff</span> <span class="o">=</span> <span class="n">directions_movement</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
  <span class="n">x</span> <span class="o">+=</span> <span class="n">diff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">y</span> <span class="o">+=</span> <span class="n">diff</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

  <span class="k">if</span> <span class="n">isPlayer</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">width</span> <span class="o">-</span> <span class="mi">2</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="k">elif</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">width</span> <span class="o">-</span> <span class="mi">2</span>

  <span class="k">if</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="n">height</span> <span class="o">-</span> <span class="mi">2</span><span class="p">:</span>
    <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="k">elif</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">height</span> <span class="o">-</span> <span class="mi">2</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

<span class="n">start_position</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">end_position</span> <span class="o">=</span> <span class="p">(</span><span class="n">width</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">PriorityQueue</span><span class="p">()</span>

<span class="n">p</span><span class="p">.</span><span class="n">put</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">start_position</span><span class="p">,</span> <span class="n">hurricanes</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="n">found</span> <span class="o">=</span> <span class="bp">False</span>

<span class="k">while</span> <span class="ow">not</span> <span class="n">p</span><span class="p">.</span><span class="n">empty</span><span class="p">():</span>
  <span class="n">old_heuristic</span><span class="p">,</span> <span class="p">(</span><span class="n">px</span><span class="p">,</span> <span class="n">py</span><span class="p">),</span> <span class="n">current_hurricanes</span><span class="p">,</span> <span class="n">steps</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">get</span><span class="p">()</span>
  <span class="n">steps</span> <span class="o">+=</span> <span class="mi">1</span>

  <span class="c1"># move hurricanes
</span>  <span class="n">new_hurricanes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
  <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">current_hurricanes</span><span class="p">:</span>
    <span class="n">new_hurricanes</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="bp">False</span><span class="p">))</span>

  <span class="c1"># attempt to move
</span>  <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">direction</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">directions_movement</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">move</span><span class="p">((</span><span class="n">px</span><span class="p">,</span> <span class="n">py</span><span class="p">,</span> <span class="n">c</span><span class="p">),</span> <span class="bp">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="n">end_position</span><span class="p">:</span>
      <span class="n">found</span> <span class="o">=</span> <span class="bp">True</span>
      <span class="k">break</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">width</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
      <span class="k">continue</span>

    <span class="n">collides</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">hx</span><span class="p">,</span> <span class="n">hy</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">new_hurricanes</span><span class="p">:</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">hx</span><span class="p">,</span> <span class="n">hy</span><span class="p">):</span>
        <span class="n">collides</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">break</span>
    <span class="k">if</span> <span class="n">collides</span><span class="p">:</span>
      <span class="k">continue</span>

    <span class="n">new_heuristic</span> <span class="o">=</span> <span class="n">steps</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">end_position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">end_position</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">steps</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
      <span class="n">p</span><span class="p">.</span><span class="n">put</span><span class="p">((</span><span class="n">new_heuristic</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">new_hurricanes</span><span class="p">,</span> <span class="n">steps</span><span class="p">))</span>
      <span class="n">visited</span><span class="p">.</span><span class="n">add</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">steps</span><span class="p">))</span>

  <span class="k">if</span> <span class="n">found</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span>
    <span class="k">break</span>
</code></pre></div>    </div>

    <h2 id="part-2-23">Part 2</h2>

    <p>In part 2, I found a bug in my original code. If, right out of the gate, there is a hurricane blocking the path of the starting position, then the A* search will return prematurely with no results:</p>

    <div class="language-python highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>    <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="n">end_position</span><span class="p">:</span>
      <span class="n">found</span> <span class="o">=</span> <span class="bp">True</span>
      <span class="k">break</span>
</code></pre></div>    </div>

    <p>To fix this, I simply check if the current position is the starting position; if it is, the subsequent block of code is executed, which has “stay still” as one of the possible actions to take.</p>

    <p>Hence, after fixing the bug, I just move all of the path finding code to its own function, which will return the number of steps taken and the state of the board, and call it three times; once from start -&gt; end, end -&gt; start and start -&gt; end again.</p>

    <p>Here is the final diff:</p>

    <div class="language-diff highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="p">46,49c46,67
</span><span class="gd">&lt; start_position = (1, 0)
&lt; end_position = (width - 2, height - 1)
&lt; visited = set()
&lt; p = PriorityQueue()
</span><span class="p">---
</span><span class="gi">&gt; def astar(start_position, end_position, hurricanes):
&gt;   visited = set()
&gt;   p = PriorityQueue()
&gt;
&gt;   p.put((0, start_position, hurricanes, 0))
&gt;   found = False
&gt;
&gt;   while not p.empty():
&gt;     old_heuristic, (px, py), current_hurricanes, steps = p.get()
&gt;     steps += 1
&gt;
&gt;     # move hurricanes
&gt;     new_hurricanes = list()
&gt;     for pos in current_hurricanes:
&gt;       new_hurricanes.append(move(pos, False))
&gt;
&gt;     # attempt to move
&gt;     for c, direction in enumerate(directions_movement):
&gt;       x, y, _ = move((px, py, c), True)
&gt;       if (x, y) == end_position:
&gt;         found = True
&gt;         break
</span><span class="p">51,52c69,84
</span><span class="gd">&lt; p.put((0, start_position, hurricanes, 0))
&lt; found = False
</span><span class="p">---
</span><span class="gi">&gt;       if not (0 &lt; x &lt; width - 1 and 0 &lt; y &lt; height - 1) \
&gt;         and (x, y) != start_position:
&gt;         continue
&gt;
&gt;       collides = False
&gt;       for (hx, hy, _) in new_hurricanes:
&gt;         if (x, y) == (hx, hy):
&gt;           collides = True
&gt;           break
&gt;       if collides:
&gt;         continue
&gt;
&gt;       new_heuristic = steps + abs(end_position[0] - x) + abs(end_position[1] - y)
&gt;       if (x, y, steps) not in visited:
&gt;         p.put((new_heuristic, (x, y), new_hurricanes, steps))
&gt;         visited.add((x, y, steps))
</span><span class="p">54,67c86,87
</span><span class="gd">&lt; while not p.empty():
&lt;   old_heuristic, (px, py), current_hurricanes, steps = p.get()
&lt;   steps += 1
&lt;
&lt;   # move hurricanes
&lt;   new_hurricanes = list()
&lt;   for pos in current_hurricanes:
&lt;     new_hurricanes.append(move(pos, False))
&lt;
&lt;   # attempt to move
&lt;   for c, direction in enumerate(directions_movement):
&lt;     x, y, _ = move((px, py, c), True)
&lt;     if (x, y) == end_position:
&lt;       found = True
</span><span class="p">---
</span><span class="gi">&gt;     if found:
&gt;       return current_hurricanes, steps
</span><span class="p">70,88c90,95
</span><span class="gd">&lt;     if not (0 &lt; x &lt; width - 1 and 0 &lt; y &lt; height - 1):
&lt;       continue
&lt;
&lt;     collides = False
&lt;     for (hx, hy, _) in new_hurricanes:
&lt;       if (x, y) == (hx, hy):
&lt;         collides = True
&lt;         break
&lt;     if collides:
&lt;       continue
&lt;
&lt;     new_heuristic = steps + abs(end_position[0] - x) + abs(end_position[1] - y)
&lt;     if (x, y, steps) not in visited:
&lt;       p.put((new_heuristic, (x, y), new_hurricanes, steps))
&lt;       visited.add((x, y, steps))
&lt;
&lt;   if found:
&lt;     print(steps)
&lt;     break
</span><span class="p">---
</span><span class="gi">&gt; start_position = (1, 0)
&gt; end_position = (width - 2, height - 1)
&gt; hurricanes, steps = astar(start_position, end_position, hurricanes)
&gt; hurricanes, backsteps = astar(end_position, start_position, hurricanes)
&gt; hurricanes, backbacksteps = astar(start_position, end_position, hurricanes)
&gt; print(backbacksteps + backsteps + steps - 2)
</span></code></pre></div>    </div>
    <hr>

  </div>
</div>

<h1 id="day-25">Day 25</h1>

<p>There’s only one part to this puzzle; and it’s probably the most fun I had in a puzzle thus far!</p>

<p>Nothing like alternate number representations to end of the advent eh? In this puzzle, we have a bunch of alien-looking numbers, like so:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1=-0-2
12111
2=0=
21
2=01
111
20012
112
1=-1=
1-12
12
1=
122
</code></pre></div></div>

<p>We eventually find out that each of these numbers are in base 5, but with a twist (as there usually is); <code class="language-plaintext highlighter-rouge">-</code> and <code class="language-plaintext highlighter-rouge">=</code> represent -1 and -2 respectively, and the maximum digit that can be represented is 2. From a list of these integers, we need to sum it out, and return our sum in the same format.</p>

<p>Okay, so there are two subproblems:</p>

<ol>
  <li>Converting this integer representation to base 10;</li>
  <li>Converting base 10 integers to this integer representation.</li>
</ol>

<p>The first sub-problem is really simple. All we have to do is to sum the value represented by each digit position, negative and all that: so, for example, <code class="language-plaintext highlighter-rouge">1=-0-2</code> can converted to an integer by this method: <code class="language-plaintext highlighter-rouge">2 + (-1) * 5 + 0 * 5^2 + (-1) ^ 5^3 + (-2) ^ 5^4 + 1 * 5^5 = 1747</code>. In Haskell, this is a <code class="language-plaintext highlighter-rouge">foldr</code> zipped with the position of each digit, something like that:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">snafuToInt</span> <span class="o">::</span> <span class="kt">SNAFU</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">snafuToInt</span> <span class="o">=</span> <span class="n">foldr</span> <span class="n">convert</span> <span class="mi">0</span> <span class="o">.</span> <span class="n">enumerate</span>
  <span class="kr">where</span>
    <span class="n">convert</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">digit</span><span class="p">)</span> <span class="n">acc</span> <span class="o">=</span> <span class="n">acc</span> <span class="o">+</span> <span class="p">(</span><span class="mi">5</span> <span class="o">^</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">snafuDigitToInt</span> <span class="n">digit</span><span class="p">)</span>
    <span class="n">enumerate</span> <span class="n">xs</span> <span class="o">=</span> <span class="n">zip</span><span class="p">[(</span><span class="n">length</span> <span class="n">xs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">length</span> <span class="n">xs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">..</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="n">xs</span>
</code></pre></div></div>

<p>where <code class="language-plaintext highlighter-rouge">SNAFU</code> is just a <code class="language-plaintext highlighter-rouge">String</code>, <code class="language-plaintext highlighter-rouge">snafuDigitToInt</code> converts <code class="language-plaintext highlighter-rouge">-=012</code> to an integer, like <code class="language-plaintext highlighter-rouge">-1, -2, 0, 1, 2</code>.</p>

<p>To approach the second sub-problem, we must understand that we are in a situation where we need to perform <em>differences</em> to convert a normal base 10 integer to this strange version of an integer. Okay, what if it was to a normal base 5 integer? Normally, we would need to perform the following:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1747 % 5 = 2 (last digit is 2)

1747 / 5 = 349
349 % 5 = 4 (fourth digit is 4)

349 / 5 = 69
69 % 5 = 4 (third digit is 4)

69 / 5 = 13
13 % 5 = 3 (second digit is 3)

13 / 5 = 2
2 % 5 = 2 (first digit is 2)
</code></pre></div></div>

<p>As such, our base 5 reprsentation of 1747 is 23442. Now, let’s think about how our number system changes things. If we now want to represent, say, 8, in normal base 5, that would be <code class="language-plaintext highlighter-rouge">1 * 5^1 + 3</code>. In our unique representation, it’s <code class="language-plaintext highlighter-rouge">2 * 5^1 - 2</code>, whch means <code class="language-plaintext highlighter-rouge">2=</code>. We discover that the difference is actually just <code class="language-plaintext highlighter-rouge">1 * 5^1 + (3 - 5) + 5 = 2 * 5^1 - 2</code>, which is <code class="language-plaintext highlighter-rouge">2=</code>. Okay, what a bout a smaller number, like 6? That’s <code class="language-plaintext highlighter-rouge">1 * 5^1 + 1</code> for both normal base 5, and our unique base 5 (<code class="language-plaintext highlighter-rouge">11</code>).</p>

<p>Hence, we find out that should our normal base 5 digit exceed <code class="language-plaintext highlighter-rouge">2</code>, we need to perform <code class="language-plaintext highlighter-rouge">(5 - digit)</code> on it, to get the correct representation at that point. But doing so will offset our answer by 5; how do we intend to fix that? Let’s think about a larger number, say <code class="language-plaintext highlighter-rouge">74</code>. This is <code class="language-plaintext highlighter-rouge">2 * 5^2 + 4 * 5^1 + 4 * 5^0</code> in normal base 5. Using our logic above, to represent this in our unique number, we see that: <code class="language-plaintext highlighter-rouge">2 * 5^2 + (4 - 5) * 5^1 + (4 - 5) * 5^0</code> which is offset by <code class="language-plaintext highlighter-rouge">+ 5 * 5^1 + 5 * 5^0</code>, missing from the expression. Wait, isn’t that just <code class="language-plaintext highlighter-rouge">5^2 + 5^1</code>? If we apply this back to the unique number expression, then: <code class="language-plaintext highlighter-rouge">3 * 5^2 + (4 - 5 + 1) * 5^1 - 1 * 5^0</code>, which is just <code class="language-plaintext highlighter-rouge">3 * 5^2 - 1</code> which is <code class="language-plaintext highlighter-rouge">5*5^2 + (5 - 3) * 5 ^ 2 - 1</code>, which is <code class="language-plaintext highlighter-rouge">5^3 - 2*5^2 - 1</code> which finally translates to <code class="language-plaintext highlighter-rouge">1=0-</code> in our special integer representation.</p>

<p>What this whole shtick implies is that we need to <em>carry over</em> a 1 to the next significant digit, as long as our base 5 representation exceeds the maximum digit, 2.</p>

<p>With that finally out of the way, we can implement our logic:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">intToSnafu</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">SNAFU</span>
<span class="n">intToSnafu</span> <span class="n">x</span> <span class="o">=</span> <span class="n">reverse</span> <span class="o">$</span> <span class="n">convertDigits</span> <span class="n">x</span> <span class="mi">0</span> <span class="kt">[]</span>
  <span class="kr">where</span>
    <span class="n">convertDigits</span> <span class="n">num</span> <span class="n">carry</span> <span class="n">xs</span>
      <span class="o">|</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">carry</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">=</span> <span class="kt">[]</span>
      <span class="o">|</span> <span class="n">num'</span> <span class="o">+</span> <span class="n">carry</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">=</span> <span class="n">intToSnafuDigit</span> <span class="p">(</span><span class="n">num'</span> <span class="o">+</span> <span class="n">carry</span> <span class="o">-</span> <span class="mi">5</span><span class="p">)</span> <span class="o">:</span> <span class="n">convertDigits</span> <span class="n">num''</span> <span class="mi">1</span> <span class="n">xs</span>
      <span class="o">|</span> <span class="n">otherwise</span> <span class="o">=</span> <span class="n">intToSnafuDigit</span> <span class="p">(</span><span class="n">num'</span> <span class="o">+</span> <span class="n">carry</span><span class="p">)</span> <span class="o">:</span> <span class="n">convertDigits</span> <span class="n">num''</span> <span class="mi">0</span> <span class="n">xs</span>
      <span class="kr">where</span>
        <span class="n">num'</span> <span class="o">=</span> <span class="n">num</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">5</span>
        <span class="n">num''</span> <span class="o">=</span> <span class="n">floor</span> <span class="o">$</span> <span class="p">((</span><span class="n">fromIntegral</span> <span class="n">num</span><span class="p">)</span> <span class="o">/</span> <span class="mi">5</span><span class="p">)</span>
</code></pre></div></div>

<p>I’m reversing the list because I don’t want to do <code class="language-plaintext highlighter-rouge">++ []</code>, which increases my time complexity, however much that matters. Now that we have both of our conversion functions, we can finally do the problem, which is to sum all the numbers together in our special base 5 representation. The full code is as follows:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">import</span> <span class="nn">System.IO</span>

<span class="kr">type</span> <span class="kt">SNAFUDigit</span> <span class="o">=</span> <span class="kt">Char</span>
<span class="kr">type</span> <span class="kt">SNAFU</span> <span class="o">=</span> <span class="kt">String</span>

<span class="n">snafuDigitToInt</span> <span class="o">::</span> <span class="kt">SNAFUDigit</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">snafuDigitToInt</span> <span class="sc">'='</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
<span class="n">snafuDigitToInt</span> <span class="sc">'-'</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="n">snafuDigitToInt</span> <span class="sc">'0'</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">snafuDigitToInt</span> <span class="sc">'1'</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">snafuDigitToInt</span> <span class="sc">'2'</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">intToSnafuDigit</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">SNAFUDigit</span>
<span class="n">intToSnafuDigit</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="sc">'='</span>
<span class="n">intToSnafuDigit</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="sc">'-'</span>
<span class="n">intToSnafuDigit</span> <span class="mi">0</span> <span class="o">=</span> <span class="sc">'0'</span>
<span class="n">intToSnafuDigit</span> <span class="mi">1</span> <span class="o">=</span> <span class="sc">'1'</span>
<span class="n">intToSnafuDigit</span> <span class="mi">2</span> <span class="o">=</span> <span class="sc">'2'</span>

<span class="n">snafuToInt</span> <span class="o">::</span> <span class="kt">SNAFU</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">snafuToInt</span> <span class="o">=</span> <span class="n">foldr</span> <span class="n">convert</span> <span class="mi">0</span> <span class="o">.</span> <span class="n">enumerate</span>
  <span class="kr">where</span>
    <span class="n">convert</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">digit</span><span class="p">)</span> <span class="n">acc</span> <span class="o">=</span> <span class="n">acc</span> <span class="o">+</span> <span class="p">(</span><span class="mi">5</span> <span class="o">^</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">snafuDigitToInt</span> <span class="n">digit</span><span class="p">)</span>
    <span class="n">enumerate</span> <span class="n">xs</span> <span class="o">=</span> <span class="n">zip</span><span class="p">[(</span><span class="n">length</span> <span class="n">xs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">length</span> <span class="n">xs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">..</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="n">xs</span>

<span class="n">intToSnafu</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">SNAFU</span>
<span class="n">intToSnafu</span> <span class="n">x</span> <span class="o">=</span> <span class="n">reverse</span> <span class="o">$</span> <span class="n">convertDigits</span> <span class="n">x</span> <span class="mi">0</span> <span class="kt">[]</span>
  <span class="kr">where</span>
    <span class="n">convertDigits</span> <span class="n">num</span> <span class="n">carry</span> <span class="n">xs</span>
      <span class="o">|</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">carry</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">=</span> <span class="kt">[]</span>
      <span class="o">|</span> <span class="n">num'</span> <span class="o">+</span> <span class="n">carry</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">=</span> <span class="n">intToSnafuDigit</span> <span class="p">(</span><span class="n">num'</span> <span class="o">+</span> <span class="n">carry</span> <span class="o">-</span> <span class="mi">5</span><span class="p">)</span> <span class="o">:</span> <span class="n">convertDigits</span> <span class="n">num''</span> <span class="mi">1</span> <span class="n">xs</span>
      <span class="o">|</span> <span class="n">otherwise</span> <span class="o">=</span> <span class="n">intToSnafuDigit</span> <span class="p">(</span><span class="n">num'</span> <span class="o">+</span> <span class="n">carry</span><span class="p">)</span> <span class="o">:</span> <span class="n">convertDigits</span> <span class="n">num''</span> <span class="mi">0</span> <span class="n">xs</span>
      <span class="kr">where</span>
        <span class="n">num'</span> <span class="o">=</span> <span class="n">num</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">5</span>
        <span class="n">num''</span> <span class="o">=</span> <span class="n">floor</span> <span class="o">$</span> <span class="p">((</span><span class="n">fromIntegral</span> <span class="n">num</span><span class="p">)</span> <span class="o">/</span> <span class="mi">5</span><span class="p">)</span>

<span class="n">main</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">contents</span> <span class="o">&lt;-</span> <span class="n">readFile</span> <span class="s">"input.txt"</span>
  <span class="kr">let</span> <span class="n">result</span> <span class="o">=</span> <span class="n">intToSnafu</span> <span class="o">.</span> <span class="n">sum</span> <span class="o">.</span> <span class="n">map</span> <span class="n">snafuToInt</span> <span class="o">$</span> <span class="n">lines</span> <span class="n">contents</span>
  <span class="n">print</span> <span class="n">result</span>
</code></pre></div></div>

<p>And with that, we’ve completed Advent of Code 2022, the first time ever I’ve done so!</p>

<p><img src="/images/20221225_2.png" style="max-width: 400px; width: 100%; margin: 0 auto; display: block;" alt="Advent of Code 2022 Diagram"></p>
<p class="text-center text-gray lh-condensed-ultra f6">Advent of Code Calendar 2022</p>

<hr>

<h1 id="conclusion">Conclusion</h1>

<p>I’ll probably update this blog post for formatting, English and clearer explanations after Christmas, but I will not change the published date.</p>

<p>AOC has been a fun experience for me to hone my skills in a way that did not feel too overbearing, yet fun and engaging. The puzzles taught me a lot, highlighting things that I should improve on. In a nutshell, the lessons were:</p>

<ul>
  <li>Fully understand the problem statement first</li>
  <li>Trust gut instinct on what <em>kind</em> of data structure is needed</li>
  <li>Using gut instinct, pen down how the algorithm will be like. Don’t try to fit everything in your head</li>
  <li>Test code regularly. If possible, test automatically</li>
</ul>

<p>I hope to do AOC next year too, hopefully with less mistakes!</p>

<p>Merry Christmas and Happy 2023, folks.</p>

<p>Happy Coding,</p>

<p>CodingIndex</p>

  </div>

    </div>
  </div>

    <footer>
      <div class="container-md p-3 text-gray text-center">
        <p>Copyright © CodingIndex 2023</p>
      </div>
    </footer>
  </body>
</html>

